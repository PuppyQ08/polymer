SUBROUTINE TWOINDEX_V(DERI,N,Q)
! CALCULATE AND STORE TWO-CENTER TWO-ELECTRON ELECTRON REPULSION INTEGRALS
! USING THE OBARA-SAIKA RECURSION METHOD.  THIS SUBROUTINE WORKS CORRECTLY 
! ONLY WHEN HELIX EQUALS TO ZERO.

   USE CONTROL
   USE STRUCTURE
   USE BASISSET
   USE AUXILIARY
   USE INTEGRAL
   USE GRADIENT
   USE FMT
   USE CONSTANTS
   
   IMPLICIT NONE
   INTEGER :: N,Q
   INTEGER :: I,J,II,JJ,I1,I2,I3,J1,J2,J3
   INTEGER :: TS,M,MMAX
   DOUBLE PRECISION :: PISUB1,PISUB2
   DOUBLE PRECISION :: AX,AY,AZ,BX,BY,BZ,PX,PY,PZ,C
   DOUBLE PRECISION :: COMZ,GZI,H,T
   DOUBLE PRECISION :: PISUB,F1(0:7),F2(0:7)
   DOUBLE PRECISION,ALLOCATABLE :: ERI(:,:,:,:,:,:,:)
   DOUBLE PRECISION :: DERI(N,N)

   ALLOCATE(ERI(0:7,0:3,0:3,0:3,0:3,0:3,0:3))

   IF (HELIX /= 0.0D0) CALL PABORT('AN INTERNAL PROGRAM ERROR IS DETECTED')

   ! PRELIMINARY
   PISUB1=2.0D0/DSQRT(PI)
   PISUB2=2.0D0*DSQRT(PI)**5
   F1(0)=1.0D0/PISUB1
   F1(1)=1.0D0/2.0D0/PISUB1
   F1(2)=3.0D0/4.0D0/PISUB1
   F1(3)=15.0D0/8.0D0/PISUB1
   F1(4)=105.0D0/16.0D0/PISUB1
   F1(5)=945.0D0/32.0D0/PISUB1
   F1(6)=10395.0D0/64.0D0/PISUB1
   F1(7)=135135.0D0/128.0D0/PISUB1
   F2(0)=-0.5D0
   F2(1)=-1.5D0
   F2(2)=-2.5D0
   F2(3)=-3.5D0
   F2(4)=-4.5D0
   F2(5)=-5.5D0
   F2(6)=-6.5D0
   F2(7)=-7.5D0

   ! ZERO SCRATCH
   ERI(0:7,0:3,0:3,0:3,0:3,0:3,0:3)=0.0D0
   DERI=0.0D0

   DO I=1,NASHELL
    II=A_SHELL(I,0,0,0)
    AX=AGSX(II)
    AY=AGSY(II)
    AZ=AGSZ(II)
    DO J=1,NASHELL
     JJ=A_SHELL(J,0,0,0)
     BX=AGSX(JJ)+DFLOAT(Q)*PERIOD
     BY=AGSY(JJ)
     BZ=AGSZ(JJ)
     COMZ=AZT(II)+AZT(JJ)
     GZI=AZT(II)*AZT(JJ)/COMZ
     T=GZI*((AX-BX)**2+(AY-BY)**2+(AZ-BZ)**2)
     C=PISUB2/DSQRT(COMZ)/AZT(II)/AZT(JJ)
     DO M=0,A_SHELL_ANG(I)+A_SHELL_ANG(J)
      IF (T < TF(M)) THEN
       TS=NINT(T*20.0D0)
       H=0.05D0*DFLOAT(TS)-T
       ERI(M,0,0,0,0,0,0)=((((((IGAMMA(TS,M+6)*H*0.166666666666667D0+IGAMMA(TS,M+5))*H*0.2D0+IGAMMA(TS,M+4))*H*0.25D0+ &
       IGAMMA(TS,M+3))*H*0.333333333333333D0+IGAMMA(TS,M+2))*H*0.5D0+IGAMMA(TS,M+1))*H+IGAMMA(TS,M))*C
      ELSE
       ERI(M,0,0,0,0,0,0)=C*F1(M)*DEXP(F2(M)*DLOG(T))
      ENDIF
     ENDDO

     PX=(AX*AZT(II)+BX*AZT(JJ))/COMZ
     PY=(AY*AZT(II)+BY*AZT(JJ))/COMZ
     PZ=(AZ*AZT(II)+BZ*AZT(JJ))/COMZ

     DO I1=0,A_SHELL_ANG(I)
      DO I2=0,A_SHELL_ANG(I)-I1
       DO I3=0,A_SHELL_ANG(I)-I1-I2
        DO J1=0,A_SHELL_ANG(J)
         DO J2=0,A_SHELL_ANG(J)-J1
          DO J3=0,A_SHELL_ANG(J)-J1-J2
           MMAX=A_SHELL_ANG(I)+A_SHELL_ANG(J)-I1-I2-I3-J1-J2-J3
           IF (I1+I2+I3+J1+J2+J3 == 0) CYCLE
           DO M=0,MMAX
            IF (I1 >= 1) THEN
             ERI(M,I1,I2,I3,J1,J2,J3)=(PX-AX)*ERI(M+1,I1-1,I2,I3,J1,J2,J3)
             IF (I1 >= 2) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+ &
                          0.5D0*DFLOAT(I1-1)/AZT(II)*(ERI(M,I1-2,I2,I3,J1,J2,J3)-GZI/AZT(II)*ERI(M+1,I1-2,I2,I3,J1,J2,J3))
             IF (J1 >= 1) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J1)/COMZ*ERI(M+1,I1-1,I2,I3,J1-1,J2,J3)
            ELSE IF (I2 >= 1) THEN
             ERI(M,I1,I2,I3,J1,J2,J3)=(PY-AY)*ERI(M+1,I1,I2-1,I3,J1,J2,J3)
             IF (I2 >= 2) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+ &
                          0.5D0*DFLOAT(I2-1)/AZT(II)*(ERI(M,I1,I2-2,I3,J1,J2,J3)-GZI/AZT(II)*ERI(M+1,I1,I2-2,I3,J1,J2,J3))
             IF (J2 >= 1) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J2)/COMZ*ERI(M+1,I1,I2-1,I3,J1,J2-1,J3)
            ELSE IF (I3 >= 1) THEN
             ERI(M,I1,I2,I3,J1,J2,J3)=(PZ-AZ)*ERI(M+1,I1,I2,I3-1,J1,J2,J3)
             IF (I3 >= 2) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+ &
                          0.5D0*DFLOAT(I3-1)/AZT(II)*(ERI(M,I1,I2,I3-2,J1,J2,J3)-GZI/AZT(II)*ERI(M+1,I1,I2,I3-2,J1,J2,J3))
             IF (J3 >= 1) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J3)/COMZ*ERI(M+1,I1,I2,I3-1,J1,J2,J3-1)
            ELSE IF (J1 >= 1) THEN
             ERI(M,I1,I2,I3,J1,J2,J3)=(PX-BX)*ERI(M+1,I1,I2,I3,J1-1,J2,J3)
             IF (J1 >= 2) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+ &
                          0.5D0*DFLOAT(J1-1)/AZT(JJ)*(ERI(M,I1,I2,I3,J1-2,J2,J3)-GZI/AZT(JJ)*ERI(M+1,I1,I2,I3,J1-2,J2,J3))
             IF (I1 >= 1) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(I1)/COMZ*ERI(M+1,I1-1,I2,I3,J1-1,J2,J3)
            ELSE IF (J2 >= 1) THEN
             ERI(M,I1,I2,I3,J1,J2,J3)=(PY-BY)*ERI(M+1,I1,I2,I3,J1,J2-1,J3)
             IF (J2 >= 2) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+ &
                          0.5D0*DFLOAT(J2-1)/AZT(JJ)*(ERI(M,I1,I2,I3,J1,J2-2,J3)-GZI/AZT(JJ)*ERI(M+1,I1,I2,I3,J1,J2-2,J3))
             IF (I2 >= 1) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(I2)/COMZ*ERI(M+1,I1,I2-1,I3,J1,J2-1,J3)
            ELSE IF (J3 >= 1) THEN
             ERI(M,I1,I2,I3,J1,J2,J3)=(PZ-BZ)*ERI(M+1,I1,I2,I3,J1,J2,J3-1)
             IF (J3 >= 2) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+ &
                          0.5D0*DFLOAT(J3-1)/AZT(JJ)*(ERI(M,I1,I2,I3,J1,J2,J3-2)-GZI/AZT(JJ)*ERI(M+1,I1,I2,I3,J1,J2,J3-2))
             IF (I3 >= 1) ERI(M,I1,I2,I3,J1,J2,J3)=ERI(M,I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(I3)/COMZ*ERI(M+1,I1,I2,I3-1,J1,J2,J3-1)
            END IF
           ENDDO
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO

     DO I1=0,A_SHELL_ANG(I)
      DO I2=0,A_SHELL_ANG(I)-I1
       DO I3=0,A_SHELL_ANG(I)-I1-I2
        DO J1=0,A_SHELL_ANG(J)
         DO J2=0,A_SHELL_ANG(J)-J1
          DO J3=0,A_SHELL_ANG(J)-J1-J2
           DERI(A_SHELL(I,I1,I2,I3),A_SHELL(J,J1,J2,J3))= &
           DERI(A_SHELL(I,I1,I2,I3),A_SHELL(J,J1,J2,J3))+ &
           ERI(0,I1,I2,I3,J1,J2,J3)*ANORM(A_SHELL(I,I1,I2,I3))*ANORM(A_SHELL(J,J1,J2,J3))
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO

    ENDDO
   ENDDO
   
   DEALLOCATE(ERI)

   RETURN
END SUBROUTINE



SUBROUTINE TWOINDEX_S(DOV,N,Q)
! CALCULATE OVERLAP INTEGRALS FOR AUXILIARY GAUSSIAN FUNCTIONS.
! ARGUMENT ARRAY DOV(I,J) STORES THE OVERLAP INTEGRALS BETWEEN I(0) AND J(Q).
! N IS THE DIMENSION OF SQUARE MATRIX DOV.

   USE CONTROL
   USE STRUCTURE
   USE AUXILIARY
   USE BASISSET
   USE INTEGRAL
   USE GRADIENT
   USE CONSTANTS
   
   IMPLICIT NONE
   INTEGER :: N,Q
   DOUBLE PRECISION :: DOV(N,N)
   DOUBLE PRECISION,ALLOCATABLE :: S1(:,:,:,:,:,:),S2(:,:,:,:,:,:)
   DOUBLE PRECISION :: PISUB
   DOUBLE PRECISION :: QX,QC,QS
   DOUBLE PRECISION :: COMZ1,COMZ2,GZI,FS
   DOUBLE PRECISION :: AX,AY,AZ,BX,BY,BZ,PX,PY,PZ,R
   INTEGER :: I,J,II,JJ
   INTEGER :: I1,I2,I3,J1,J2,J3
   
   ALLOCATE(S1(0:4,0:4,0:4,0:4,0:4,0:4),S2(0:4,0:4,0:4,0:4,0:4,0:4))
   
   PISUB=DSQRT(PI**3)
   
   DOV=0.0D0
   
   QX=DFLOAT(Q)*PERIOD
   QC=DCOS(DFLOAT(Q)*HELIX)
   QS=DSIN(DFLOAT(Q)*HELIX)
   DO I=1,NASHELL
    II=A_SHELL(I,0,0,0)
    AX=AGSX(II)
    AY=AGSY(II)
    AZ=AGSZ(II)
    DO J=1,NASHELL
     JJ=A_SHELL(J,0,0,0)
     BX=AGSX(JJ)+QX
     BY=AGSY(JJ)*QC-AGSZ(JJ)*QS
     BZ=AGSY(JJ)*QS+AGSZ(JJ)*QC
     R=(AX-BX)**2+(AY-BY)**2+(AZ-BZ)**2
     COMZ1=AZT(II)+AZT(JJ)
     COMZ2=DSQRT(COMZ1**3)
     GZI=AZT(II)*AZT(JJ)/COMZ1
      
     S1(0,0,0,0,0,0)=PISUB/COMZ2*DEXP(-GZI*R)
      
     PX=(AX*AZT(II)+BX*AZT(JJ))/COMZ1
     PY=(AY*AZT(II)+BY*AZT(JJ))/COMZ1
     PZ=(AZ*AZT(II)+BZ*AZT(JJ))/COMZ1
      
     DO I1=0,A_SHELL_ANG(I)
      DO I2=0,A_SHELL_ANG(I)-I1
       DO I3=0,A_SHELL_ANG(I)-I1-I2
        DO J1=0,A_SHELL_ANG(J)
         DO J2=0,A_SHELL_ANG(J)-J1
          DO J3=0,A_SHELL_ANG(J)-J1-J2
           IF (I1+I2+I3+J1+J2+J3 == 0) CYCLE
           ! OVERLAP INTEGRALS (OBARA-SAIKA RECURSION FORMULAS)
           IF (I1 >= 1) THEN
            S1(I1,I2,I3,J1,J2,J3)=(PX-AX)*S1(I1-1,I2,I3,J1,J2,J3)
            IF (I1 >= 2) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(I1-1)/COMZ1*S1(I1-2,I2,I3,J1,J2,J3)
            IF (J1 >= 1) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J1)/COMZ1*S1(I1-1,I2,I3,J1-1,J2,J3)
           ELSE IF (I2 >= 1) THEN
            S1(I1,I2,I3,J1,J2,J3)=(PY-AY)*S1(I1,I2-1,I3,J1,J2,J3)
            IF (I2 >= 2) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(I2-1)/COMZ1*S1(I1,I2-2,I3,J1,J2,J3)
            IF (J2 >= 1) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J2)/COMZ1*S1(I1,I2-1,I3,J1,J2-1,J3)
           ELSE IF (I3 >= 1) THEN
            S1(I1,I2,I3,J1,J2,J3)=(PZ-AZ)*S1(I1,I2,I3-1,J1,J2,J3)
            IF (I3 >= 2) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(I3-1)/COMZ1*S1(I1,I2,I3-2,J1,J2,J3)
            IF (J3 >= 1) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J3)/COMZ1*S1(I1,I2,I3-1,J1,J2,J3-1)
           ELSE IF (J1 >= 1) THEN
            S1(I1,I2,I3,J1,J2,J3)=(PX-BX)*S1(I1,I2,I3,J1-1,J2,J3)
            IF (J1 >= 2) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J1-1)/COMZ1*S1(I1,I2,I3,J1-2,J2,J3)
           ELSE IF (J2 >= 1) THEN
            S1(I1,I2,I3,J1,J2,J3)=(PY-BY)*S1(I1,I2,I3,J1,J2-1,J3)
            IF (J2 >= 2) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J2-1)/COMZ1*S1(I1,I2,I3,J1,J2-2,J3)
           ELSE IF (J3 >= 1) THEN
            S1(I1,I2,I3,J1,J2,J3)=(PZ-BZ)*S1(I1,I2,I3,J1,J2,J3-1)
            IF (J3 >= 2) S1(I1,I2,I3,J1,J2,J3)=S1(I1,I2,I3,J1,J2,J3)+0.5D0*DFLOAT(J3-1)/COMZ1*S1(I1,I2,I3,J1,J2,J3-2)
           ENDIF   
          ENDDO
         ENDDO
        ENDDO
        S2(I1,I2,I3,0,0,0)=S1(I1,I2,I3,0,0,0)
        IF (A_SHELL_ANG(J) >= 1) THEN
         S2(I1,I2,I3,1,0,0)=S1(I1,I2,I3,1,0,0)
         S2(I1,I2,I3,0,1,0)=S1(I1,I2,I3,0,1,0)*QC+S1(I1,I2,I3,0,0,1)*QS
         S2(I1,I2,I3,0,0,1)=-S1(I1,I2,I3,0,1,0)*QS+S1(I1,I2,I3,0,0,1)*QC
        ENDIF
        IF (A_SHELL_ANG(J) >= 2) THEN
         S2(I1,I2,I3,2,0,0)=S1(I1,I2,I3,2,0,0)
         S2(I1,I2,I3,1,1,0)=S1(I1,I2,I3,1,1,0)*QC+S1(I1,I2,I3,1,0,1)*QS
         S2(I1,I2,I3,1,0,1)=-S1(I1,I2,I3,1,1,0)*QS+S1(I1,I2,I3,1,0,1)*QC
         S2(I1,I2,I3,0,1,1)=(S1(I1,I2,I3,0,0,2)-S1(I1,I2,I3,0,2,0))*QC*QS+S1(I1,I2,I3,0,1,1)*(QC*QC-QS*QS)
         S2(I1,I2,I3,0,2,0)=S1(I1,I2,I3,0,2,0)*QC*QC+S1(I1,I2,I3,0,0,2)*QS*QS+2.0D0*S1(I1,I2,I3,0,1,1)*QC*QS
         S2(I1,I2,I3,0,0,2)=S1(I1,I2,I3,0,2,0)*QS*QS+S1(I1,I2,I3,0,0,2)*QC*QC-2.0D0*S1(I1,I2,I3,0,1,1)*QC*QS
        ENDIF
        IF (A_SHELL_ANG(J) >= 3) THEN
         S2(I1,I2,I3,3,0,0)=S1(I1,I2,I3,3,0,0)
         S2(I1,I2,I3,0,3,0)=(S1(I1,I2,I3,0,3,0)*QC+S1(I1,I2,I3,0,2,1)*QS*3.0D0)*QC*QC+ &
                            (S1(I1,I2,I3,0,0,3)*QS+S1(I1,I2,I3,0,1,2)*QC*3.0D0)*QS*QS
         S2(I1,I2,I3,0,0,3)=(S1(I1,I2,I3,0,0,3)*QC-S1(I1,I2,I3,0,1,2)*QS*3.0D0)*QC*QC- &
                            (S1(I1,I2,I3,0,3,0)*QS-S1(I1,I2,I3,0,2,1)*QC*3.0D0)*QS*QS
         S2(I1,I2,I3,2,1,0)=S1(I1,I2,I3,2,1,0)*QC+S1(I1,I2,I3,2,0,1)*QS
         S2(I1,I2,I3,2,0,1)=-S1(I1,I2,I3,2,1,0)*QS+S1(I1,I2,I3,2,0,1)*QC
         S2(I1,I2,I3,1,2,0)=S1(I1,I2,I3,1,2,0)*QC*QC+S1(I1,I2,I3,1,0,2)*QS*QS+S1(I1,I2,I3,1,1,1)*2.0D0*QC*QS
         S2(I1,I2,I3,1,0,2)=S1(I1,I2,I3,1,0,2)*QC*QC+S1(I1,I2,I3,1,2,0)*QS*QS-S1(I1,I2,I3,1,1,1)*2.0D0*QC*QS
         S2(I1,I2,I3,0,2,1)=(S1(I1,I2,I3,0,0,3)*QS-S1(I1,I2,I3,0,3,0)*QC)*QC*QS+ &
                            S1(I1,I2,I3,0,1,2)*(2.0D0*QC*QC-QS*QS)*QS+S1(I1,I2,I3,0,2,1)*(QC*QC-2.0D0*QS*QS)*QC
         S2(I1,I2,I3,0,1,2)=(S1(I1,I2,I3,0,3,0)*QS+S1(I1,I2,I3,0,0,3)*QC)*QC*QS- &
                            S1(I1,I2,I3,0,2,1)*(2.0D0*QC*QC-QS*QS)*QS+S1(I1,I2,I3,0,1,2)*(QC*QC-2.0D0*QS*QS)*QC
         S2(I1,I2,I3,1,1,1)=(S1(I1,I2,I3,1,0,2)-S1(I1,I2,I3,1,2,0))*QC*QS+S1(I1,I2,I3,1,1,1)*(QC*QC-QS*QS)
        ENDIF
       ENDDO
      ENDDO
     ENDDO
     DO I1=0,A_SHELL_ANG(I)
      DO I2=0,A_SHELL_ANG(I)-I1
       DO I3=0,A_SHELL_ANG(I)-I1-I2
        DO J1=0,A_SHELL_ANG(J)
         DO J2=0,A_SHELL_ANG(J)-J1
          DO J3=0,A_SHELL_ANG(J)-J1-J2
           DOV(A_SHELL(I,I1,I2,I3),A_SHELL(J,J1,J2,J3))=S2(I1,I2,I3,J1,J2,J3)*ANORM(A_SHELL(I,I1,I2,I3))*ANORM(A_SHELL(J,J1,J2,J3))
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO

   DEALLOCATE(S1,S2)
   RETURN
END SUBROUTINE



SUBROUTINE LUDECOMPOSITION_DISK(N,M,INDX)
! LU DECOMPOSITION OF TWO-INDEX TWO-ELECTRON INTEGRAL MATRIX.  L AND U MATRICES ARE STORED ON
! AN EXTERNAL DISK.  ONLY THREE VECTOR OF LENGTH N ARE KEPT AT ONCE IN CORE MEMORY.
! SEE ALSO NUMERICAL RECIPES IN FORTRAN 2ND ED. P.38.

   USE CONTROL
   USE BASISSET
   USE INTEGRAL
   USE AUXILIARY

   IMPLICIT NONE
   REAL :: ICPUS,ICPUE
   INTEGER :: N,M,INDX(N)
   INTEGER :: I,IMAX,J,K,L,IM,Q2
   INTEGER :: IROW,ICOLUMN,IREAD,IWRITE,IDUMMY
   DOUBLE PRECISION,PARAMETER :: TINY = 1.0D-20
   DOUBLE PRECISION :: D,AAMAX,DUM,SUM
   DOUBLE PRECISION,ALLOCATABLE :: V(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: ROW(:,:),COLUMN(:),VV(:),DUMMY(:,:)

   CALL PCPU_TIME(ICPUS)
! BUG
   IF (N /= NAGS*(2*REDUCED_CEL1+1)) CALL PABORT('AN INTERNAL PROGRAM ERROR IS DETECTED')
   IF ((MOD(N,M) /= 0).OR.(M == 1)) CALL PABORT('AN INTERNAL PROGRAM ERROR IS DETECTED')
   IF (DFLOAT(N*N)*16.0D0 > DOPTN(26)*1000000.0D0) CALL PABORT('THE SIZE OF THE TWO-INDEX INTEGRAL FILE WILL EXCEED MAXDISK')
   IF (DFLOAT(N*N)*16.0D0/1000000.0D0 > 1.0D0) THEN
    WRITE(6,'(F9.1,A)') DFLOAT(N*N)*16.0D0/1000000.0D0,' MB DISK SPACE WILL BE USED'
   ELSE
    WRITE(6,'(F9.1,A)') DFLOAT(N*N)*16.0D0/1000.0D0,' KB DISK SPACE WILL BE USED'
   ENDIF

   ALLOCATE(V(NAGS,NAGS),ROW(N,M),COLUMN(N),VV(N),DUMMY(N,M))

   ! ZERO SCRATCH TWO FILES
   REWIND(34)
   REWIND(35)
   DO IROW=1,N
    IF (MOD(IROW,M) == 1) THEN
     ROW=0.0D0
     WRITE(34) ROW
     WRITE(35) ROW
    ENDIF
   ENDDO

   ! FORM LARGE V MATRIX IN FILE 34 FROM DIRECT COMPUTATION OF SMALL V MATRICES
   IREAD=34
   IWRITE=35
   DO Q2=-2*REDUCED_CEL1,2*REDUCED_CEL1
    IF (LOPTN(30)) CALL TWOINDEX_V(V,NAGS,Q2)
    IF (LOPTN(31)) CALL TWOINDEX_S(V,NAGS,Q2)
    REWIND(34)
    REWIND(35)
    DO IROW=1,N
     IM=MOD(IROW,M)
     IF (IM == 0) IM=M
     IF (IM == 1) READ(IREAD) ROW
     DO L=1,NAGS
      IF (MOD(IROW-L,NAGS) == 0) THEN
       DO K=1,NAGS
        ICOLUMN=IROW+Q2*NAGS-L+K
        IF ((ICOLUMN >=1).AND.(ICOLUMN <= N)) ROW(ICOLUMN,IM)=V(L,K)
       ENDDO
      ENDIF
     ENDDO
     IF (IM == M) WRITE(IWRITE) ROW
    ENDDO
    IDUMMY=IREAD
    IREAD=IWRITE
    IWRITE=IDUMMY
   ENDDO
   ! V MATRIX IS FINALLY STORED IN FILE 34
   IF (IREAD == 35) THEN
    REWIND(34)
    REWIND(35)
    DO IROW=1,N
     IF (MOD(IROW,M) == 1) THEN
      READ(35) ROW
      WRITE(34) ROW
     ENDIF
    ENDDO
   ENDIF
   CALL PCPU_TIME(ICPUE)
   WRITE(6,'(A,F10.1,A)') ' ... V MATRIX HAS BEEN CONSTRUCTED AND STORED (CPU / SEC = ',ICPUE-ICPUS,')'
   CALL PCPU_TIME(ICPUS)
!  CALL DUMP6(34,N,M)

   ! LU DECOMPOSITION STARTS FROM HERE ...
   D=1.0D0
   REWIND(34)
   DO I=1,N
    IM=MOD(I,M)
    IF (IM == 0) IM=M
    IF (IM == 1) READ(34) ROW
    AAMAX=0.0D0
    DO J=1,N
     IF (DABS(ROW(J,IM)) > AAMAX) AAMAX=DABS(ROW(J,IM))
    ENDDO
    IF (AAMAX == 0.0D0) CALL PABORT('SINGULAR MATRIX IN LU DECOMPOSITION')
    VV(I)=1.0D0/AAMAX
   ENDDO
   ! MAIN LOOP OVER COLUMN INDEX J
   DO J=1,N
    REWIND(34)
    DO I=1,N
     IM=MOD(I,M)
     IF (IM == 0) IM=M
     IF (IM == 1) READ(34) ROW
     COLUMN(I)=ROW(J,IM) ! PICK UP A COLUMN VECTOR FROM FILE 34
    ENDDO
    REWIND(34)
    REWIND(35)
    DO I=1,J-1
     IM=MOD(I,M)
     IF (IM == 0) IM=M
     IF (IM == 1) READ(34) ROW ! PICK UP A ROW VECTOR FROM FILE 34
     SUM=ROW(J,IM)
     DO K=1,I-1
      SUM=SUM-ROW(K,IM)*COLUMN(K)
     ENDDO
     ROW(J,IM)=SUM
     COLUMN(I)=SUM
     IF (IM == M) WRITE(35) ROW ! OVERWRITE THE ROW VECTOR TO FILE 35
    ENDDO
    AAMAX=0.0D0
    DO I=J,N
     IM=MOD(I,M)
     IF (IM == 0) IM=M
     IF (IM == 1) READ(34) ROW ! PICK UP A ROW VECTOR FROM FILE 34
     SUM=ROW(J,IM)
     DO K=1,J-1
      SUM=SUM-ROW(K,IM)*COLUMN(K)
     ENDDO
     ROW(J,IM)=SUM
     COLUMN(I)=SUM
     IF (IM == M) WRITE(35) ROW ! OVERWRITE THE ROW VECTOR TO FILE 35
     DUM=VV(I)*DABS(SUM)
     IF (DUM >= AAMAX) THEN
      IMAX=I
      AAMAX=DUM
     ENDIF
    ENDDO
    IF (J /= IMAX) THEN
     ! ROW-WISE PIVOT
     IF (IMAX < J) CALL PABORT('AN INTERNAL PROGRAM ERROR IS DETECTED')
     REWIND(35)
     DO K=1,IMAX
      IF (MOD(K,M) == 1) READ(35) ROW
     ENDDO
     IM=MOD(IMAX,M)
     IF (IM == 0) IM=M
     DO K=1,N
      COLUMN(K)=ROW(K,IM) ! PICK UP IMAX-TH ROW VECTOR FROM FILE 35 (HERE 'COLUMN' ARRAY IS USED AS A DUMMY ARRAY FOR SWAP)
     ENDDO
     IF (COLUMN(J) == 0.0D0) THEN
      DUM=1.0D0/TINY
     ELSE
      DUM=1.0D0/COLUMN(J)
     ENDIF
     REWIND(34)
     REWIND(35)
     DO K=1,N
      IM=MOD(K,M)
      IF (IM == 0) IM=M
      IF (IM == 1) READ(35) ROW ! PICK UP A ROW VECTOR FROM FILE 35
      IF (K == J) THEN
       IF (COLUMN(J) == 0.0D0) COLUMN(J)=TINY
       DO I=1,N
        DUMMY(I,1)=ROW(I,IM)
        ROW(I,IM)=COLUMN(I)
        COLUMN(I)=DUMMY(I,1)
       ENDDO
      ELSE IF (K == IMAX) THEN
       IF (K > J) COLUMN(J)=COLUMN(J)*DUM
       DO I=1,N
        ROW(I,IM)=COLUMN(I)
       ENDDO
      ELSE
       IF (K > J) ROW(J,IM)=ROW(J,IM)*DUM
      ENDIF
      IF (IM == M) WRITE(34) ROW
     ENDDO
     D=-D
     VV(IMAX)=VV(J)
    ELSE
     ! TRANSFER FILE 35 TO FILE 34
     REWIND(35)
     DO K=1,J
      IF (MOD(K,M) == 1) READ(35) ROW ! PICK UP J-TH ROW VECTOR FROM FILE 35
     ENDDO
     IM=MOD(J,M)
     IF (IM == 0) IM=M
     IF (ROW(J,IM) == 0.0D0) THEN
      DUM=1.0D0/TINY
     ELSE
      DUM=1.0D0/ROW(J,IM)
     ENDIF
     REWIND(34)
     REWIND(35)
     DO K=1,N
      IM=MOD(K,M)
      IF (IM == 0) IM=M
      IF (IM == 1) READ(35) ROW
      IF ((K == J).AND.(ROW(J,IM) == 0.0D0)) ROW(J,IM)=TINY
      IF (K > J) ROW(J,IM)=ROW(J,IM)*DUM
      IF (IM == M) WRITE(34) ROW
     ENDDO
    ENDIF
    INDX(J)=IMAX
    CALL PCPU_TIME(ICPUE)
    IF (MOD(J,M) == 0) WRITE(6,'(A,F5.1,A,F10.1,A)') ' ... ',DFLOAT(J)/DFLOAT(N)*100.0,' % (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
   ENDDO
   WRITE(6,'(A)') ' ... LU DECOMPOSITION OF V MATRIX HAS BEEN DONE'
!  CALL DUMP6(34,N,M)

   REWIND(35)
   DO I=N/M,1,-1
    REWIND(34)
    DO J=1,I
     READ(34) ROW
    ENDDO
    DO J=1,M
     DO K=1,N
      DUMMY(K,M+1-J)=ROW(K,J)
     ENDDO
    ENDDO
    WRITE(35) DUMMY
   ENDDO
   CALL PCPU_TIME(ICPUE)
   WRITE(6,'(A,F10.1,A)') ' ... ORDER OF THE ROW HAS BEEN REVERSED (CPU / SEC = ',ICPUE-ICPUS,')'
!  CALL DUMP6(35,N,M)

   DEALLOCATE(V,ROW,COLUMN,VV,DUMMY)

   RETURN
END SUBROUTINE



SUBROUTINE LUBACKSUBSTITUTION_DISK(N,M,INDX,B)
! FORWARD AND BACKSUBSTITUTION FOR LINEAR EQUATIONS AX=B, WHERE A IS TWO-INDEX INTEGRAL MATRIX AND
! B IS A REAL VECTOR.  SEE NUMERICAL RECIPES IN FORTRAN 2ND ED. P.39.

   IMPLICIT NONE
   INTEGER :: N,M,INDX(N)
   INTEGER :: I,II,J,LL,IM
   DOUBLE PRECISION :: B(N)
   DOUBLE PRECISION :: SUM
   DOUBLE PRECISION,ALLOCATABLE :: ROW(:,:)

   IF ((MOD(N,M) /= 0).OR.(M == 1)) CALL PABORT('AN INTERNAL PROGRAM ERROR IS DETECTED')

   ALLOCATE(ROW(N,M))

   II=0
   REWIND(34)
   DO I=1,N
    IM=MOD(I,M)
    IF (IM == 0) IM=M
    IF (IM == 1) READ(34) ROW
    LL=INDX(I)
    SUM=B(LL)
    B(LL)=B(I)
    IF (II /= 0) THEN
     DO J=II,I-1
      SUM=SUM-ROW(J,IM)*B(J)
     ENDDO
    ELSE IF (SUM /= 0.0D0) THEN
     II=I
    END IF
    B(I)=SUM
   ENDDO
   REWIND(35)
   DO I=N,1,-1
    IM=MOD(N-I+1,M)
    IF (IM == 0) IM=M
    IF (IM == 1) READ(35) ROW
    SUM=B(I)
    DO J=I+1,N
     SUM=SUM-ROW(J,IM)*B(J)
    ENDDO
    B(I)=SUM/ROW(I,IM)
   ENDDO

   DEALLOCATE(ROW)

   RETURN
END SUBROUTINE
