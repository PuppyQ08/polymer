SUBROUTINE REL_HIGHORDER_CORRELATION
! PERFORM FULL AND TRUNCATED CI, HIGH-ORDER RECURSIVE MP, AND HIGH-ORDER CC CALCULATIONS.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER :: I,J
   INTEGER :: NROOTS,NTRIALS
   DOUBLE PRECISION :: A,B

   OPEN(50,FILE='polymerdata1',FORM='formatted')
   REWIND(50)
   READ(50,*) IALL(0,0,0)
   READ(50,*) IOCC
   IALLMAX = IALL(0,0,0)
   IVIRTCORE = 0
   ICORE = 0
   KVC = 0
   ALLOCATE(REPSILON(1:IALL(0,0,0),0:0))
   DO I = 1, IALL(0,0,0)
     READ(50,*) REPSILON(I,0)
     WRITE(*,'(2F20.15)') REPSILON(I,0)
   ENDDO
   DEALLOCATE(CO)
   ALLOCATE(CO(1:2*NCGS,1:IALL(0,0,0),0:0))
   DO I = 1, IALL(0,0,0)
     DO J = 1, 2*NCGS
       READ(50,*) A,B
       CO(J,I,0) = DCMPLX(A,B)
       WRITE(*,'(2F20.15)') CO(J,I,0)
     ENDDO
   ENDDO
   CLOSE(50)
   OPEN(50,FILE='polymerdata2',FORM='formatted')
   REWIND(50)
   ALLOCATE(RHCORE(1:2*NCGS,1:2*NCGS))
   DO I = 1, 2*NCGS
     DO J = 1, 2*NCGS
       READ(50,*) A,B
       RHCORE(J,I) = DCMPLX(A,B)
       WRITE(*,'(2I3,2F20.15)') J,I,RHCORE(J,I)
     ENDDO
   ENDDO
   CLOSE(50)
   IF (KVC /= 0) CALL PABORT('FOR MOLECULES ONLY')
   IF (LOPTN(25)) CALL PABORT('USE NON-DIRECT ALGORITHM')
   IF (IALL(0,0,0)-IOCC-IVIRTCORE <= 0) CALL PABORT('NO VIRTUAL ORBITAL')

   ALLOCATE(H(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   ALLOCATE(G(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   CALL REL_TWO_ELECTRON_INTEGRALS
   CALL REL_ONE_ELECTRON_INTEGRALS
   CALL REL_GENERATE_CONFIGURATIONS(MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))
   IF (LOPTN(60)) CALL REL_GENERATE_IP_CONFIGURATIONS(MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1))
   IF (LOPTN(61)) CALL REL_GENERATE_EA_CONFIGURATIONS(MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE))
   IF (IOPTN(49) > 0) CALL REL_HIGHORDER_MP(IOPTN(49))
   IF ((.NOT.LOPTN(60)).AND.(.NOT.LOPTN(61))) THEN
    ! CI_EE
    IF (IOPTN(51) >= MAX(IOPTN(50),1)) THEN
     DO I=MAX(IOPTN(50),1),MIN(IOPTN(51),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))
      IF (IOPTN(9) == 0) CALL REL_FULL_HAMILTONIAN(I)
      NROOTS=IOPTN(56)
      CALL REL_CI_GUESS(I,NROOTS,NTRIALS)
      CALL REL_HIGHORDER_CI(I,NROOTS,NTRIALS)
     ENDDO
    ELSE IF ((IOPTN(50) >= MAX(IOPTN(51),1)).AND.(IOPTN(51) /= 0)) THEN
     DO I=MIN(IOPTN(50),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),MAX(IOPTN(51),1),-1
      IF (IOPTN(9) == 0) CALL REL_FULL_HAMILTONIAN(I)
      NROOTS=IOPTN(56)
      CALL REL_CI_GUESS(I,NROOTS,NTRIALS)
      CALL REL_HIGHORDER_CI(I,NROOTS,NTRIALS)
     ENDDO
    ENDIF
   ENDIF
   IF (LOPTN(60)) THEN
    ! CI_IP
    IF (IOPTN(51) >= MAX(IOPTN(50),1)) THEN
     DO I=MAX(IOPTN(50),1),MIN(IOPTN(51),MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1))
      IF (IOPTN(9) == 0) CALL REL_FULL_IP_HAMILTONIAN(I)
      NROOTS=IOPTN(56)
      CALL REL_CI_IP_GUESS(I,NROOTS,NTRIALS)
      CALL REL_HIGHORDER_CI_IP(I,NROOTS,NTRIALS)
     ENDDO
    ELSE IF ((IOPTN(50) >= MAX(IOPTN(51),1)).AND.(IOPTN(51) /= 0)) THEN
     DO I=MIN(IOPTN(50),MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1)),MAX(IOPTN(51),1),-1
      IF (IOPTN(9) == 0) CALL REL_FULL_IP_HAMILTONIAN(I)
      NROOTS=IOPTN(56)
      CALL REL_CI_IP_GUESS(I,NROOTS,NTRIALS)
      CALL REL_HIGHORDER_CI_IP(I,NROOTS,NTRIALS)
     ENDDO
    ENDIF
   ENDIF
   IF (LOPTN(61)) THEN
    ! CI_EA
    IF (IOPTN(51) >= MAX(IOPTN(50),1)) THEN
     DO I=MAX(IOPTN(50),1),MIN(IOPTN(51),MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE))
      IF (IOPTN(9) == 0) CALL REL_FULL_EA_HAMILTONIAN(I)
      NROOTS=IOPTN(56)
      CALL REL_CI_EA_GUESS(I,NROOTS,NTRIALS)
      CALL REL_HIGHORDER_CI_EA(I,NROOTS,NTRIALS)
     ENDDO
    ELSE IF ((IOPTN(50) >= MAX(IOPTN(51),1)).AND.(IOPTN(51) /= 0)) THEN
     DO I=MIN(IOPTN(50),MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE)),MAX(IOPTN(51),1),-1
      IF (IOPTN(9) == 0) CALL REL_FULL_EA_HAMILTONIAN(I)
      NROOTS=IOPTN(56)
      CALL REL_CI_EA_GUESS(I,NROOTS,NTRIALS)
      CALL REL_HIGHORDER_CI_EA(I,NROOTS,NTRIALS)
     ENDDO
    ENDIF
   ENDIF
   IF (IOPTN(53) >= MAX(IOPTN(52),1)) THEN
    DO I=MAX(IOPTN(52),1),MIN(IOPTN(53),MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))
     IF (IOPTN(54) > 0) THEN
      IF (I == MAX(IOPTN(52),1)) CALL REL_HIGHORDER_CC(I,.FALSE.,.TRUE.,.FALSE.)
      IF (I /= MAX(IOPTN(52),1)) CALL REL_HIGHORDER_CC(I,.TRUE.,.TRUE.,.FALSE.)
     ELSE
      IF (I == MAX(IOPTN(52),1)) CALL REL_HIGHORDER_CC(I,.FALSE.,.FALSE.,.FALSE.)
      IF (I /= MAX(IOPTN(52),1)) CALL REL_HIGHORDER_CC(I,.TRUE.,.FALSE.,.FALSE.)
     ENDIF
     IF (LOPTN(65)) CALL REL_HIGHORDER_CC(I,.TRUE.,.TRUE.,.TRUE.)
    ENDDO
   ELSE IF ((IOPTN(52) >= MAX(IOPTN(53),1)).AND.(IOPTN(53) /= 0)) THEN
    DO I=MIN(IOPTN(52),MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),MAX(IOPTN(53),1),-1
     IF (IOPTN(54) > 0) THEN
      IF (I == MAX(IOPTN(52),1)) CALL REL_HIGHORDER_CC(I,.FALSE.,.TRUE.,.FALSE.)
      IF (I /= MAX(IOPTN(52),1)) CALL REL_HIGHORDER_CC(I,.TRUE.,.TRUE.,.FALSE.)
     ELSE
      IF (I == MAX(IOPTN(52),1)) CALL REL_HIGHORDER_CC(I,.FALSE.,.FALSE.,.FALSE.)
      IF (I /= MAX(IOPTN(52),1)) CALL REL_HIGHORDER_CC(I,.TRUE.,.FALSE.,.FALSE.)
     ENDIF
     IF (LOPTN(65)) CALL REL_HIGHORDER_CC(I,.TRUE.,.TRUE.,.TRUE.)
    ENDDO
   ENDIF
   IF (IOPTN(59) > 0) THEN
    IF (IOPTN(53) == 0) CALL PABORT('CC CALCULATION MUST PRECEED EOMCC CALCULATION')
    IF ((.NOT.LOPTN(60)).AND.(.NOT.LOPTN(61))) THEN
     ! EOMEE-CC
     IF (IOPTN(57) <= IOPTN(58)) THEN
      DO I=IOPTN(57),IOPTN(58)
       IF (IOPTN(9) == 0) THEN
        IF ((IOPTN(66) > 0).AND.(IOPTN(66) <= IOPTN(59))) THEN
!        IF (I == IOPTN(53)) &
!        CALL REL_FULL_EFF_H_PERTURBATION(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),MAX(2,IOPTN(49)))
        ELSE
         CALL REL_FULL_EFF_H(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I)
        ENDIF
       ENDIF
       NROOTS=IOPTN(59)
       CALL REL_CI_GUESS(I,NROOTS,NTRIALS)
       CALL REL_EOMEECC(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I,NROOTS,NTRIALS,.FALSE.)
       IF ((IOPTN(66) > 0).AND.(IOPTN(66) <= NROOTS)) THEN
        NROOTS=IOPTN(59)
        CALL REL_CI_GUESS(I,NROOTS,NTRIALS)
        CALL REL_EOMEECC(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I,NROOTS,NTRIALS,.TRUE.)
       ENDIF
      ENDDO
     ELSE
      DO I=IOPTN(57),IOPTN(58),-1
       IF (IOPTN(9) == 0) THEN
        IF ((IOPTN(66) > 0).AND.(IOPTN(66) <= IOPTN(59))) THEN
!        IF (I == IOPTN(53)) &
!        CALL REL_FULL_EFF_H_PERTURBATION(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),MAX(2,IOPTN(49)))
        ELSE
         CALL REL_FULL_EFF_H(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I)
        ENDIF
       ENDIF
       NROOTS=IOPTN(59)
       CALL REL_CI_GUESS(I,NROOTS,NTRIALS)
       CALL REL_EOMEECC(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I,NROOTS,NTRIALS,.TRUE.)
       IF ((IOPTN(66) > 0).AND.(IOPTN(66) <= NROOTS)) THEN
        NROOTS=IOPTN(59)
        CALL REL_CI_GUESS(I,NROOTS,NTRIALS)
        CALL REL_EOMEECC(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I,NROOTS,NTRIALS,.FALSE.)
       ENDIF
      ENDDO
     ENDIF
     IF ((IOPTN(66) > 0).AND.(IOPTN(66) <= NROOTS)) THEN
      IF (IOPTN(58) /= MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))) THEN
       CALL WARNING('NON-STANDARD EOM-CC; PERTURBATIVE CORRECTION CALCULATIONS WILL NOT BE PERFORMED')
      ELSE
!      CALL REL_CCPT(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),MAX(2,IOPTN(49)))
      ENDIF
     ENDIF
    ENDIF
    IF (LOPTN(60)) THEN
     ! EOMIP-CC
     IF (IOPTN(57) <= IOPTN(58)) THEN
      DO I=IOPTN(57),IOPTN(58)
       IF (IOPTN(9) == 0) CALL REL_FULL_IP_EFF_H(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I)
       NROOTS=IOPTN(59)
       CALL REL_CI_IP_GUESS(I,NROOTS,NTRIALS)
       CALL REL_EOMIPCC(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I,NROOTS,NTRIALS)
      ENDDO
     ELSE
      DO I=IOPTN(57),IOPTN(58),-1
       IF (IOPTN(9) == 0) CALL REL_FULL_IP_EFF_H(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I)
       NROOTS=IOPTN(59)
       CALL REL_CI_IP_GUESS(I,NROOTS,NTRIALS)
       CALL REL_EOMIPCC(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I,NROOTS,NTRIALS)
      ENDDO
     ENDIF
    ENDIF
    IF (LOPTN(61)) THEN
     ! EOMEA-CC
     IF (IOPTN(57) <= IOPTN(58)) THEN
      DO I=IOPTN(57),IOPTN(58)
       IF (IOPTN(9) == 0) CALL REL_FULL_EA_EFF_H(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I)
       NROOTS=IOPTN(59)
       CALL REL_CI_EA_GUESS(I,NROOTS,NTRIALS)
       CALL REL_EOMEACC(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I,NROOTS,NTRIALS)
      ENDDO
     ELSE
      DO I=IOPTN(57),IOPTN(58),-1
       IF (IOPTN(9) == 0) CALL REL_FULL_EA_EFF_H(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I)
       NROOTS=IOPTN(59)
       CALL REL_CI_EA_GUESS(I,NROOTS,NTRIALS)
       CALL REL_EOMEACC(MIN(IOPTN(53),2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)),I,NROOTS,NTRIALS)
      ENDDO
     ENDIF
    ENDIF
   ENDIF
   DEALLOCATE(H,G)
   DEALLOCATE(CFHALF,ADDRSS,NORDER)

   RETURN
END SUBROUTINE



SUBROUTINE REL_ONE_ELECTRON_INTEGRALS
! FORM ONE ELECTRON PART OF THE HAMILTONIAN MATRIX.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: I,J,MOP,MOQ
   DOUBLE COMPLEX,ALLOCATABLE :: WR1(:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: WR2(:,:)
   INTEGER,PARAMETER :: CASHESIZE = 1000 ! CASHE SIZE MUST BE EXACTLY THE SAME IN THE STORE & RESTORE SUBROUTINES
   INTEGER :: K,L,P,Q,R
   INTEGER :: EOF
   INTEGER :: ICASHECOUNT,ICOUNT
   INTEGER(4),ALLOCATABLE :: ICASHE1(:),ICASHE2(:)
   DOUBLE PRECISION,ALLOCATABLE :: DCASHE(:)

   DOUBLE COMPLEX,ALLOCATABLE :: WR3(:,:),WR4(:,:)
   
   WRITE(6,'(A)') 'INTEGRAL TRANSFORMATION OF ONE-ELECTRON INTEGRALS WILL BE PERFORMED'

   ALLOCATE(WR1(IALLMAX,IALLMAX),WR2(IALLMAX-IVIRTCORE,2*NCGS))
   DO I=1,2*NCGS 
    DO MOP=1,IALL(0,0,0)-IVIRTCORE
     WR2(MOP,I)=DCMPLX(0.0D0,0.0D0)
     DO J=1,2*NCGS
      WR2(MOP,I)=WR2(MOP,I)+DCONJG(CO(J,MOP,0))*RHCORE(J,I)
     ENDDO
    ENDDO
   ENDDO
   DO MOP=1,IALL(0,0,0)-IVIRTCORE
    DO MOQ=1,IALL(0,0,0)-IVIRTCORE
     H(MOP,MOQ)=DCMPLX(0.0D0,0.0D0)
     DO I=1,2*NCGS
      H(MOP,MOQ)=H(MOP,MOQ)+CO(I,MOQ,0)*WR2(MOP,I)
     ENDDO
    ENDDO
   ENDDO
   DO MOP=1,IALL(0,0,0)-IVIRTCORE
    DO MOQ=1,IALL(0,0,0)-IVIRTCORE
     WR1(MOP,MOQ)=H(MOP,MOQ)
     DO I=1,IOCC
      WR1(MOP,MOQ)=WR1(MOP,MOQ)+G(MOP,MOQ,I,I)-G(MOP,I,I,MOQ)
     ENDDO
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'ONE-ELECTRON PART OF THE HAMILTONIAN MATRIX'
    CALL DUMP7(H,IALL(0,0,0)-IVIRTCORE)
    CALL DUMP7(WR1,IALL(0,0,0)-IVIRTCORE)
   ENDIF
   DEALLOCATE(WR1,WR2)
!  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
   ALLOCATE(WR1(2*NCGS,2*NCGS),WR2(2*NCGS,2*NCGS))
   ALLOCATE(WR3(IALL(0,0,0)-IVIRTCORE,2*NCGS),WR4(IALL(0,0,0)-IVIRTCORE,IALL(0,0,0)-IVIRTCORE))
   DO I=1,2*NCGS
    DO J=1,2*NCGS
     WR1(J,I)=DCMPLX(0.0D0,0.0D0)
     DO MOP=ICORE+1,IOCC
      WR1(J,I)=WR1(J,I)+DCONJG(CO(J,MOP,0))*CO(I,MOP,0)
     ENDDO
    ENDDO
   ENDDO
   WR2=DCMPLX(0.0D0,0.0D0)
   DO I=1,2*NCGS
    DO J=1,2*NCGS
     WR2(I,J)=RHCORE(I,J)
    ENDDO
   ENDDO
   CALL DUMP7(WR2,2*NCGS,2*NCGS)
!  DO I=1,NCGS
!   DO J=1,NCGS
!    WR1(J,I)=DCMPLX(DREAL(WR1(J,I)),0.0D0)
!    WR1(J+NCGS,I)=DCMPLX(0.0D0,0.0D0)
!    WR1(J,I+NCGS)=DCMPLX(0.0D0,0.0D0)
!    WR1(J+NCGS,I+NCGS)=DCMPLX(DREAL(WR1(J+NCGS,I+NCGS)),0.0D0)
!   ENDDO
!  ENDDO
   CALL DUMP7(WR1,2*NCGS)
   ALLOCATE(ICASHE1(CASHESIZE),ICASHE2(CASHESIZE),DCASHE(CASHESIZE))
   REWIND(31)
   ICOUNT=0
   DO
    READ(31,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
    IF (EOF /= 0) EXIT
    DO ICASHECOUNT=1,CASHESIZE
     IF (ICASHE1(ICASHECOUNT) == -1) EXIT
     ICOUNT=ICOUNT+1
     P=0
     Q=0
     R=0
     I=0
     J=0
     K=0
     L=0
     CALL MVBITS(ICASHE1(ICASHECOUNT),16,8,P,0)
     CALL MVBITS(ICASHE1(ICASHECOUNT), 8,8,Q,0)
     CALL MVBITS(ICASHE1(ICASHECOUNT), 0,8,R,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT),24,8,I,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT),16,8,J,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT), 8,8,K,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT), 0,8,L,0)
     WR2(I,     J     )=WR2(I,     J     )+1.0D0*WR1(K,     L     )*DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR2(I+NCGS,J+NCGS)=WR2(I+NCGS,J+NCGS)+1.0D0*WR1(K,     L     )*DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR2(I,     J     )=WR2(I,     J     )+1.0D0*WR1(K+NCGS,L+NCGS)*DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR2(I+NCGS,J+NCGS)=WR2(I+NCGS,J+NCGS)+1.0D0*WR1(K+NCGS,L+NCGS)*DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR2(I,     L     )=WR2(I,     L     )-1.0D0*WR1(K,     J     )*DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR2(I+NCGS,L     )=WR2(I+NCGS,L     )-1.0D0*WR1(K,     J+NCGS)*DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR2(I,     L+NCGS)=WR2(I,     L+NCGS)-1.0D0*WR1(K+NCGS,J     )*DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR2(I+NCGS,L+NCGS)=WR2(I+NCGS,L+NCGS)-1.0D0*WR1(K+NCGS,J+NCGS)*DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
    ENDDO
   ENDDO
   CALL DUMP7(WR2,2*NCGS,2*NCGS)
   DO I=1,2*NCGS 
    DO MOP=1,IALL(0,0,0)-IVIRTCORE
     WR3(MOP,I)=DCMPLX(0.0D0,0.0D0)
     DO J=1,2*NCGS
      WR3(MOP,I)=WR3(MOP,I)+DCONJG(CO(J,MOP,0))*WR2(J,I)
     ENDDO
    ENDDO
   ENDDO
   DO MOP=1,IALL(0,0,0)-IVIRTCORE
    DO MOQ=1,IALL(0,0,0)-IVIRTCORE
     WR4(MOP,MOQ)=DCMPLX(0.0D0,0.0D0)
     DO I=1,2*NCGS
      WR4(MOP,MOQ)=WR4(MOP,MOQ)+CO(I,MOQ,0)*WR3(MOP,I)
     ENDDO
    ENDDO
   ENDDO
   CALL DUMP7(WR4,IALL(0,0,0)-IVIRTCORE)
   DEALLOCATE(WR1,WR2,WR3,WR4,ICASHE1,ICASHE2,DCASHE)
!  /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
   
   RETURN
END SUBROUTINE



SUBROUTINE REL_TWO_ELECTRON_INTEGRALS
! FORM TWO ELECTRON PART OF THE HAMILTONIAN MATRIX.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER,PARAMETER :: CASHESIZE = 1000 ! CASHE SIZE MUST BE EXACTLY THE SAME IN THE STORE & RESTORE SUBROUTINES
   INTEGER :: I,J,K,L,P,Q,R
   INTEGER :: MOP,MOQ,MOR,MOS,MOI,MOJ,MOA,MOB
   INTEGER :: EOF
   INTEGER :: ICASHECOUNT,ICOUNT
   INTEGER(4),ALLOCATABLE :: ICASHE1(:),ICASHE2(:)
   DOUBLE PRECISION,ALLOCATABLE :: DCASHE(:)
   DOUBLE COMPLEX,ALLOCATABLE :: WR1(:,:,:,:),WR2(:,:,:,:)
   DOUBLE COMPLEX :: EMP2
   
   WRITE(6,'(A)') 'INTEGRAL TRANSFORMATION OF TWO-ELECTRON INTEGRALS WILL BE PERFORMED'

   ALLOCATE(ICASHE1(CASHESIZE),ICASHE2(CASHESIZE),DCASHE(CASHESIZE))
   ALLOCATE(WR1(2*NCGS,2*NCGS,2*NCGS,2*NCGS),WR2(2*NCGS,2*NCGS,2*NCGS,2*NCGS))
   REWIND(31)
   ICOUNT=0
   WR1=DCMPLX(0.0D0,0.0D0)
   DO
    READ(31,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
    IF (EOF /= 0) EXIT
    DO ICASHECOUNT=1,CASHESIZE
     IF (ICASHE1(ICASHECOUNT) == -1) EXIT
     ICOUNT=ICOUNT+1
     P=0
     Q=0
     R=0
     I=0
     J=0
     K=0
     L=0
     CALL MVBITS(ICASHE1(ICASHECOUNT),16,8,P,0)
     CALL MVBITS(ICASHE1(ICASHECOUNT), 8,8,Q,0)
     CALL MVBITS(ICASHE1(ICASHECOUNT), 0,8,R,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT),24,8,I,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT),16,8,J,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT), 8,8,K,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT), 0,8,L,0)
     WR1(I     ,J     ,K     ,L     )=DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR1(I+NCGS,J+NCGS,K     ,L     )=DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR1(I     ,J     ,K+NCGS,L+NCGS)=DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
     WR1(I+NCGS,J+NCGS,K+NCGS,L+NCGS)=DCMPLX(DCASHE(ICASHECOUNT),0.0D0)
    ENDDO
   ENDDO
   DO MOP=1,IALL(0,0,0)-IVIRTCORE
    DO I=1,2*NCGS
     DO J=1,2*NCGS
      DO K=1,2*NCGS
       WR2(I,J,K,MOP)=DCMPLX(0.0D0,0.0D0)
       DO L=1,2*NCGS
        WR2(I,J,K,MOP)=WR2(I,J,K,MOP)+CO(L,MOP,0)*WR1(I,J,K,L)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DO MOP=1,IALL(0,0,0)-IVIRTCORE
    DO MOQ=1,IALL(0,0,0)-IVIRTCORE
     DO I=1,2*NCGS
      DO J=1,2*NCGS
       WR1(I,J,MOQ,MOP)=DCMPLX(0.0D0,0.0D0)
       DO K=1,2*NCGS
        WR1(I,J,MOQ,MOP)=WR1(I,J,MOQ,MOP)+DCONJG(CO(K,MOQ,0))*WR2(I,J,K,MOP)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DO MOP=1,IALL(0,0,0)-IVIRTCORE
    DO MOQ=1,IALL(0,0,0)-IVIRTCORE
     DO MOR=1,IALL(0,0,0)-IVIRTCORE
      DO I=1,2*NCGS
       WR2(I,MOR,MOQ,MOP)=DCMPLX(0.0D0,0.0D0)
       DO J=1,2*NCGS
        WR2(I,MOR,MOQ,MOP)=WR2(I,MOR,MOQ,MOP)+CO(J,MOR,0)*WR1(I,J,MOQ,MOP)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DO MOP=1,IALL(0,0,0)-IVIRTCORE
    DO MOQ=1,IALL(0,0,0)-IVIRTCORE
     DO MOR=1,IALL(0,0,0)-IVIRTCORE
      DO MOS=1,IALL(0,0,0)-IVIRTCORE
       G(MOS,MOR,MOQ,MOP)=DCMPLX(0.0D0,0.0D0)
       DO I=1,2*NCGS
        G(MOS,MOR,MOQ,MOP)=G(MOS,MOR,MOQ,MOP)+DCONJG(CO(I,MOS,0))*WR2(I,MOR,MOQ,MOP)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(ICASHE1,ICASHE2,DCASHE)
   DEALLOCATE(WR1,WR2)
!  DO MOP=1,IALL(0,0,0)-IVIRTCORE
!   DO MOQ=1,IALL(0,0,0)-IVIRTCORE
!    DO MOR=1,IALL(0,0,0)-IVIRTCORE
!     DO MOS=1,IALL(0,0,0)-IVIRTCORE
!      WRITE(*,'(4I3,2F15.10)') MOP,MOQ,MOR,MOS,G(MOP,MOQ,MOR,MOS)-G(MOP,MOS,MOR,MOQ)
!     ENDDO
!    ENDDO
!   ENDDO
!  ENDDO

   EMP2=DCMPLX(0.0D0,0.0D0)
   DO MOI=ICORE+1,IOCC
    DO MOA=IOCC+1,IALL(0,0,0)-IVIRTCORE
     DO MOJ=ICORE+1,IOCC
      DO MOB=IOCC+1,IALL(0,0,0)-IVIRTCORE
       EMP2=EMP2+0.25D0*DCONJG(G(MOI,MOA,MOJ,MOB)-G(MOI,MOB,MOJ,MOA))*(G(MOI,MOA,MOJ,MOB)-G(MOI,MOB,MOJ,MOA)) &
       /(REPSILON(MOI,0)+REPSILON(MOJ,0)-REPSILON(MOA,0)-REPSILON(MOB,0))
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   WRITE(6,'(A,2F20.15)') 'MP2 ENERGY = ',EMP2

   RETURN
END SUBROUTINE



SUBROUTINE REL_GENERATE_CONFIGURATIONS(ORDER)
! GENERATE CONFIGURATIONS FOR ALPHA ELECTRONS

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: ORDER
   INTEGER :: I,J,K,L,M
   INTEGER :: I1,I2,I3,I4,I5,I6,I7,I8
   INTEGER(4) :: ICF
   INTEGER :: COMBINATION
   REAL :: MEM
   
   WRITE(6,'(A,I3)') 'GENERATE AND ORDER CONFIGURATIONS FOR ALPHA (BETA) ELECTRONS UP TO EXCITATION ',ORDER
   IF (ICORE > 0) WRITE(6,'(A,I3,A)') '***** WARNING : ',ICORE,' CORE ALPHA (BETA) ORBITALS ARE ALWAYS OCCUPIED'
   IF (IVIRTCORE > 0) WRITE(6,'(A,I3,A)') '***** WARNING : ', &
   IVIRTCORE,' HIGHEST VIRTUAL ALPHA (BETA) ORBITALS ARE ALWAYS UNOCCUPIED'
   WRITE(6,'(A,I3,A,I3,A)') 'THERE ARE ',IOCC-ICORE,' ACTIVE ALPHA (BETA) ELECTRONS IN ',IALL(0,0,0)-ICORE-IVIRTCORE,' ACTIVE ORBITALS'
   MEM=4.0*2**(IALL(0,0,0)-IVIRTCORE)
   IF (MEM > 1000000.0) WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE FOR THE ALPHA (BETA) STRINGS WILL BE ',MEM/1000000.0,' MB'
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   NCF=0
   DO I=0,ORDER
    J=COMBINATION(IOCC-ICORE,IOCC-ICORE-I)*COMBINATION(IALL(0,0,0)-IOCC-IVIRTCORE,I)
    WRITE(6,'(I4,A,I7)') I,' EXCITATION CONFIGURATIONS ',J
    NCF=NCF+J
   ENDDO
   WRITE(6,'(A,I7)') '    TOTAL ALPHA (BETA) CONFIGURATIONS ',NCF
   IF (NCF /= COMBINATION(IALL(0,0,0)-ICORE-IVIRTCORE,IOCC-ICORE)) CALL PABORT('AN ERROR OCCURRED IN COMBINATION FUNCTION')

   ALLOCATE(CFHALF(NCF),NORDER(NCF),ADDRSS(2**(IALLMAX-IVIRTCORE)))
   ADDRSS=0
   I=0
   IF (IOCC == 1) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE
     J=0
     IF (I1 <= ICORE) J=J+1
     IF (J /= ICORE) CYCLE
     J=0
     IF (I1 > IOCC) J=J+1
     IF (J > ORDER) CYCLE
     ICF=0
     ICF=IBSET(ICF,I1-1) 
     I=I+1
     CFHALF(I)=ICF
     NORDER(I)=J
     ADDRSS(ICF)=I
     IF (NORDER(I) <= 2) THEN
      K=0
      DO L=0,IALL(0,0,0)-IVIRTCORE-1
       IF (BTEST(ICF,L)) K=K+10**L
       IF (BTEST(ICF,L)) M=L
      ENDDO
      IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' ORDER = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
     ENDIF
    ENDDO
   ELSE IF (IOCC == 2) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-1
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE
      J=0
      IF (I1 <= ICORE) J=J+1
      IF (I2 <= ICORE) J=J+1
      IF (J /= ICORE) CYCLE
      J=0
      IF (I1 > IOCC) J=J+1
      IF (I2 > IOCC) J=J+1
      IF (J > ORDER) CYCLE
      ICF=0
      ICF=IBSET(ICF,I1-1) 
      ICF=IBSET(ICF,I2-1) 
      I=I+1
      CFHALF(I)=ICF
      NORDER(I)=J
      ADDRSS(ICF)=I
      IF (NORDER(I) <= 2) THEN
       K=0
       DO L=0,IALL(0,0,0)-IVIRTCORE-1
        IF (BTEST(ICF,L)) K=K+10**L
        IF (BTEST(ICF,L)) M=L
       ENDDO
       IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' ORDER = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
      ENDIF
     ENDDO
    ENDDO
   ELSE IF (IOCC == 3) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-2
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-1
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE
       J=0
       IF (I1 <= ICORE) J=J+1
       IF (I2 <= ICORE) J=J+1
       IF (I3 <= ICORE) J=J+1
       IF (J /= ICORE) CYCLE
       J=0
       IF (I1 > IOCC) J=J+1
       IF (I2 > IOCC) J=J+1
       IF (I3 > IOCC) J=J+1
       IF (J > ORDER) CYCLE
       ICF=0
       ICF=IBSET(ICF,I1-1) 
       ICF=IBSET(ICF,I2-1) 
       ICF=IBSET(ICF,I3-1) 
       I=I+1
       CFHALF(I)=ICF
       NORDER(I)=J
       ADDRSS(ICF)=I
       IF (NORDER(I) <= 2) THEN
        K=0
        DO L=0,IALL(0,0,0)-IVIRTCORE-1
         IF (BTEST(ICF,L)) K=K+10**L
         IF (BTEST(ICF,L)) M=L
        ENDDO
        IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' ORDER = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
       ENDIF
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 4) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-3
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-2
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-1
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE
        J=0
        IF (I1 <= ICORE) J=J+1
        IF (I2 <= ICORE) J=J+1
        IF (I3 <= ICORE) J=J+1
        IF (I4 <= ICORE) J=J+1
        IF (J /= ICORE) CYCLE
        J=0
        IF (I1 > IOCC) J=J+1
        IF (I2 > IOCC) J=J+1
        IF (I3 > IOCC) J=J+1
        IF (I4 > IOCC) J=J+1
        IF (J > ORDER) CYCLE
        ICF=0
        ICF=IBSET(ICF,I1-1) 
        ICF=IBSET(ICF,I2-1) 
        ICF=IBSET(ICF,I3-1) 
        ICF=IBSET(ICF,I4-1) 
        I=I+1
        CFHALF(I)=ICF
        NORDER(I)=J
        ADDRSS(ICF)=I
        IF (NORDER(I) <= 2) THEN
         K=0
         DO L=0,IALL(0,0,0)-IVIRTCORE-1
          IF (BTEST(ICF,L)) K=K+10**L
          IF (BTEST(ICF,L)) M=L
         ENDDO
         IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' ORDER = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
        ENDIF
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 5) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-4
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-3
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-2
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-1
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE
         J=0
         IF (I1 <= ICORE) J=J+1
         IF (I2 <= ICORE) J=J+1
         IF (I3 <= ICORE) J=J+1
         IF (I4 <= ICORE) J=J+1
         IF (I5 <= ICORE) J=J+1
         IF (J /= ICORE) CYCLE
         J=0
         IF (I1 > IOCC) J=J+1
         IF (I2 > IOCC) J=J+1
         IF (I3 > IOCC) J=J+1
         IF (I4 > IOCC) J=J+1
         IF (I5 > IOCC) J=J+1
         IF (J > ORDER) CYCLE
         ICF=0
         ICF=IBSET(ICF,I1-1) 
         ICF=IBSET(ICF,I2-1) 
         ICF=IBSET(ICF,I3-1) 
         ICF=IBSET(ICF,I4-1) 
         ICF=IBSET(ICF,I5-1) 
         I=I+1
         CFHALF(I)=ICF
         NORDER(I)=J
         ADDRSS(ICF)=I
         IF (NORDER(I) <= 2) THEN
          K=0
          DO L=0,IALL(0,0,0)-IVIRTCORE-1
           IF (BTEST(ICF,L)) K=K+10**L
           IF (BTEST(ICF,L)) M=L
          ENDDO
          IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' ORDER = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
         ENDIF
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 6) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-5
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-4
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-3
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-2
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE-1
         DO I6=I5+1,IALL(0,0,0)-IVIRTCORE
          J=0
          IF (I1 <= ICORE) J=J+1
          IF (I2 <= ICORE) J=J+1
          IF (I3 <= ICORE) J=J+1
          IF (I4 <= ICORE) J=J+1
          IF (I5 <= ICORE) J=J+1
          IF (I6 <= ICORE) J=J+1
          IF (J /= ICORE) CYCLE
          J=0
          IF (I1 > IOCC) J=J+1
          IF (I2 > IOCC) J=J+1
          IF (I3 > IOCC) J=J+1
          IF (I4 > IOCC) J=J+1
          IF (I5 > IOCC) J=J+1
          IF (I6 > IOCC) J=J+1
          IF (J > ORDER) CYCLE
          ICF=0
          ICF=IBSET(ICF,I1-1) 
          ICF=IBSET(ICF,I2-1) 
          ICF=IBSET(ICF,I3-1) 
          ICF=IBSET(ICF,I4-1) 
          ICF=IBSET(ICF,I5-1) 
          ICF=IBSET(ICF,I6-1) 
          I=I+1
          CFHALF(I)=ICF
          NORDER(I)=J
          ADDRSS(ICF)=I
          IF (NORDER(I) <= 2) THEN
           K=0
           DO L=0,IALL(0,0,0)-IVIRTCORE-1
            IF (BTEST(ICF,L)) K=K+10**L
            IF (BTEST(ICF,L)) M=L
           ENDDO
           IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' ORDER = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
          ENDIF
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 7) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-6
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-5
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-4
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-3
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE-2
         DO I6=I5+1,IALL(0,0,0)-IVIRTCORE-1
          DO I7=I6+1,IALL(0,0,0)-IVIRTCORE
           J=0
           IF (I1 <= ICORE) J=J+1
           IF (I2 <= ICORE) J=J+1
           IF (I3 <= ICORE) J=J+1
           IF (I4 <= ICORE) J=J+1
           IF (I5 <= ICORE) J=J+1
           IF (I6 <= ICORE) J=J+1
           IF (I7 <= ICORE) J=J+1
           IF (J /= ICORE) CYCLE
           J=0
           IF (I1 > IOCC) J=J+1
           IF (I2 > IOCC) J=J+1
           IF (I3 > IOCC) J=J+1
           IF (I4 > IOCC) J=J+1
           IF (I5 > IOCC) J=J+1
           IF (I6 > IOCC) J=J+1
           IF (I7 > IOCC) J=J+1
           IF (J > ORDER) CYCLE
           ICF=0
           ICF=IBSET(ICF,I1-1) 
           ICF=IBSET(ICF,I2-1) 
           ICF=IBSET(ICF,I3-1) 
           ICF=IBSET(ICF,I4-1) 
           ICF=IBSET(ICF,I5-1) 
           ICF=IBSET(ICF,I6-1) 
           ICF=IBSET(ICF,I7-1) 
           I=I+1
           CFHALF(I)=ICF
           NORDER(I)=J
           ADDRSS(ICF)=I
           IF (NORDER(I) <= 2) THEN
            K=0
            DO L=0,IALL(0,0,0)-IVIRTCORE-1
             IF (BTEST(ICF,L)) K=K+10**L
             IF (BTEST(ICF,L)) M=L
            ENDDO
            IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' ORDER = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
           ENDIF
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 8) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-7
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-6
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-5
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-4
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE-3
         DO I6=I5+1,IALL(0,0,0)-IVIRTCORE-2
          DO I7=I6+1,IALL(0,0,0)-IVIRTCORE-1
           DO I8=I7+1,IALL(0,0,0)-IVIRTCORE
            J=0
            IF (I1 <= ICORE) J=J+1
            IF (I2 <= ICORE) J=J+1
            IF (I3 <= ICORE) J=J+1
            IF (I4 <= ICORE) J=J+1
            IF (I5 <= ICORE) J=J+1
            IF (I6 <= ICORE) J=J+1
            IF (I7 <= ICORE) J=J+1
            IF (I8 <= ICORE) J=J+1
            IF (J /= ICORE) CYCLE
            J=0
            IF (I1 > IOCC) J=J+1
            IF (I2 > IOCC) J=J+1
            IF (I3 > IOCC) J=J+1
            IF (I4 > IOCC) J=J+1
            IF (I5 > IOCC) J=J+1
            IF (I6 > IOCC) J=J+1
            IF (I7 > IOCC) J=J+1
            IF (I8 > IOCC) J=J+1
            IF (J > ORDER) CYCLE
            ICF=0
            ICF=IBSET(ICF,I1-1) 
            ICF=IBSET(ICF,I2-1) 
            ICF=IBSET(ICF,I3-1) 
            ICF=IBSET(ICF,I4-1) 
            ICF=IBSET(ICF,I5-1) 
            ICF=IBSET(ICF,I6-1) 
            ICF=IBSET(ICF,I7-1) 
            ICF=IBSET(ICF,I8-1) 
            I=I+1
            CFHALF(I)=ICF
            NORDER(I)=J
            ADDRSS(ICF)=I
            IF (NORDER(I) <= 2) THEN
             K=0
             DO L=0,IALL(0,0,0)-IVIRTCORE-1
              IF (BTEST(ICF,L)) K=K+10**L
              IF (BTEST(ICF,L)) M=L
             ENDDO
             IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' ORDER = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
            ENDIF
           ENDDO
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE
    CALL PABORT('NUMBER OF ELECTRONS IS TOO LARGE')
   ENDIF

   RETURN
END SUBROUTINE



SUBROUTINE REL_HAMILTONIAN_PRODUCT(INFILE,OUTFILE,OFFSET,ORDER)
! FORM THE PRODUCT OF HAMILTONIAN MATRIX AND A TRIAL VECTOR IN INFILE
! AND STORE THE PRODUCT VECTOR IN OUTFILE.  THE ORDER LIMITS THE NUMBER
! EXCITATION IN THE CONFIGURATIONS CONSIDERED.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: INFILE,OUTFILE,OFFSET
   INTEGER :: ORDER
   INTEGER :: ISIGN,JSIGN
   INTEGER :: I,J,K,L,M
   INTEGER :: IA,IB,IC,ID
   INTEGER :: NIA,NIB,NJA,NJB
   INTEGER(4) :: CFONE,CFTWO
   REAL :: MEM,ICPUS,ICPUE,EST
   DOUBLE COMPLEX :: X,Y
   DOUBLE COMPLEX,ALLOCATABLE :: TRL(:,:),PRD(:,:)
   INTEGER,ALLOCATABLE :: PSIGN(:,:,:),PADRS(:,:,:)

!  CALL PCPU_TIME(ICPUS)
   MEM=16.0*2.0*NCF**2+4.0*2.0*NCF*(IALL(0,0,0)-IVIRTCORE)**2
!  IF (MEM > 1000000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
!  ELSE IF (MEM > 1000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
!  ELSE
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
!  ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 

   ALLOCATE(TRL(1,NCF),PRD(1,NCF),PSIGN(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,NCF),PADRS(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,NCF))

   ! READ TRIAL VECTOR FROM FILE INFILE
   REWIND(INFILE)
   DO I=0,OFFSET
    READ(INFILE) TRL
   ENDDO

   ! ZERO SCRATCH TRIAL VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   DO IA=1,NCF
    DO IB=1,1
     IF (NORDER(IA)+NORDER(IB) > ORDER) TRL(IB,IA)=DCMPLX(0.0D0,0.0D0)
    ENDDO
   ENDDO

   ! ZERO SCRATCH PRODUCT VECTOR
   PRD=DCMPLX(0.0D0,0.0D0)

   ! DIAGONAL ELEMENTS
   DO IA=1,NCF
    DO IB=1,1
     DO I=1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFHALF(IA),I-1)) PRD(IB,IA)=PRD(IB,IA)+H(I,I)*TRL(IB,IA)
!     IF (BTEST(CFHALF(IB),I-1)) PRD(IB,IA)=PRD(IB,IA)+H(I,I)*TRL(IB,IA)
     ENDDO
    ENDDO
   ENDDO
   DO IA=1,NCF
    DO IB=1,1
     DO I=1,IALL(0,0,0)-IVIRTCORE
      DO J=1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),I-1)) THEN
        NIA=1
       ELSE
        NIA=0
       ENDIF
       IF (BTEST(CFHALF(IA),J-1)) THEN
        NJA=1
       ELSE
        NJA=0
       ENDIF
!      IF (BTEST(CFHALF(IB),I-1)) THEN
!       NIB=1
!      ELSE
        NIB=0
!      ENDIF
!      IF (BTEST(CFHALF(IB),J-1)) THEN
!       NJB=1
!      ELSE
        NJB=0
!      ENDIF
       PRD(IB,IA)=PRD(IB,IA)+0.5D0*(DFLOAT((NJA+NJB)*(NIA+NIB))*G(J,J,I,I) &
                 -DFLOAT(NJA*NIA+NJB*NIB)*G(J,I,I,J))*TRL(IB,IA)
      ENDDO
     ENDDO
    ENDDO
   ENDDO

   ! ONE SPIN ORBITAL DIFFERENCE
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(CFHALF(IA),I-1)) THEN
      DO K=1,IALL(0,0,0)-IVIRTCORE
       IF (.NOT.(BTEST(CFHALF(IA),K-1))) THEN
        CFONE=IBCLR(CFHALF(IA),I-1)
        CFONE=IBSET(CFONE,K-1)
        IC=ADDRSS(CFONE)
        X=H(K,I)
        DO J=1,IALL(0,0,0)-IVIRTCORE
         IF ((J /= I).AND.(J /= K).AND.(BTEST(CFONE,J-1))) X=X+G(K,I,J,J)-G(K,J,J,I)
        ENDDO
        ISIGN=1
        DO J=1,I
         IF (BTEST(CFHALF(IA),J-1)) ISIGN=-ISIGN
        ENDDO
        DO J=1,K
         IF (BTEST(CFONE,J-1)) ISIGN=-ISIGN
        ENDDO
        DO IB=1,1
         IF (CDABS(TRL(IB,IA)) > 1.0D-15) THEN
          Y=DCMPLX(0.0D0,0.0D0)
!         DO J=1,IALL(0,0,0)-IVIRTCORE
!          IF (BTEST(CFHALF(IB),J-1)) Y=Y+G(K,I,J,J)
!         ENDDO
          PRD(IB,IC)=PRD(IB,IC)+(X+Y)*DFLOAT(ISIGN)*TRL(IB,IA)
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
!  DO IB=1,1
!   DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
!    IF (BTEST(CFHALF(IB),I-1)) THEN
!     DO K=1,IALL(0,0,0)-IVIRTCORE
!      IF (.NOT.(BTEST(CFHALF(IB),K-1))) THEN
!       CFONE=IBCLR(CFHALF(IB),I-1)
!       CFONE=IBSET(CFONE,K-1)
!       IC=ADDRSS(CFONE)
!       X=H(K,I)
!       DO J=1,IALL(0,0,0)-IVIRTCORE
!        IF ((J /= I).AND.(J /= K).AND.(BTEST(CFONE,J-1))) X=X+G(K,I,J,J)-G(K,J,J,I)
!       ENDDO
!       ISIGN=1
!       DO J=1,I
!        IF (BTEST(CFHALF(IB),J-1)) ISIGN=-ISIGN
!       ENDDO
!       DO J=1,K
!        IF (BTEST(CFONE,J-1)) ISIGN=-ISIGN
!       ENDDO
!       DO IA=1,NCF
!        IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
!         Y=0.0D0
!         DO J=1,IALL(0,0,0)-IVIRTCORE
!          IF (BTEST(CFHALF(IA),J-1)) Y=Y+G(K,I,J,J)
!         ENDDO
!         PRD(IC,IA)=PRD(IC,IA)+(X+Y)*DFLOAT(ISIGN)*TRL(IB,IA)
!        ENDIF
!       ENDDO
!      ENDIF
!     ENDDO
!    ENDIF
!   ENDDO
!  ENDDO

   ! TWO SPIN ORBITAL DIFFERENCES, CASE 1
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE-1
     IF (BTEST(CFHALF(IA),I-1)) THEN
      DO J=I+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),J-1)) THEN
        DO K=1,IALL(0,0,0)-IVIRTCORE-1
         IF (.NOT.(BTEST(CFHALF(IA),K-1))) THEN
          DO L=K+1,IALL(0,0,0)-IVIRTCORE
           IF (.NOT.(BTEST(CFHALF(IA),L-1))) THEN
            CFTWO=IBCLR(CFHALF(IA),I-1)
            CFTWO=IBCLR(CFTWO,J-1)
            CFTWO=IBSET(CFTWO,K-1)
            CFTWO=IBSET(CFTWO,L-1)
            IC=ADDRSS(CFTWO)
            ISIGN=1
            DO M=1,I
             IF (BTEST(CFHALF(IA),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,J
             IF (BTEST(CFHALF(IA),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,K
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,L
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            Y=DFLOAT(ISIGN)*(G(K,I,L,J)-G(K,J,L,I))
            DO IB=1,1
             PRD(IB,IC)=PRD(IB,IC)+Y*TRL(IB,IA)
            ENDDO
           ENDIF
          ENDDO
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
!  DO IB=1,1
!   DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE-1
!    IF (BTEST(CFHALF(IB),I-1)) THEN
!     DO J=I+1,IALL(0,0,0)-IVIRTCORE
!      IF (BTEST(CFHALF(IB),J-1)) THEN
!       DO K=1,IALL(0,0,0)-IVIRTCORE-1
!        IF (.NOT.(BTEST(CFHALF(IB),K-1))) THEN
!         DO L=K+1,IALL(0,0,0)-IVIRTCORE
!          IF (.NOT.(BTEST(CFHALF(IB),L-1))) THEN
!           CFTWO=IBCLR(CFHALF(IB),I-1)
!           CFTWO=IBCLR(CFTWO,J-1)
!           CFTWO=IBSET(CFTWO,K-1)
!           CFTWO=IBSET(CFTWO,L-1)
!           IC=ADDRSS(CFTWO)
!           ISIGN=1
!           DO M=1,I
!            IF (BTEST(CFHALF(IB),M-1)) ISIGN=-ISIGN
!           ENDDO
!           DO M=1,J
!            IF (BTEST(CFHALF(IB),M-1)) ISIGN=-ISIGN
!           ENDDO
!           DO M=1,K
!            IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
!           ENDDO
!           DO M=1,L
!            IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
!           ENDDO
!           Y=DFLOAT(ISIGN)*(G(K,I,L,J)-G(K,J,L,I))
!           DO IA=1,NCF
!            PRD(IC,IA)=PRD(IC,IA)+Y*TRL(IB,IA)
!           ENDDO
!          ENDIF
!         ENDDO
!        ENDIF
!       ENDDO
!      ENDIF
!     ENDDO
!    ENDIF
!   ENDDO
!  ENDDO
!  CALL PCPU_TIME(ICPUE)
!  EST=ICPUE-ICPUS
!  CALL PCPU_TIME(ICPUS)

   ! TWO SPIN ORBITAL DIFFERENCES, CASE 2
!  DO IB=1,1
!   DO K=ICORE+1,IALL(0,0,0)-IVIRTCORE
!    DO L=1,IALL(0,0,0)-IVIRTCORE
!     PSIGN(L,K,IB)=0
!     PADRS(L,K,IB)=0
!     IF ((BTEST(CFHALF(IB),K-1)).AND.(.NOT.(BTEST(CFHALF(IB),L-1)))) THEN
!      CFONE=IBCLR(CFHALF(IB),K-1)
!      CFONE=IBSET(CFONE,L-1)
!      PADRS(L,K,IB)=ADDRSS(CFONE)
!      JSIGN=1
!      DO M=1,K
!       IF (BTEST(CFHALF(IB),M-1)) JSIGN=-JSIGN
!      ENDDO
!      DO M=1,L
!       IF (BTEST(CFONE,M-1)) JSIGN=-JSIGN
!      ENDDO
!      PSIGN(L,K,IB)=JSIGN
!     ENDIF
!    ENDDO
!   ENDDO
!  ENDDO
!  DO IA=1,NCF
!   DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
!    DO J=1,IALL(0,0,0)-IVIRTCORE
!     IF ((BTEST(CFHALF(IA),I-1)).AND.(.NOT.(BTEST(CFHALF(IA),J-1)))) THEN
!      CFONE=IBCLR(CFHALF(IA),I-1)
!      CFONE=IBSET(CFONE,J-1)
!      IC=ADDRSS(CFONE)
!      ISIGN=1
!      DO K=1,I
!       IF (BTEST(CFHALF(IA),K-1)) ISIGN=-ISIGN
!      ENDDO
!      DO K=1,J
!       IF (BTEST(CFONE,K-1)) ISIGN=-ISIGN
!      ENDDO
!      DO IB=1,1
!       IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
!        DO K=ICORE+1,IALL(0,0,0)-IVIRTCORE
!         DO L=1,IALL(0,0,0)-IVIRTCORE
!          IF (PADRS(L,K,IB) /= 0) PRD(PADRS(L,K,IB),IC)=PRD(PADRS(L,K,IB),IC)+DFLOAT(ISIGN*PSIGN(L,K,IB))*G(J,I,L,K)*TRL(IB,IA)
!         ENDDO
!        ENDDO
!       ENDIF
!      ENDDO
!     ENDIF
!    ENDDO
!   ENDDO
!   CALL PCPU_TIME(ICPUE)
!   IF (IA == 1) THEN
!    EST=EST+(ICPUE-ICPUS)*NCF
!    EST=EST/3600.0
!    IF (EST > 0.1) WRITE(6,'(A,F20.1,A)') '***** WARNING : ESTIMATED PRODUCT FORMATION TIME = ',EST,' HOURS'
!   ENDIF
!  ENDDO

   ! ZERO SCRATCH PRODUCT VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   DO IA=1,NCF
    DO IB=1,1
     IF (NORDER(IA)+NORDER(IB) > ORDER) PRD(IB,IA)=DCMPLX(0.0D0,0.0D0)
    ENDDO
   ENDDO

   ! STORE PRODUCT VECTOR
   REWIND(OUTFILE)
   IF (OFFSET == 0) THEN
    WRITE(OUTFILE) PRD
   ELSE
    DO I=1,OFFSET
     READ(OUTFILE) TRL
    ENDDO
    WRITE(OUTFILE) PRD
   ENDIF

   DEALLOCATE(TRL,PRD,PSIGN,PADRS)

   RETURN
END SUBROUTINE



SUBROUTINE REL_FULL_HAMILTONIAN(ORDER)
! FORM FULL HAMILTONIAN AND DIAGONALIZE IT BY THE STANDARD ALGORITHMS.
! CAUTION, DO NOT USE THIS FOR PRODUCTION RUN.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL,PARAMETER :: LEVEC = .FALSE.
   INTEGER :: ORDER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: INFO
   REAL :: MEM,DEV
   DOUBLE PRECISION,ALLOCATABLE :: HAM(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: VL(:,:),VR(:,:),ER(:),EI(:),WK(:)
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:)

   WRITE(6,'(I2,A)') ORDER,'-ORDER CONFIGURATION INTERACTION CALCULATION FOR ALL STATES'
   IF (LEVEC) THEN 
    MEM=16.0*(2.0*NCF**4+8.0*NCF**2)
   ELSE
    MEM=16.0*(NCF**4+9.0*NCF**2)
   ENDIF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   ALLOCATE(HAM(NCF,NCF),VL(1,NCF),ER(NCF),EI(NCF),WK(4*NCF))
   IF (LEVEC) THEN 
    ALLOCATE(VR(NCF,NCF))
   ELSE
    ALLOCATE(VR(1,NCF))
   ENDIF
   ALLOCATE(TRL(1,NCF))

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')

   ! FORM HAMILTONIAN AND KEEP IT IN MEMORY
   DO IA=1,NCF
    DO IB=1,1
     TRL=0.0D0
     IF (NORDER(IA)+NORDER(IB) <= ORDER) TRL(IA,IB)=1.0D0
     REWIND(50)
     WRITE(50) TRL
     CALL REL_HAMILTONIAN_PRODUCT(50,60,0,ORDER)
     REWIND(60)
     READ(60) TRL
     DO IC=1,NCF
      DO ID=1,1
       HAM((IA-1)*NCF+IB,(IC-1)*NCF+ID)=TRL(IC,ID)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
!  CALL DUMP5(HAM,NCF**2)

   DEALLOCATE(TRL)
   CLOSE(50)
   CLOSE(60)

   ! DIAGONALIZE HAMILTONIAN
   IF (LEVEC) THEN
    CALL DGEEV('N','V',NCF,HAM,NCF,ER,EI,VL,1,VR,NCF,WK,4*NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT(NCF,NCF,ER,VR,EI)
    DO IA=1,MIN(25,NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
     DO IB=1,1
      WRITE(6,'(I10,F20.15)') IB,VR(IB,IA)
     ENDDO
    ENDDO
   ELSE
    CALL DGEEV('N','N',NCF,HAM,NCF,ER,EI,VL,1,VR,1,WK,4*NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT_EVALONLY(NCF,ER)
    DO IA=1,MIN(25,NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
    ENDDO
   ENDIF
   CALL PFLUSH(6)

   DEALLOCATE(HAM,VL,VR,ER,EI,WK)

   RETURN
END SUBROUTINE



SUBROUTINE REL_HIGHORDER_MP(ORDER)
! PERFORM HIGH-ORDER MOELLER-PLESSET PERTURBATION CALCULATIONS IN A RECURSIVE ALGORITHM.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER,PARAMETER :: MAXFILE = 100
   INTEGER :: ORDER
   INTEGER :: MOI,MOJ
   INTEGER :: IA,IB
   INTEGER :: I,J,K,IFILE
   REAL :: MEM,ICPUS,ICPUE
   DOUBLE PRECISION :: HA,HB
   DOUBLE PRECISION :: EMP,DMP(0:ORDER)
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:)

   CALL PCPU_TIME(ICPUS)
   WRITE(6,'(A)') 'RECURSIVE HIGH-ORDER MOELLER-PLESSET PERTURBATION CALCULATIONS WILL BE PERFORMED'
   MEM=16.0*2.0*NCF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   WRITE(6,'(A)') '------------------------------------------------------'
   WRITE(6,'(A)') 'ORDER      CORRELATION        TOTAL ENERGY   CPU / SEC'
   ALLOCATE(VEC1(1,NCF),VEC2(1,NCF))
   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')

   ! INITIALIZE WAVEFUNCTION TO THE HARTREE-FOCK DETERMINANT
   EMP=NUCLEAR_REPULSION
   VEC1=0.0D0
   VEC1(1,1)=1.0D0
   REWIND(50)
   WRITE(50) VEC1

   ! DMP(0)
   DMP(0)=0.0D0
   DO MOI=1,IOCC
    DMP(0)=DMP(0)+2.0D0*REPSILON(MOI,0)
   ENDDO
   EMP=EMP+DMP(0)
   WRITE(6,'(I2,F20.10,F20.10,F12.1)') 0,DMP(0),EMP,0.0

   ! DMP(1) ONWARD
   DO IFILE=0,ORDER-1
    IF (IOPTN(9) >= 3) THEN
     REWIND(50)
     DO I=0,IFILE
      READ(50) VEC1
     ENDDO
     WRITE(6,'(I3,A)') IFILE,'TH ORDER WAVE FUNCTION'
     CALL DUMP5(VEC1,NCF)
    ENDIF
    DEALLOCATE(VEC1,VEC2)
    CALL REL_HAMILTONIAN_PRODUCT(50,51,IFILE,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))
    ALLOCATE(VEC1(1,NCF),VEC2(1,NCF))
    REWIND(51)
    DO I=0,IFILE
     READ(51) VEC1
    ENDDO
    IF (IOPTN(9) >= 3) THEN
     WRITE(6,'(A,I1,A)') 'H|',IFILE,'>'
     CALL DUMP5(VEC1,NCF)
    ENDIF
    IF (IFILE == 0) THEN
     DMP(1)=-DMP(0)
     DO MOI=1,IOCC
      DMP(1)=DMP(1)+2.0D0*H(MOI,MOI)
     ENDDO
     DO MOI=1,IOCC
      DO MOJ=1,IOCC
       DMP(1)=DMP(1)+(2.0D0*G(MOI,MOI,MOJ,MOJ)-G(MOI,MOJ,MOJ,MOI))
      ENDDO
     ENDDO
    ELSE
     DMP(IFILE+1)=VEC1(1,1)
    ENDIF
    EMP=EMP+DMP(IFILE+1)
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(I2,F20.10,F20.10,F12.1)') IFILE+1,DMP(IFILE+1),EMP,ICPUE-ICPUS
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)
    IF (DABS(DMP(IFILE+1)) < 1.0D-15) EXIT
    VEC1=-VEC1
    REWIND(50)
    DO K=0,IFILE
     READ(50) VEC2
     DO IA=1,NCF
      HA=0.0D0
      IF (K == IFILE) THEN
       DO I=1,IALL(0,0,0)-IVIRTCORE
        IF (BTEST(CFHALF(IA),I-1)) HA=HA+REPSILON(I,0)
       ENDDO
      ENDIF
      DO IB=1,1
       HB=0.0D0
       IF (K == IFILE) THEN
        DO I=1,IALL(0,0,0)-IVIRTCORE
         IF (BTEST(CFHALF(IB),I-1)) HB=HB+REPSILON(I,0)
        ENDDO
       ENDIF
       IF (K == IFILE) THEN
        VEC1(IB,IA)=VEC1(IB,IA)+(DMP(IFILE-K+1)+HA+HB)*VEC2(IB,IA)
       ELSE
        VEC1(IB,IA)=VEC1(IB,IA)+DMP(IFILE-K+1)*VEC2(IB,IA)
       ENDIF
      ENDDO
     ENDDO
    ENDDO
    DO IA=1,NCF
     HA=0.0D0
     DO I=1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFHALF(IA),I-1)) HA=HA+REPSILON(I,0)
     ENDDO
     DO IB=1,1
      HB=0.0D0
      DO I=1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IB),I-1)) HB=HB+REPSILON(I,0)
      ENDDO
      IF ((IA == 1).AND.(IB == 1)) THEN
       VEC2(IB,IA)=0.0D0
      ELSE
       VEC2(IB,IA)=VEC1(IB,IA)/(HA+HB-DMP(0))
      ENDIF
     ENDDO
    ENDDO
    IF (IFILE == MAXFILE) EXIT
    WRITE(50) VEC2
   ENDDO

   WRITE(6,'(A)') '------------------------------------------------------'
   DEALLOCATE(VEC1,VEC2)
   CLOSE(50)
   CLOSE(51)
   RETURN
END SUBROUTINE



SUBROUTINE REL_CI_GUESS(ORDER,NROOTS,NTRIALS)
! GENERATE INITIAL GUESS TRIAL VECTORS FOR CI CALCULATIONS.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER :: ORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: IA,IB,JA,JB
   INTEGER :: I
   DOUBLE PRECISION :: H1,H2
   DOUBLE PRECISION,ALLOCATABLE :: H3(:)
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:)

   IF (NROOTS < 1) CALL PABORT('ILLEGAL NUMBER OF CI ROOTS')
   IF ((ORDER < 1).OR.(ORDER > 2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))) CALL PABORT('ILLEGAL NUMBER OF CI ORDER')

   WRITE(6,'(A)') 'INITIAL GUESS FOR THE CI/EOMCC VECTORS WILL BE GENERATED'

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   REWIND(50)

   ALLOCATE(H3(NCF),VEC1(1,NCF))
   ! CALCULATE THE SUM OF EPSILONS FOR EACH CONFIGURATION
   DO IA=1,NCF
    H3(IA)=0.0D0
    DO I=1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(CFHALF(IA),I-1)) H3(IA)=H3(IA)+REPSILON(I,0)
    ENDDO
   ENDDO

   ! DETERMINE THE THRESHOLD FOR NULLY AND SINGLY SUBSTITUTED DETERMINANTS
   DO IA=1,NCF
    DO IB=1,1
     VEC1(IB,IA)=H3(IB)+H3(IA)
    ENDDO
   ENDDO
   NTRIALS=0
   DO
    H1=1.0D90
    JB=0
    DO IA=1,NCF
     DO IB=1,1
      IF (NORDER(IA)+NORDER(IB) >= 2) CYCLE
      IF (VEC1(IB,IA) < H1) THEN
       H1=VEC1(IB,IA)
       JB=IB
       JA=IA
      ENDIF
     ENDDO
    ENDDO
    IF (JB == 0) CALL PABORT('DECREASE THE NUMBER OF ROOTS')
    NTRIALS=NTRIALS+1
    IF (((NROOTS == 1).AND.(NTRIALS == NROOTS)).OR.(NTRIALS >= NROOTS*3/2)) EXIT
    VEC1(JB,JA)=1.0D99
   ENDDO
   IF (IOPTN(9) >= 2) WRITE(6,'(A,F24.10)') 'THRESHOLD (0+1 DETERMINANTS) = ',H1

   ! DETERMINE THE THRESHOLD FOR DOUBLY AND HIGHER SUBSTITUTED DETERMINANTS
   IF (ORDER >= 2) THEN
    DO IA=1,NCF
     DO IB=1,1
      VEC1(IB,IA)=H3(IB)+H3(IA)
     ENDDO
    ENDDO
    NTRIALS=0
    DO
     H2=1.0D90
     JB=0
     DO IA=1,NCF
      DO IB=1,1
       IF ((NORDER(IA)+NORDER(IB) < 2).OR.(NORDER(IA)+NORDER(IB) > ORDER)) CYCLE
       IF (VEC1(IB,IA) < H2) THEN
        H2=VEC1(IB,IA)
        JB=IB
        JA=IA
       ENDIF
      ENDDO
     ENDDO
     IF (JB == 0) CALL PABORT('DECREASE THE NUMBER OF ROOTS')
     NTRIALS=NTRIALS+1
     IF (NTRIALS >= NROOTS/2) EXIT
     VEC1(JB,JA)=1.0D99
    ENDDO
    IF (IOPTN(9) >= 2) WRITE(6,'(A,F24.10)') 'THRESHOLD (2 DETERMINANTS)   = ',H2
   ENDIF

   ! GENERATE INITIAL TRIAL VECTORS
   NTRIALS=0
   REWIND(50)
   DO IA=1,NCF
    DO IB=1,1
     IF (NORDER(IA)+NORDER(IB) > ORDER) CYCLE
     IF (((H3(IB)+H3(IA) <= H1).AND.(NORDER(IA)+NORDER(IB) <= 1)).OR. &
         ((NROOTS > 1).AND.(H3(IB)+H3(IA) <= H2).AND.(NORDER(IA)+NORDER(IB) >= 2))) THEN
      NTRIALS=NTRIALS+1
      VEC1=0.0D0
      VEC1(IB,IA)=1.0D0
      WRITE(50) VEC1
     ENDIF
    ENDDO
   ENDDO 
   DEALLOCATE(H3,VEC1)
   CLOSE(50)

   RETURN
END SUBROUTINE



SUBROUTINE REL_HIGHORDER_CI(ORDER,NROOTS,NTRIALS)
! PERFORM HIGH-ORDER CONFIGURATION INTERACTION CALCULATIONS BY THE DAVIDSON'S ALGORITHM.

   USE CONSTANTS
   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER,PARAMETER :: MAXFILE = 1000
   INTEGER,PARAMETER :: MAXCYCLE = 1000
   INTEGER :: ICYCLE
   INTEGER :: ORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: NTRIALS_NEXT
   INTEGER :: IA,IB
   INTEGER :: I,J,K,L,NOPEN
   INTEGER,ALLOCATABLE :: N(:)
   REAL :: MEM,ICPUS,ICPUE
   LOGICAL :: LDONE(MAXFILE)
   DOUBLE PRECISION :: DEVSQ,DEVMAX,D,F,S2
   DOUBLE PRECISION :: SMALLH(MAXFILE,MAXFILE),LAMBDA(MAXFILE),ECI(MAXFILE)
   DOUBLE PRECISION :: W1(MAXFILE,MAXFILE),W2(MAXFILE)
   DOUBLE PRECISION :: PERCENTS,PERCENTD
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:)

   CALL PCPU_TIME(ICPUS)
   WRITE(6,'(A)') 'HIGH-ORDER CONFIGURATION INTERACTION CALCULATIONS WILL BE PERFORMED'
   WRITE(6,'(A,I2)') 'CI ORDER IS ',ORDER
   WRITE(6,'(A,I4)') 'THE NUMBER OF CI ROOTS SOUGHT ',NROOTS
   WRITE(6,'(A,I4)') 'THE NUMBER OF INITIAL TRIAL VECTORS ',NTRIALS
   MEM=16.0*2.0*NCF**2
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   IF (NROOTS > 1) THEN
    WRITE(6,'(A)') '-----------------------------------------------------------------------'
    WRITE(6,'(A)') '             DEVIATION        OMEGA / EV       TOTAL ENERGY   CPU / SEC'
   ELSE
    WRITE(6,'(A)') '----------------------------------------------------------------'
    WRITE(6,'(A)') 'ITR    DEVIATION     CORRELATION        TOTAL ENERGY   CPU / SEC'
   ENDIF
   ALLOCATE(VEC1(1,NCF),VEC2(1,NCF),N(IALLMAX-IVIRTCORE))
   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fi1',FORM='UNFORMATTED')

   ! INITIALIZE
   LDONE=.FALSE.
   IF (NTRIALS > MAXFILE) CALL PABORT('TOO MANY INITIAL TRIAL VECTORS')

   ! DAVIDSON ITERATION
   DO ICYCLE=1,MAXCYCLE

    ! CALCULATE H|0> AND STORE IT IN FILE 70
    DEALLOCATE(VEC1,VEC2)
    DO I=1,NTRIALS
     IF (.NOT.LDONE(I)) THEN
      CALL REL_HAMILTONIAN_PRODUCT(50,51,I-1,ORDER)
      LDONE(I)=.TRUE.
     ENDIF
    ENDDO
    ALLOCATE(VEC1(1,NCF),VEC2(1,NCF))

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|N> FOR DEBUG
!   DO I=1,NTRIALS
!    REWIND(50)
!    DO J=1,I
!     READ(50) VEC1
!    ENDDO
!    REWIND(50)
!    DO L=1,NTRIALS
!     READ(50) VEC2
!     SMALLH(I,L)=0.0D0
!     DO IA=1,NCF
!      DO IB=1,NCF
!       SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
!      ENDDO
!     ENDDO
!    ENDDO
!    WRITE(6,'(I3,100F10.5:)') I,(SMALLH(I,L),L=1,NTRIALS)
!   ENDDO

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|H|N>
    REWIND(50)
    DO I=1,NTRIALS
     READ(50) VEC1
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      SMALLH(I,L)=0.0D0
      DO IA=1,NCF
       DO IB=1,1
        SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
      
    ! DIAGONALIZE SUBSPACE HAMILTONIAN
    IF (NTRIALS == 1) THEN
     LAMBDA(1)=SMALLH(1,1)
     W1(1,1)=1.0D0
    ELSE
     W1=SMALLH
     CALL TRED2(W1,NTRIALS,MAXFILE,LAMBDA,W2)
     CALL TQLI(LAMBDA,W2,NTRIALS,MAXFILE,W1)
     CALL PIKSRT(NTRIALS,MAXFILE,LAMBDA,W1,W2)
    ENDIF
      
    ! FORM RESIDUAL VECTORS
    CALL PCPU_TIME(ICPUE)
    DEVMAX=0.0D0
    IF (NROOTS > 1) WRITE(6,'(A,I3)') ' ITER ',ICYCLE
    NTRIALS_NEXT=NTRIALS
    DO K=1,NROOTS
     VEC1=0.0D0
     REWIND(50)
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      VEC1=VEC1+VEC2*W1(L,K)
      READ(50) VEC2
      VEC1=VEC1-LAMBDA(K)*VEC2*W1(L,K)
     ENDDO
     DEVSQ=0.0D0
     DO IA=1,NCF
      DO IB=1,NCF
       DEVSQ=DEVSQ+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     DEVSQ=DSQRT(DEVSQ)
     IF (DEVSQ > DEVMAX) DEVMAX=DEVSQ
     ECI(K)=LAMBDA(K)+NUCLEAR_REPULSION
     IF (NROOTS == 1) THEN
      WRITE(6,'(I2,F15.10,F15.10,F20.10,F12.1)') ICYCLE,DEVSQ,ECI(K)-EHFKS,ECI(K),ICPUE-ICPUS
     ELSE
      WRITE(6,'(A,I3,F15.10,F15.5,F20.10,F12.1)') ' ROOT ',K,DEVSQ,(ECI(K)-ECI(1))*EV,ECI(K),(ICPUE-ICPUS)/DFLOAT(NROOTS)
     ENDIF
      
     IF (DEVSQ < DOPTN(67)) CYCLE

     ! FORM A NEW SUBSPACE VECTOR BY KNOWLES-HANDY SCHEME
     DO IA=1,NCF
      DO IB=1,1
       NOPEN=0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        N(I)=0
        IF (BTEST(CFHALF(IA),I-1)) N(I)=1
        IF (BTEST(CFHALF(IB),I-1)) N(I)=N(I)+1
        NOPEN=NOPEN+N(I)*(2-N(I))
       ENDDO
       IF (NOPEN == 0) THEN
        F=0.0D0
       ELSE
        F=-DFLOAT(NOPEN)/DFLOAT(NOPEN*(NOPEN-1))
       ENDIF
       D=0.0D0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        D=D+DFLOAT(N(I))*H(I,I)-DFLOAT(N(I)*(2-N(I)))*G(I,I,I,I)/4.0D0
        DO J=1,IALL(0,0,0)-IVIRTCORE
         D=D+DFLOAT(N(I)*N(J))*(2.0D0*G(I,I,J,J)-G(I,J,J,I))/4.0D0
         IF (I /= J) D=D-F*DFLOAT(N(I)*(2-N(I))*N(J)*(2-N(J)))*G(I,J,J,I)/4.0D0
        ENDDO
       ENDDO
       IF ((LAMBDA(K)-D) /= 0.0D0) VEC1(IB,IA)=VEC1(IB,IA)/(LAMBDA(K)-D)
      ENDDO
     ENDDO
      
     ! ORTHONORMALIZE THE NEW SUBSPACE VECTOR
     D=0.0D0
     DO IA=1,NCF
      DO IB=1,1
       D=D+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     D=DSQRT(D)
     VEC1=VEC1/D
     REWIND(50)
     DO L=1,NTRIALS_NEXT
      READ(50) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,1
        D=D+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
      VEC1=VEC1-D*VEC2
     ENDDO
     D=0.0D0
     DO IA=1,NCF
      DO IB=1,1
       D=D+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     D=DSQRT(D)
     VEC1=VEC1/D
     IF (D > DOPTN(67)*100.0D0) THEN
      NTRIALS_NEXT=NTRIALS_NEXT+1
      IF (NTRIALS_NEXT > MAXFILE) CALL PABORT('TOO MANY TRIAL VECTORS')
      REWIND(50)
      DO L=1,NTRIALS_NEXT-1
       READ(50) VEC2
      ENDDO
      WRITE(50) VEC1
     ENDIF

    ENDDO

    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    IF (DEVMAX < DOPTN(67)) THEN
     IF (NROOTS > 1) THEN
      WRITE(6,'(A)') '-----------------------------------------------------------------------'
     ELSE
      WRITE(6,'(A)') '----------------------------------------------------------------'
     ENDIF
     REWIND(51)
     DO I=1,NROOTS
      WRITE(6,'(A,I3,F15.10,A)') 'ROOT ',I,(ECI(I)-ECI(1))*EV,' EV'
      REWIND(50)
      VEC1=0.0D0
      DO L=1,NTRIALS
       READ(50) VEC2
       VEC1=VEC1+VEC2*W1(L,I)
      ENDDO
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,1
        D=D+VEC1(IA,IB)**2
       ENDDO
      ENDDO
      VEC1=VEC1/DSQRT(D)
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,1
        IF (NORDER(IA)+NORDER(IB) == 1) PERCENTS=PERCENTS+VEC1(IA,IB)**2
        IF (NORDER(IA)+NORDER(IB) == 2) PERCENTD=PERCENTD+VEC1(IA,IB)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES = ',PERCENTD*1.0D2
      WRITE(51) VEC1
      CALL REL_S_SQUARED(51,I-1,ORDER,S2)
      WRITE(6,'(A,F8.4)') ' < S**2 > = ',S2
      DO IA=1,NCF
       DO IB=1,1
        IF (DABS(VEC1(IA,IB)) > 0.1D0) WRITE(6,'(A,I6,I6,A,F8.4)') ' DETERMINANT (',IA,IB,' ) ',VEC1(IA,IB)
       ENDDO
      ENDDO
      IF (IOPTN(9) == 0) THEN
       WRITE(6,'(A)') 'CI WAVEFUNCTION'
       CALL DUMP5(VEC1,NCF)
      ENDIF
     ENDDO
!    REWIND(50)
!    REWIND(51)
!    DO I=1,NROOTS
!     READ(51) VEC1
!     WRITE(50) VEC1
!    ENDDO
     DEALLOCATE(VEC1,VEC2,N)
     CLOSE(50)
     CLOSE(51)
     RETURN
    ELSE IF (NTRIALS_NEXT == NTRIALS) THEN
     CALL PABORT('ALGORITHM FAILED TO INCREASE THE SUBSPACE')
    ELSE IF (NROOTS > 1) THEN
     WRITE(6,'(I3,A)') NTRIALS_NEXT-NTRIALS,' TRIAL VECTORS HAVE BEEN ADDED'
    ENDIF
    NTRIALS=NTRIALS_NEXT

   ENDDO
   CALL PABORT('DAVIDSON ALGORITHM FAILED TO CONVERGE')

END SUBROUTINE



SUBROUTINE REL_HIGHORDER_CC(ORDER,LGUESS,LDIIS,LXCC)
! PERFORM HIGH-ORDER COUPLED-CLUSTER CALCULATIONS BY DAVIDSON'S ALGORITHM.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL :: LGUESS
   LOGICAL :: LCYCLE
   LOGICAL :: LDIIS
   LOGICAL :: LXCC
   INTEGER,PARAMETER :: MAXITER=1000
   INTEGER :: IDIIS
   INTEGER :: ITER,IORDER
   INTEGER :: ORDER,IPOWER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: I,J
   INTEGER :: HOLEA(ORDER),HOLEB(ORDER),PARTA(ORDER),PARTB(ORDER)
   INTEGER :: KSIGN(0:2*MIN(IOCC,IALL(0,0,0)-IOCC-IVIRTCORE)),ISIGN,JSIGN
   INTEGER(4) :: CFALPH,CFBETA
   INTEGER :: EOF
   INTEGER :: INDX(MAXITER+1)
   REAL :: MEM,ICPUS,ICPUE
   DOUBLE COMPLEX,ALLOCATABLE :: VEC1(:,:),VEC2(:,:),VEC3(:,:)
   DOUBLE PRECISION :: DEVSQ,D
   DOUBLE PRECISION :: HA,HB
   DOUBLE PRECISION :: B(21,21),BS(21,21),C(21),CS(21)
   DOUBLE PRECISION :: XCC
   DOUBLE PRECISION :: ZEROOFENERGY

   IF (.NOT.LXCC) THEN
    WRITE(6,'(A)') 'HIGH-ORDER COUPLED-CLUSTER CALCULATIONS WILL BE PERFORMED'
   ELSE
    WRITE(6,'(A)') 'HIGH-ORDER EXPECTATION-VALUE COUPLED-CLUSTER CALCULATIONS WILL BE PERFORMED WITH THE EXISTING T-AMPLITUDES'
   ENDIF
   IF ((IOPTN(64) == 1).AND.(.NOT.LXCC)) THEN
    WRITE(6,'(A)') 'H EXP(T) ALGORITHM WILL BE USED'
   ELSE IF ((IOPTN(64) == 2).OR.(LXCC)) THEN
    IF (.NOT.LXCC) WRITE(6,'(A)') 'EXP(-T) H EXP(T) ALGORITHM WILL BE USED'
    IF (LXCC) WRITE(6,'(A)') 'EXP(T^DAGGER) H EXP(T) ALGORITHM WILL BE USED'
   ELSE
    CALL PABORT('UNKNOWN CC ALGORITHM')
   ENDIF
   IF (.NOT.LXCC) THEN
    WRITE(6,'(A,I2)') 'CC ORDER IS ',ORDER
   ELSE
    WRITE(6,'(A,I2)') 'XCC ORDER IS ',ORDER
   ENDIF
   IF ((LDIIS).AND.(.NOT.LXCC)) THEN
    IDIIS=IOPTN(54)
    WRITE(6,'(A,I3,A)') 'DIIS EXTRAPOLATION WILL BE PERFORMED ONCE IN',IDIIS,' ITERATIONS'
   ELSE
    IDIIS=1
   ENDIF
   CALL PCPU_TIME(ICPUS)
   MEM=16.0*2.0*NCF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   ALLOCATE(VEC1(1,NCF),VEC2(1,NCF),VEC3(1,NCF))
   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fi1',FORM='UNFORMATTED')
   OPEN(52,FILE=TRIM(COPTN(1))//'.fi2',FORM='UNFORMATTED')
   OPEN(53,FILE=TRIM(COPTN(1))//'.fi3',FORM='UNFORMATTED')
   OPEN(54,FILE=TRIM(COPTN(1))//'.fi4',FORM='UNFORMATTED')
   OPEN(55,FILE=TRIM(COPTN(1))//'.fi5',FORM='UNFORMATTED')
   OPEN(56,FILE=TRIM(COPTN(1))//'.fi6',FORM='UNFORMATTED')
   OPEN(57,FILE=TRIM(COPTN(1))//'.fi7',FORM='UNFORMATTED')
   OPEN(58,FILE=TRIM(COPTN(1))//'.fi8',FORM='UNFORMATTED')
   OPEN(59,FILE=TRIM(COPTN(1))//'.fi9',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fj0',FORM='UNFORMATTED')
   OPEN(61,FILE=TRIM(COPTN(1))//'.fj1',FORM='UNFORMATTED')
   OPEN(62,FILE=TRIM(COPTN(1))//'.fj2',FORM='UNFORMATTED')
   OPEN(63,FILE=TRIM(COPTN(1))//'.fj3',FORM='UNFORMATTED')
   OPEN(64,FILE=TRIM(COPTN(1))//'.fj4',FORM='UNFORMATTED')
   OPEN(65,FILE=TRIM(COPTN(1))//'.fj5',FORM='UNFORMATTED')
   OPEN(66,FILE=TRIM(COPTN(1))//'.fj6',FORM='UNFORMATTED')
   OPEN(67,FILE=TRIM(COPTN(1))//'.fj7',FORM='UNFORMATTED')
   OPEN(68,FILE=TRIM(COPTN(1))//'.fj8',FORM='UNFORMATTED')
   OPEN(69,FILE=TRIM(COPTN(1))//'.fj9',FORM='UNFORMATTED')
   OPEN(70,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')
   OPEN(71,FILE=TRIM(COPTN(1))//'.fo1',FORM='UNFORMATTED')
   OPEN(72,FILE=TRIM(COPTN(1))//'.fo2',FORM='UNFORMATTED')
   OPEN(73,FILE=TRIM(COPTN(1))//'.fo3',FORM='UNFORMATTED')
   OPEN(74,FILE=TRIM(COPTN(1))//'.fo4',FORM='UNFORMATTED')
   OPEN(75,FILE=TRIM(COPTN(1))//'.fo5',FORM='UNFORMATTED')
   OPEN(76,FILE=TRIM(COPTN(1))//'.fo6',FORM='UNFORMATTED')
   OPEN(77,FILE=TRIM(COPTN(1))//'.fo7',FORM='UNFORMATTED')
   OPEN(78,FILE=TRIM(COPTN(1))//'.fo8',FORM='UNFORMATTED')
   OPEN(79,FILE=TRIM(COPTN(1))//'.fo9',FORM='UNFORMATTED')
   OPEN(80,FILE=TRIM(COPTN(1))//'.fp0',FORM='UNFORMATTED')
   OPEN(81,FILE=TRIM(COPTN(1))//'.fp1',FORM='UNFORMATTED')
   OPEN(82,FILE=TRIM(COPTN(1))//'.fp2',FORM='UNFORMATTED')
   OPEN(83,FILE=TRIM(COPTN(1))//'.fp3',FORM='UNFORMATTED')
   OPEN(84,FILE=TRIM(COPTN(1))//'.fp4',FORM='UNFORMATTED')
   OPEN(85,FILE=TRIM(COPTN(1))//'.fp5',FORM='UNFORMATTED')
   OPEN(86,FILE=TRIM(COPTN(1))//'.fp6',FORM='UNFORMATTED')
   OPEN(87,FILE=TRIM(COPTN(1))//'.fp7',FORM='UNFORMATTED')
   OPEN(88,FILE=TRIM(COPTN(1))//'.fp8',FORM='UNFORMATTED')
   OPEN(89,FILE=TRIM(COPTN(1))//'.fp9',FORM='UNFORMATTED')
   OPEN(90,FILE=TRIM(COPTN(1))//'.fq0',FORM='UNFORMATTED')
   OPEN(91,FILE=TRIM(COPTN(1))//'.fq1',FORM='UNFORMATTED')
   OPEN(92,FILE=TRIM(COPTN(1))//'.fq2',FORM='UNFORMATTED')
   VEC1=DCMPLX(0.0D0,0.0D0)
   DO I=50,89
    REWIND(I)
    WRITE(I) VEC1
   ENDDO

   ! SIGNS ASSOCIATED WITH THE PERMUTATION OF THE CLUSTER OPERATORS
   DO I=0,MIN(IOCC,IALL(0,0,0)-IOCC-IVIRTCORE)
    KSIGN(I)=(-1)**((I*(I-1))/2)
   ENDDO

   ! COUPLED-CLUSTER ITERATION
   ! FILE 90: COUPLED-CLUSTER T AMPLITUDES
   ! FILE 91: COUPLED-CLUSTER WAVE FUNCTION EXP(T)|0>
   ! FILE 92: H EXP(T)|0>
   IF (LGUESS) THEN
    WRITE(6,'(A)') 'INITIAL GUESS FOR COUPLED-CLUSTER AMPLITUDES HAS BEEN RESTORED FROM FILE'
    REWIND(90)
    READ(90) VEC1
   ELSE
    VEC1=DCMPLX(0.0D0,0.0D0)
    REWIND(90)
    WRITE(90) VEC1
   ENDIF
   IF (.NOT.LXCC) THEN
    WRITE(6,'(A)') '-----------------------------------------------------------------'
    WRITE(6,'(A)') 'ITR     DEVIATION     CORRELATION        TOTAL ENERGY   CPU / SEC'
   ENDIF
   DO ITER=1,MAXITER
    IF (IOPTN(9) >= 2) THEN
     WRITE(6,'(A)') 'T-AMPLITUDE'
     CALL DUMP5(VEC1,NCF)
    ENDIF
    DO I=68,50,-1
     REWIND(I)
     READ(I) VEC2
     REWIND(I+1)
     WRITE(I+1) VEC2
    ENDDO
    REWIND(50)
    WRITE(50) VEC1
    
    ! XCC
    IF (LXCC) THEN

     ! FORM NUMERATOR <0|EXP(T^DAGGER) H EXP(T)|0>
     VEC2=DCMPLX(0.0D0,0.0D0)
     VEC2(1,1)=DCMPLX(1.0D0,0.0D0)
     REWIND(92)
     WRITE(92) VEC2
     DEALLOCATE(VEC1,VEC2,VEC3)
     CALL REL_EXPONENTIAL_OPERATOR(50,92,91,ORDER,.FALSE.,.FALSE.)
     CALL REL_HAMILTONIAN_PRODUCT(91,92,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))
     CALL REL_EXPONENTIAL_OPERATOR(50,92,91,ORDER,.FALSE.,.TRUE.)
     ALLOCATE(VEC1(1,NCF),VEC2(1,NCF),VEC3(1,NCF))
     REWIND(91)
     READ(91) VEC1
     XCC=VEC1(1,1)
     WRITE(6,'(A,F20.10)') 'XCC NUMERATOR =   ',XCC

     ! FORM DENOMINATOR <0|EXP(T^DAGGER) EXP(T)|0>
     VEC2=DCMPLX(0.0D0,0.0D0)
     VEC2(1,1)=DCMPLX(1.0D0,0.0D0)
     REWIND(92)
     WRITE(92) VEC2
     DEALLOCATE(VEC1,VEC2,VEC3)
     CALL REL_EXPONENTIAL_OPERATOR(50,92,91,ORDER,.FALSE.,.FALSE.)
     CALL REL_EXPONENTIAL_OPERATOR(50,91,92,ORDER,.FALSE.,.TRUE.)
     ALLOCATE(VEC1(1,NCF),VEC2(1,NCF),VEC3(1,NCF))
     REWIND(92)
     READ(92) VEC1
     D=VEC1(1,1)
     XCC=XCC/D
     WRITE(6,'(A,F20.10)') 'XCC DENOMINATOR = ',D
     WRITE(6,'(A,F20.10)') 'XCC ENERGY      = ',XCC+NUCLEAR_REPULSION

     DEALLOCATE(VEC1,VEC2,VEC3)
     CLOSE(50)
     CLOSE(51)
     CLOSE(52)
     CLOSE(53)
     CLOSE(54)
     CLOSE(55)
     CLOSE(56)
     CLOSE(57)
     CLOSE(58)
     CLOSE(59)
     CLOSE(60)
     CLOSE(61)
     CLOSE(62)
     CLOSE(63)
     CLOSE(64)
     CLOSE(65)
     CLOSE(66)
     CLOSE(67)
     CLOSE(68)
     CLOSE(69)
     CLOSE(70)
     CLOSE(71)
     CLOSE(72)
     CLOSE(73)
     CLOSE(74)
     CLOSE(75)
     CLOSE(76)
     CLOSE(77)
     CLOSE(78)
     CLOSE(79)
     CLOSE(80)
     CLOSE(81)
     CLOSE(82)
     CLOSE(83)
     CLOSE(84)
     CLOSE(85)
     CLOSE(86)
     CLOSE(87)
     CLOSE(88)
     CLOSE(89)
     CLOSE(90)
     CLOSE(91)
     CLOSE(92)
     RETURN

    ENDIF

    ! FORM EXP(T)|0>
    VEC2=DCMPLX(0.0D0,0.0D0)
    VEC2(1,1)=DCMPLX(1.0D0,0.0D0)
    REWIND(92)
    WRITE(92) VEC2
    DEALLOCATE(VEC1,VEC2,VEC3)
    CALL REL_EXPONENTIAL_OPERATOR(50,92,91,ORDER,.FALSE.,.FALSE.)
    ALLOCATE(VEC1(1,NCF),VEC2(1,NCF),VEC3(1,NCF))

    ! FORM H EXP(T)|0>
    DEALLOCATE(VEC1,VEC2,VEC3)
    CALL REL_HAMILTONIAN_PRODUCT(91,92,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))
    ALLOCATE(VEC1(1,NCF),VEC2(1,NCF),VEC3(1,NCF))

    ! FORM EXP(-T) H EXP(T)|0>
    IF (IOPTN(64) == 2) THEN
     DEALLOCATE(VEC1,VEC2,VEC3)
     CALL REL_EXPONENTIAL_OPERATOR(50,92,91,ORDER,.TRUE.,.FALSE.)
     ALLOCATE(VEC1(1,NCF),VEC2(1,NCF),VEC3(1,NCF))
    ENDIF

    ! FORM H EXP(T)|0> - E EXP(T)|0> OR EXP(-T) H EXP(T)|0> - E|0>
    REWIND(91)
    READ(91) VEC3
    REWIND(92)
    READ(92) VEC1
    IF (IOPTN(64) == 2) THEN
     VEC1=VEC3
     VEC3=DCMPLX(0.0D0,0.0D0)
     VEC3(1,1)=DCMPLX(1.0D0,0.0D0)
    ENDIF
    ECC=VEC1(1,1)
!   VEC1=VEC1/ECC
    VEC2=DCMPLX(0.0D0,0.0D0)
    DO IA=1,NCF
     DO IB=1,1
      IF (NORDER(IA)+NORDER(IB) <= ORDER) VEC2(IB,IA)=VEC1(IB,IA)-VEC3(IB,IA)*ECC
! DEBUG FOR CCD, COMMENT OUT FROM HERE ...
!     IF (NORDER(IA)+NORDER(IB) == 2) VEC2(IB,IA)=VEC1(IB,IA)-VEC3(IB,IA)*ECC
! ... TO HERE
     ENDDO
    ENDDO
    DO I=88,70,-1
     REWIND(I)
     READ(I) VEC3
     REWIND(I+1)
     WRITE(I+1) VEC3
    ENDDO
    REWIND(70)
    WRITE(70) VEC2
    DEVSQ=0.0D0
    DO IA=1,NCF
     DO IB=1,1
      DEVSQ=DEVSQ+DREAL(DCONJG(VEC2(IB,IA))*VEC2(IB,IA))
     ENDDO
    ENDDO
    DEVSQ=DSQRT(DEVSQ)
    CALL PCPU_TIME(ICPUE)
    IF (ITER == 1) ZEROOFENERGY = ECC+NUCLEAR_REPULSION-EHFKS
    WRITE(6,'(I3,F15.10,2F15.10,2F20.10,F12.1)') ITER,DEVSQ,ECC+NUCLEAR_REPULSION-EHFKS-ZEROOFENERGY, &
                                                 ECC+NUCLEAR_REPULSION,ICPUE-ICPUS
    CALL PCPU_TIME(ICPUS)
    IF (DEVSQ > 100.0D0) CALL PABORT('COUPLED-CLUSTER ITERATION FAILED TO CONVERGE')
    IF (DEVSQ < DOPTN(62)) THEN
     WRITE(6,'(A)') '-----------------------------------------------------------------'
     REWIND(90)
     READ(90) VEC3
     WRITE(6,'(A)') 'CONVERGED T-AMPLITUDES'
     DO IA=1,NCF
      DO IB=1,1
       IF (CDABS(VEC3(IB,IA)) > 0.05D0) WRITE(6,'(A,I6,A,I6,A,F10.5)') ' T(',IA,'-ALPHA ',IB,'-BETA ) = ',VEC3(IB,IA)
      ENDDO
     ENDDO
     DEALLOCATE(VEC1,VEC2,VEC3)
     CLOSE(50)
     CLOSE(51)
     CLOSE(52)
     CLOSE(53)
     CLOSE(54)
     CLOSE(55)
     CLOSE(56)
     CLOSE(57)
     CLOSE(58)
     CLOSE(59)
     CLOSE(60)
     CLOSE(61)
     CLOSE(62)
     CLOSE(63)
     CLOSE(64)
     CLOSE(65)
     CLOSE(66)
     CLOSE(67)
     CLOSE(68)
     CLOSE(69)
     CLOSE(70)
     CLOSE(71)
     CLOSE(72)
     CLOSE(73)
     CLOSE(74)
     CLOSE(75)
     CLOSE(76)
     CLOSE(77)
     CLOSE(78)
     CLOSE(79)
     CLOSE(80)
     CLOSE(81)
     CLOSE(82)
     CLOSE(83)
     CLOSE(84)
     CLOSE(85)
     CLOSE(86)
     CLOSE(87)
     CLOSE(88)
     CLOSE(89)
     CLOSE(90)
     CLOSE(91)
     CLOSE(92)
     RETURN
    ENDIF

    IF ((ITER < IDIIS).OR.(MOD(ITER,IDIIS) /= 0).OR.(.NOT.LDIIS)) THEN
     ! FORM NEW T AMPLITUDE BY SIMPLE RELAXATION
     REWIND(90)
     READ(90) VEC1
     DO IA=1,NCF
      CFALPH=CFHALF(1)
      HA=0.0D0
      ISIGN=1
      DO I=1,IOCC
       IF (.NOT.BTEST(CFHALF(IA),I-1)) THEN
        IF (I /= 1) THEN
         DO J=1,I-1
          IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
         ENDDO
        ENDIF
        CFALPH=IBCLR(CFALPH,I-1)
        HA=HA+REPSILON(I,0)
       ENDIF
      ENDDO
      DO I=IOCC+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),I-1)) THEN
        DO J=1,I-1
         IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
        ENDDO
        CFALPH=IBSET(CFALPH,I-1)
        HA=HA-REPSILON(I,0)
       ENDIF
      ENDDO
      DO IB=1,1
!      CFBETA=CFHALF(1)
       HB=0.0D0
       JSIGN=1
!      DO I=1,IOCC
!       IF (.NOT.BTEST(CFHALF(IB),I-1)) THEN
!        IF (I /= 1) THEN
!         DO J=1,I-1
!          IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
!         ENDDO
!        ENDIF
!        CFBETA=IBCLR(CFBETA,I-1)
!        HB=HB+REPSILON(I,0)
!       ENDIF
!      ENDDO
!      DO I=IOCC+1,IALL(0,0,0)-IVIRTCORE
!       IF (BTEST(CFHALF(IB),I-1)) THEN
!        DO J=1,I-1
!         IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
!        ENDDO
!        CFBETA=IBSET(CFBETA,I-1)
!        HB=HB-REPSILON(I,0)
!       ENDIF
!      ENDDO
       IF ((IA == 1).AND.(IB == 1)) THEN
        VEC1(IB,IA)=0.0D0
       ELSE
        IF (IOPTN(64) == 2) THEN
         VEC1(IB,IA)=VEC1(IB,IA)-VEC2(IB,IA)*DFLOAT(ISIGN*JSIGN*KSIGN(NORDER(IA))*KSIGN(NORDER(IB)))*DOPTN(63)
        ELSE
         VEC1(IB,IA)=VEC1(IB,IA)+VEC2(IB,IA)*DFLOAT(ISIGN*JSIGN*KSIGN(NORDER(IA))*KSIGN(NORDER(IB)))/(HA+HB)*DOPTN(63)
        ENDIF
       ENDIF
      ENDDO
     ENDDO
     REWIND(90)
     WRITE(90) VEC1
    ELSE
     IORDER=MIN(ITER,20)
     B=0.0D0
     DO I=1,IORDER
      REWIND(69+I)
      READ(69+I) VEC1
      DO J=1,IORDER
       REWIND(69+J)
       READ(69+J) VEC2
       DO IA=1,NCF
        DO IB=1,1
         B(J,I)=B(J,I)+VEC1(IB,IA)*VEC2(IB,IA)
        ENDDO
       ENDDO
      ENDDO
      B(I,IORDER+1)=-1.0D0
      B(IORDER+1,I)=-1.0D0
      C(I)=0.0D0
     ENDDO
     B(IORDER+1,IORDER+1)=0.0D0
     C(IORDER+1)=-1.0D0
     BS=B
     CS=C
!    WRITE(6,'(A)') 'PULAY MATRIX'
!    CALL DUMP5(B,21)
     CALL LUDCMP(B,IORDER+1,21,INDX,D)
     CALL LUBKSB(B,IORDER+1,21,INDX,C)
     CALL MPROVE(BS,B,IORDER+1,21,INDX,CS,C)
     WRITE(6,'(A,100F7.3:)') 'DIIS VECTOR',(C(I),I=1,IORDER+1)
     
     VEC1=0.0D0
     DO I=1,IORDER
      REWIND(49+I)
      READ(49+I) VEC2
      VEC1=VEC1+VEC2*C(I)
     ENDDO
     REWIND(90)
     WRITE(90) VEC1
    ENDIF

   ENDDO
   CALL PABORT('COUPLED-CLUSTER ITERATION FAILED TO CONVERGE')
   RETURN
END SUBROUTINE



SUBROUTINE REL_EXPONENTIAL_OPERATOR(TFILE,INFILE,OUTFILE,ORDER,LMINUS,LDAGGER)
! OPERATE WITH AN EXPONENTIAL OPERATOR ON ANY GIVEN WAVEFUNCTION.  THE T-AMPLITUDES
! ARE STORED IN TFILE, THE WAVEFUNCTION ON WHICH THE EXPONENTIAL OPERATOR ACTS IS 
! IN INFILE, AND THE EXPONENTIAL WAVEFUNCTION IS IN OUTFILE.  IF LMINUS=.TRUE.
! THE OPERATOR IS EXP(-T), OTHERWISE, EXP(T).  IF LDAGGER=.TRUE., THE OPERATOR IS
! THE CONJUGATE COMPLEX OF EXP(T), OTHERWISE, JUST EXP(T).

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL :: LDAGGER
   LOGICAL :: LMINUS
   LOGICAL :: LCYCLE
   INTEGER :: TFILE,INFILE,OUTFILE
   INTEGER :: ORDER
   INTEGER :: I,J,IPOWER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: HOLEA(ORDER),HOLEB(ORDER),PARTA(ORDER),PARTB(ORDER)
   INTEGER :: KSIGN(0:MIN(IOCC,IALL(0,0,0)-IOCC-IVIRTCORE)),ISIGN,JSIGN
   INTEGER(4) :: CFALPH,CFBETA
   DOUBLE COMPLEX,ALLOCATABLE :: VEC1(:,:),VEC2(:,:),VEC3(:,:)
   INTEGER,ALLOCATABLE :: AD1(:),AD2(:),SN1(:),SN2(:)
   LOGICAL,ALLOCATABLE :: LC1(:),LC2(:)

   ALLOCATE(VEC1(1,NCF),VEC2(1,NCF),VEC3(1,NCF))
   ALLOCATE(AD1(NCF),AD2(NCF),SN1(NCF),SN2(NCF),LC1(NCF),LC2(NCF))

   ! SIGNS ASSOCIATED WITH THE PERMUTATION OF THE CLUSTER OPERATORS
   DO I=0,MIN(IOCC,IALL(0,0,0)-IOCC-IVIRTCORE)
    KSIGN(I)=(-1)**((I*(I-1))/2)
   ENDDO

   ! RETRIEVE T-AMPLITUDES FROM FILE
   REWIND(TFILE)
   READ(TFILE) VEC1
   IF (LMINUS) VEC1=-VEC1
   ! RETRIEVE INITIAL WAVEFUNCTION FROM FILE
   REWIND(INFILE)
   READ(INFILE) VEC2
   ! INITIALIZE OUTFILE WITH THE INITIAL WAVEFUNCTION
   REWIND(OUTFILE)
   WRITE(OUTFILE) VEC2

   ! LOOP OVER THE POWER
   DO IPOWER=1,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)
    VEC3=DCMPLX(0.0D0,0.0D0)

    ! LOOP OVER ALPHA T-AMPLITUDE
    DO IA=1,NCF
     IF (NORDER(IA) > ORDER) CYCLE
     J=0
     DO I=1,IOCC
      IF (.NOT.BTEST(CFHALF(IA),I-1)) THEN
       J=J+1
       HOLEA(J)=I
      ENDIF
     ENDDO
     J=0
     DO I=IOCC+1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFHALF(IA),I-1)) THEN
       J=J+1
       PARTA(J)=I
      ENDIF
     ENDDO

     ! LOOP OVER ALPHA CONFIGURATIONS
     DO IC=1,NCF
      LCYCLE=.FALSE.
      CFALPH=CFHALF(IC)
      IF (.NOT.LDAGGER) THEN
       DO I=1,NORDER(IA)
        IF (.NOT.BTEST(CFALPH,HOLEA(I)-1)) LCYCLE=.TRUE.
        IF (BTEST(CFALPH,PARTA(I)-1)) LCYCLE=.TRUE.
       ENDDO
      ELSE
       DO I=1,NORDER(IA)
        IF (BTEST(CFALPH,HOLEA(I)-1)) LCYCLE=.TRUE.
        IF (.NOT.BTEST(CFALPH,PARTA(I)-1)) LCYCLE=.TRUE.
       ENDDO
      ENDIF
      LC1(IC)=LCYCLE
      IF (LCYCLE) CYCLE
      ISIGN=1
      IF (.NOT.LDAGGER) THEN
       DO I=1,NORDER(IA)
        IF (HOLEA(I) /= 1) THEN
         DO J=1,HOLEA(I)-1
          IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
         ENDDO
        ENDIF
        CFALPH=IBCLR(CFALPH,HOLEA(I)-1)
       ENDDO
       DO I=1,NORDER(IA)
        DO J=1,PARTA(I)-1
         IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
        ENDDO
        CFALPH=IBSET(CFALPH,PARTA(I)-1)
       ENDDO
      ELSE
       DO I=NORDER(IA),1,-1
        DO J=1,PARTA(I)-1
         IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
        ENDDO
        CFALPH=IBCLR(CFALPH,PARTA(I)-1)
       ENDDO
       DO I=NORDER(IA),1,-1
        IF (HOLEA(I) /= 1) THEN
         DO J=1,HOLEA(I)-1
          IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
         ENDDO
        ENDIF
        CFALPH=IBSET(CFALPH,HOLEA(I)-1)
       ENDDO
      ENDIF
      AD1(IC)=ADDRSS(CFALPH)
      SN1(IC)=ISIGN*KSIGN(NORDER(IA))
     ENDDO

     ! LOOP OVER BETA T-AMPLITUDE
     DO IB=1,1
      IF (NORDER(IA)+NORDER(IB) > ORDER) CYCLE
      IF (CDABS(VEC1(IB,IA)) < 1.0D-15) CYCLE
!     J=0
!     DO I=1,IOCC
!      IF (.NOT.BTEST(CFHALF(IB),I-1)) THEN
!       J=J+1
!       HOLEB(J)=I
!      ENDIF
!     ENDDO
!     J=0
!     DO I=IOCC+1,IALL(0,0,0)-IVIRTCORE
!      IF (BTEST(CFHALF(IB),I-1)) THEN
!       J=J+1
!       PARTB(J)=I
!      ENDIF
!     ENDDO

!     ! LOOP OVER BETA CONFIGURATIONS
!     DO ID=1,1
!      LCYCLE=.FALSE.
!      CFBETA=CFHALF(ID)
!      IF (.NOT.LDAGGER) THEN
!       DO I=1,NORDER(IB)
!        IF (.NOT.BTEST(CFBETA,HOLEB(I)-1)) LCYCLE=.TRUE.
!        IF (BTEST(CFBETA,PARTB(I)-1)) LCYCLE=.TRUE.
!       ENDDO
!      ELSE
!       DO I=1,NORDER(IB)
!        IF (BTEST(CFBETA,HOLEB(I)-1)) LCYCLE=.TRUE.
!        IF (.NOT.BTEST(CFBETA,PARTB(I)-1)) LCYCLE=.TRUE.
!       ENDDO
!      ENDIF
!      LC2(ID)=LCYCLE
!      IF (LCYCLE) CYCLE
!      JSIGN=1
!      IF (.NOT.LDAGGER) THEN
!       DO I=1,NORDER(IB)
!        IF (HOLEB(I) /= 1) THEN
!         DO J=1,HOLEB(I)-1
!          IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
!         ENDDO
!        ENDIF
!        CFBETA=IBCLR(CFBETA,HOLEB(I)-1)
!       ENDDO
!       DO I=1,NORDER(IB)
!        DO J=1,PARTB(I)-1
!         IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
!        ENDDO
!        CFBETA=IBSET(CFBETA,PARTB(I)-1)
!       ENDDO
!      ELSE
!       DO I=NORDER(IB),1,-1
!        DO J=1,PARTB(I)-1
!         IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
!        ENDDO
!        CFBETA=IBCLR(CFBETA,PARTB(I)-1)
!       ENDDO
!       DO I=NORDER(IB),1,-1
!        IF (HOLEB(I) /= 1) THEN
!         DO J=1,HOLEB(I)-1
!          IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
!         ENDDO
!        ENDIF
!        CFBETA=IBSET(CFBETA,HOLEB(I)-1)
!       ENDDO
!      ENDIF
!      AD2(ID)=ADDRSS(CFBETA)
!      SN2(ID)=JSIGN*KSIGN(NORDER(IB))
!     ENDDO

      ! LOOP OVER ALPHA CONFIGURATIONS
      DO IC=1,NCF
       IF (LC1(IC)) CYCLE
       ! LOOP OVER BETA CONFIGURATIONS
!      DO ID=1,1
!       IF (LC2(ID)) CYCLE
        IF (CDABS(VEC2(1,IC)) < 1.0D-15) CYCLE
        VEC3(1,AD1(IC))=VEC3(1,AD1(IC))+DFLOAT(SN1(IC))*VEC1(1,IA)*VEC2(1,IC)
!      ENDDO
      ENDDO

     ENDDO
    ENDDO
    ! AT THIS POINT, VEC3 CONTAINS T TO THE POWER OF IPOWER.  VEC3 IS COPIED TO VEC2 FOR NEXT ITERATION,
    ! AND VEC3 IS ADDED TO THE VECTOR STORED IN 91.
    VEC3=VEC3/DFLOAT(IPOWER)
    REWIND(OUTFILE)
    READ(OUTFILE) VEC2
    VEC2=VEC2+VEC3
    REWIND(OUTFILE)
    WRITE(OUTFILE) VEC2
    VEC2=VEC3
   ENDDO
   
   DEALLOCATE(VEC1,VEC2,VEC3)
   DEALLOCATE(AD1,AD2,SN1,SN2,LC1,LC2)

   RETURN
END SUBROUTINE



SUBROUTINE REL_FULL_EFF_H(TORDER,RORDER)
! FORM FULL EFFECTIVE HAMILTONIAN EXP(-T)HEXP(T) AND DIAGONALIZE IT BY LINPACK/LAPACK/BLAS SUBROUTINES.
! CAUTION, DO NOT USE THIS FOR PRODUCTION RUN.  THE ORDER OF CLUSTER EXPANSION SHOULD BE GIVEN BY TORDER
! AND THE CORRESPONDING T-AMPLITUDES MUST BE PROVIDED IN FILE 90.  THE ORDER OF LINEAR OPERATOR SHOULD BE
! GIVEN BY RORDER.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL,PARAMETER :: LEVEC = .TRUE.
   INTEGER :: RORDER,TORDER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: INFO
   REAL :: MEM,DEV
   DOUBLE PRECISION,ALLOCATABLE :: HAM(:,:),VL(:,:),VR(:,:),ER(:),EI(:),WK(:)
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:)

   WRITE(6,'(A)') 'EQUATION-OF-MOTION COUPLED CLUSTER CALCULATION FOR ALL STATES'
   WRITE(6,'(I2,A)') TORDER,'-ORDER COUPLED CLUSTER SIMILARITY TRANSFORMATION'
   WRITE(6,'(I2,A)') RORDER,'-ORDER LINEAR EXCITATION OPERATOR'
   IF (LEVEC) THEN
    MEM=16.0*(3.0D0*NCF**4+7.0*NCF**2)
   ELSE
    MEM=16.0*(NCF**4+9.0*NCF**2)
   ENDIF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   ALLOCATE(HAM(NCF,NCF),ER(NCF),EI(NCF),WK(4*NCF))
   IF (LEVEC) THEN
    ALLOCATE(VR(NCF,NCF),VL(NCF,NCF))
   ELSE
    ALLOCATE(VR(1,NCF),VL(1,NCF))
   ENDIF
   ALLOCATE(TRL(1,NCF))

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')
   OPEN(90,FILE=TRIM(COPTN(1))//'.fq0',FORM='UNFORMATTED')

   ! FORM HAMILTONIAN AND KEEP IT IN MEMORY
   HAM=0.0D0
   DO IA=1,NCF
    DO IB=1,1
     TRL=0.0D0
     IF (NORDER(IA)+NORDER(IB) <= RORDER) TRL(IB,IA)=1.0D0
     ! |B>=EXP(T)|A>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_EXPONENTIAL_OPERATOR(90,50,60,TORDER,.FALSE.,.FALSE.)
     REWIND(60)
     READ(60) TRL
     ! |C>=H|B>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_HAMILTONIAN_PRODUCT(50,60,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))
     REWIND(60)
     READ(60) TRL
     ! |D>=EXP(-T)|C>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_EXPONENTIAL_OPERATOR(90,50,60,TORDER,.TRUE.,.FALSE.)
     REWIND(60)
     READ(60) TRL
     DO IC=1,NCF
      DO ID=1,1
       HAM((IC-1)*NCF+ID,(IA-1)*NCF+IB)=TRL(ID,IC)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   IF (NCF <= 49) CALL DUMP5(HAM,NCF)

   ! CHECK IF THE TRANSFORMED HAMILTONIAN HAS ZERO FIRST ROW
   DEV=0.0D0
   DO IA=1,NCF
    DO IB=1,1
     IF ((IA == 1).AND.(IB == 1)) CYCLE
     IF (NORDER(IA)+NORDER(IB) > TORDER) CYCLE
     DEV=DEV+HAM((IA-1)*NCF+IB,1)**2
    ENDDO
   ENDDO
   IF (DEV > 1.0E-5) THEN
    CALL WARNING('THE FIRST COLUMN IN THE H BAR DEVIATES FROM ZERO')
    WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    CALL DUMP5(HAM,NCF)
   ENDIF

   DEALLOCATE(TRL)
   CLOSE(50)
   CLOSE(60)
   CLOSE(90)

   ! DIAGONALIZE HAMILTONIAN
   IF (LEVEC) THEN
    CALL DGEEV('V','V',NCF,HAM,NCF,ER,EI,VL,NCF,VR,NCF,WK,4*NCF,INFO)
!   CALL DUMP5(VR,NCF)
!   CALL DUMP5(VL,NCF)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    EI=ER
    CALL PIKSRT(NCF,NCF,ER,VR,WK)
    CALL PIKSRT(NCF,NCF,EI,VL,WK)
    DO IA=1,MIN(10,NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
     WRITE(6,'(A)') '             RIGHT-HAND VECTOR    LEFT-HAND VECTOR'
     DO IB=1,NCF
      WRITE(6,'(I10,2F20.15)') IB,VR(IB,IA),VL(IB,IA)
     ENDDO
    ENDDO
    ! BIORTHOGONALITY CHECK
    DO IA=1,NCF
     DO IB=1,NCF
      HAM(IB,IA)=0.0D0
      DO IC=1,NCF
       HAM(IB,IA)=HAM(IB,IA)+VR(IC,IB)*VL(IC,IA)
      ENDDO
     ENDDO
    ENDDO
    CALL DUMP5(HAM,NCF)
    WRITE(6,'(A)') 'DIAGONALS'
    DO IA=1,NCF
     WRITE(6,'(F20.15)') HAM(IA,IA)
    ENDDO
    DEV=0.0D0
    DO IA=1,(NCF)-1
     DO IB=IA+1,NCF
      DEV=DEV+HAM(IB,IA)**2
     ENDDO
    ENDDO
    WRITE(6,'(A)') 'OFF DIAGONALS'
    WRITE(6,'(F20.15)') DEV
   ELSE
    CALL DGEEV('N','N',NCF,HAM,NCF,ER,EI,VL,1,VR,1,WK,4*NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT_EVALONLY(NCF,ER)
    DO IA=1,MIN(25,NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
    ENDDO
   ENDIF
   CALL PFLUSH(6)

   DEALLOCATE(HAM,ER,EI,VL,VR,WK)

   RETURN
END SUBROUTINE



SUBROUTINE REL_EOMEECC(TORDER,RORDER,NROOTS,NTRIALS,LLEFT)
! PERFORM HIGH-ORDER EQUATION-OF-MOTION COUPLED CLUSTER CALCULATIONS BY HIRAO-NAKATSUJI ALGORITHM.
! K.HIRAO & H.NAKATSUJI,J.COMPUT.PHYS.45,246(1982).
! IF LLEFT=.TRUE., LEFT-HAND EIGENVECTORS WILL BE SOUGHT INSTEAD OF RIGHT-HAND EIGENVECTORS.

   USE CONSTANTS
   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL :: LLEFT
   INTEGER,PARAMETER :: MAXFILE = 1000
   INTEGER,PARAMETER :: MAXCYCLE = 1000
   INTEGER :: ICYCLE
   INTEGER :: TORDER
   INTEGER :: RORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: NTRIALS_NEXT
   INTEGER :: IA,IB
   INTEGER :: I,J,K,L,NOPEN
   INTEGER :: INFO
   INTEGER,ALLOCATABLE :: N(:)
   REAL :: MEM,ICPUS,ICPUE
   LOGICAL :: LDONE(MAXFILE)
   DOUBLE PRECISION :: DEVSQ,DEVMAX,D,F,S2
   DOUBLE PRECISION :: SMALLH(MAXFILE,MAXFILE),EEOMCC(MAXFILE)
   DOUBLE PRECISION :: VR(MAXFILE,MAXFILE),VL(1,MAXFILE),ER(MAXFILE),EI(MAXFILE),WK(4*MAXFILE)
   DOUBLE PRECISION :: PERCENTS,PERCENTD
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:)

   CALL PCPU_TIME(ICPUS)
   WRITE(6,'(A)') 'HIGH-ORDER EQUATION-OF-MOTION COUPLED CLUSTER CALCULATIONS WILL BE PERFORMED'
   IF (.NOT.LLEFT) THEN
    WRITE(6,'(A)') 'RIGHT-HAND EIGENVECTORS WILL BE SOUGHT'
   ELSE
    WRITE(6,'(A)') 'LEFT-HAND EIGENVECTORS WILL BE SOUGHT'
   ENDIF
   WRITE(6,'(A,I2)') 'THE ORDER OF COUPLED CLUSTER            = ',TORDER
   WRITE(6,'(A,I2)') 'THE ORDER OF LINEAR EXCITATION OPERATOR = ',RORDER
   WRITE(6,'(A,I4)') 'THE NUMBER OF EOMCC ROOTS SOUGHT ',NROOTS
   WRITE(6,'(A,I4)') 'THE NUMBER OF INITIAL TRIAL VECTORS ',NTRIALS
   MEM=16.0*2.0*NCF**2
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   WRITE(6,'(A)') '-----------------------------------------------------------------------'
   WRITE(6,'(A)') '             DEVIATION        OMEGA / EV       TOTAL ENERGY   CPU / SEC'
   ALLOCATE(VEC1(NCF,NCF),VEC2(NCF,NCF),N(IALLMAX-IVIRTCORE))
   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fw0',FORM='UNFORMATTED')
   OPEN(61,FILE=TRIM(COPTN(1))//'.fw1',FORM='UNFORMATTED')
   OPEN(90,FILE=TRIM(COPTN(1))//'.fq0',FORM='UNFORMATTED')

   ! INITIALIZE
   LDONE=.FALSE.
   IF (NTRIALS > MAXFILE) CALL PABORT('TOO MANY INITIAL TRIAL VECTORS')

   ! HIRAO-NAKATSUJI ITERATION
   DO ICYCLE=1,MAXCYCLE

    ! FORM EXP(-T) H EXP(T)|A> AND STORE THEM IN FILE 51
    REWIND(50)
    REWIND(51)
    DO I=1,NTRIALS
     READ(50) VEC1 ! RETRIEVE A TRIAL VECTOR
     IF (.NOT.LDONE(I)) THEN
      ! |B>=EXP(T)|A>
      REWIND(60)
      WRITE(60) VEC1
      DEALLOCATE(VEC1,VEC2)
      IF (.NOT.LLEFT) THEN
       CALL REL_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.FALSE.,.FALSE.)
      ELSE
       CALL REL_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.TRUE.,.TRUE.)
      ENDIF
      ALLOCATE(VEC1(NCF,NCF),VEC2(NCF,NCF))
      REWIND(61)
      READ(61) VEC1
      ! |C>=H|B>
      REWIND(60)
      WRITE(60) VEC1
      DEALLOCATE(VEC1,VEC2)
      CALL REL_HAMILTONIAN_PRODUCT(60,61,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE))
      ALLOCATE(VEC1(NCF,NCF),VEC2(NCF,NCF))
      REWIND(61)
      READ(61) VEC1
      ! |D>=EXP(-T)|C>
      REWIND(60)
      WRITE(60) VEC1
      DEALLOCATE(VEC1,VEC2)
      IF (.NOT.LLEFT) THEN
       CALL REL_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.TRUE.,.FALSE.)
      ELSE
       CALL REL_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.FALSE.,.TRUE.)
      ENDIF
      ALLOCATE(VEC1(NCF,NCF),VEC2(NCF,NCF))
      REWIND(61)
      READ(61) VEC1
      WRITE(51) VEC1
      LDONE(I)=.TRUE.
     ELSE
      READ(51) VEC2 ! DUMMY READING
     ENDIF
    ENDDO

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|N> FOR DEBUG
!   DO I=1,NTRIALS
!    REWIND(50)
!    DO J=1,I
!     READ(50) VEC1
!    ENDDO
!    REWIND(50)
!    DO L=1,NTRIALS
!     READ(50) VEC2
!     SMALLH(I,L)=0.0D0
!     DO IA=1,NCF
!      DO IB=1,NCF
!       SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
!      ENDDO
!     ENDDO
!    ENDDO
!   ENDDO
!   CALL DUMP10(SMALLH,NTRIALS,MAXFILE)

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|H|N>
    REWIND(50)
    DO I=1,NTRIALS
     READ(50) VEC1
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      SMALLH(I,L)=0.0D0
      DO IA=1,NCF
       DO IB=1,NCF
        SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
!   CALL DUMP10(SMALLH,NTRIALS,MAXFILE)
      
    ! DIAGONALIZE SUBSPACE HAMILTONIAN
    IF (NTRIALS == 1) THEN
     ER(1)=SMALLH(1,1)
     VR(1,1)=1.0D0
    ELSE
     CALL DGEEV('N','V',NTRIALS,SMALLH,MAXFILE,ER,EI,VL,1,VR,MAXFILE,WK,4*MAXFILE,INFO)
     IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
     CALL PIKSRT(NTRIALS,MAXFILE,ER,VR,EI)
    ENDIF
!   DO I=1,NTRIALS
!    WRITE(6,'(A,I2,A,F20.15)') 'ROOT ',I,' = ',ER(I)+NUCLEAR_REPULSION
!   ENDDO
      
    ! FORM RESIDUAL VECTORS
    CALL PCPU_TIME(ICPUE)
    DEVMAX=0.0D0
    WRITE(6,'(A,I3)') ' ITER ',ICYCLE
    NTRIALS_NEXT=NTRIALS
    DO K=1,NROOTS
     VEC1=0.0D0
     REWIND(50)
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      VEC1=VEC1+VEC2*VR(L,K)
      READ(50) VEC2
      VEC1=VEC1-ER(K)*VEC2*VR(L,K)
     ENDDO
     DEVSQ=0.0D0
     DO IA=1,NCF
      DO IB=1,NCF
       IF (NORDER(IA)+NORDER(IB) > RORDER) VEC1(IB,IA)=0.0D0
       DEVSQ=DEVSQ+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     DEVSQ=DSQRT(DEVSQ)
     IF (DEVSQ > DEVMAX) DEVMAX=DEVSQ
     EEOMCC(K)=ER(K)+NUCLEAR_REPULSION
     WRITE(6,'(A,I3,F15.10,F15.5,F20.10,F12.1)') ' ROOT ',K,DEVSQ,(EEOMCC(K)-EEOMCC(1))*EV,EEOMCC(K),(ICPUE-ICPUS)/DFLOAT(NROOTS)

     IF (DEVSQ < DOPTN(67)) CYCLE

     ! FORM A NEW SUBSPACE VECTOR BY HIRAO-NAKATSUJI SCHEME
     DO IA=1,NCF
      DO IB=1,NCF
       NOPEN=0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        N(I)=0
        IF (BTEST(CFHALF(IA),I-1)) N(I)=1
        IF (BTEST(CFHALF(IB),I-1)) N(I)=N(I)+1
        NOPEN=NOPEN+N(I)*(2-N(I))
       ENDDO
       IF (NOPEN == 0) THEN
        F=0.0D0
       ELSE
        F=-DFLOAT(NOPEN)/DFLOAT(NOPEN*(NOPEN-1))
       ENDIF
       D=0.0D0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        D=D+DFLOAT(N(I))*H(I,I)-DFLOAT(N(I)*(2-N(I)))*G(I,I,I,I)/4.0D0
        DO J=1,IALL(0,0,0)-IVIRTCORE
         D=D+DFLOAT(N(I)*N(J))*(2.0D0*G(I,I,J,J)-G(I,J,J,I))/4.0D0
         IF (I /= J) D=D-F*DFLOAT(N(I)*(2-N(I))*N(J)*(2-N(J)))*G(I,J,J,I)/4.0D0
        ENDDO
       ENDDO
       IF ((ER(K)-D) /= 0.0D0) VEC1(IB,IA)=VEC1(IB,IA)/(ER(K)-D)
      ENDDO
     ENDDO
      
     ! ORTHONORMALIZE THE NEW SUBSPACE VECTOR
     D=0.0D0
     DO IA=1,NCF
      DO IB=1,NCF
       D=D+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     D=DSQRT(D)
     VEC1=VEC1/D
     REWIND(50)
     DO L=1,NTRIALS_NEXT
      READ(50) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,NCF
        D=D+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
      VEC1=VEC1-D*VEC2
     ENDDO
     D=0.0D0
     DO IA=1,NCF
      DO IB=1,NCF
       D=D+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     D=DSQRT(D)
     VEC1=VEC1/D
     IF (D > DOPTN(67)*100.0D0) THEN
      NTRIALS_NEXT=NTRIALS_NEXT+1
      IF (NTRIALS_NEXT > MAXFILE) CALL PABORT('TOO MANY TRIAL VECTORS')
      REWIND(50)
      DO L=1,NTRIALS_NEXT-1
       READ(50) VEC2
      ENDDO
      WRITE(50) VEC1
     ENDIF

    ENDDO

    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    IF (DEVMAX < DOPTN(67)) THEN
     WRITE(6,'(A)') '-----------------------------------------------------------------------'
     IF ((IOPTN(66) > 0).AND.(IOPTN(66) <= NROOTS)) THEN
      N_DEGENERATE_ROOTS=0
      DO I=1,NROOTS
       IF (DABS(EEOMCC(IOPTN(66))-EEOMCC(I)) < 1.0D-5) THEN
        N_DEGENERATE_ROOTS=N_DEGENERATE_ROOTS+1
        IF (N_DEGENERATE_ROOTS > 10) CALL PABORT('TOO MANY DEGENERACIES')
        DEGENERATE_ROOTS(N_DEGENERATE_ROOTS)=I
       ENDIF
      ENDDO
      IOPTN(66)=DEGENERATE_ROOTS(1)
      IF (N_DEGENERATE_ROOTS > 1) WRITE(6,'(A,I3,A,A,A)') '***** WARNING : ROOT ',IOPTN(66),' IS ',CNUMBER(N_DEGENERATE_ROOTS),&
      '-FOLD DEGENERATE'
     ENDIF
      
     IF (LLEFT) THEN
      OPEN(70,FILE=TRIM(COPTN(1))//'.lft',FORM='UNFORMATTED')
      REWIND(70)
     ELSE
      OPEN(71,FILE=TRIM(COPTN(1))//'.rgt',FORM='UNFORMATTED')
      REWIND(71)
     ENDIF
     DO I=1,NROOTS
      WRITE(6,'(A,I3,F15.10,A)') 'ROOT ',I,(EEOMCC(I)-EEOMCC(1))*EV,' EV'
      REWIND(50)
      VEC1=0.0D0
      DO L=1,NTRIALS
       READ(50) VEC2
       VEC1=VEC1+VEC2*VR(L,I)
      ENDDO
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,NCF
        D=D+VEC1(IA,IB)**2
       ENDDO
      ENDDO
      VEC1=VEC1/DSQRT(D)
      IF ((IOPTN(66) > 0).AND.(IOPTN(66) <= NROOTS)) THEN
       IF (LLEFT) THEN
        DO J=1,N_DEGENERATE_ROOTS
         IF (I == DEGENERATE_ROOTS(J)) THEN
          WRITE(6,'(A,I3,A)') 'LEFT-HAND EIGENVECTOR OF ROOT ',I,' HAS BEEN STORED'
          WRITE(70) VEC1
         ENDIF
        ENDDO
       ELSE
        DO J=1,N_DEGENERATE_ROOTS
         IF (I == DEGENERATE_ROOTS(J)) THEN
          WRITE(6,'(A,I3,A)') 'RIGHT-HAND EIGENVECTOR OF ROOT ',I,' HAS BEEN STORED'
          WRITE(71) VEC1
         ENDIF
        ENDDO
       ENDIF
      ENDIF
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,NCF
        IF (NORDER(IA)+NORDER(IB) == 1) PERCENTS=PERCENTS+VEC1(IA,IB)**2
        IF (NORDER(IA)+NORDER(IB) == 2) PERCENTD=PERCENTD+VEC1(IA,IB)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES (CC) = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES (CC) = ',PERCENTD*1.0D2
      REWIND(60)
      WRITE(60) VEC1
      DEALLOCATE(VEC1,VEC2)
      CALL REL_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.FALSE.,.FALSE.)
      ALLOCATE(VEC1(NCF,NCF),VEC2(NCF,NCF))
      CALL REL_S_SQUARED(61,0,2*MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE),S2)
      WRITE(6,'(A,F8.4)') ' < S**2 > = ',S2
      REWIND(61)
      READ(61) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,NCF
        D=D+VEC2(IA,IB)**2
       ENDDO
      ENDDO
      VEC2=VEC2/DSQRT(D)
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,NCF
        IF (NORDER(IA)+NORDER(IB) == 1) PERCENTS=PERCENTS+VEC2(IA,IB)**2
        IF (NORDER(IA)+NORDER(IB) == 2) PERCENTD=PERCENTD+VEC2(IA,IB)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES (CI) = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES (CI) = ',PERCENTD*1.0D2
      DO IA=1,NCF
       DO IB=1,NCF
        IF (DABS(VEC2(IA,IB)) > 0.1D0) WRITE(6,'(A,I6,I6,A,F8.4)') ' EFFFECTIVE DETERMINANT (',IA,IB,' ) ',VEC2(IA,IB)
       ENDDO
      ENDDO
     ENDDO
!    REWIND(50)
!    REWIND(51)
!    DO I=1,NROOTS
!     READ(51) VEC1
!     WRITE(50) VEC1
!    ENDDO
     DEALLOCATE(VEC1,VEC2,N)
     IF (LLEFT) THEN
      CLOSE(70)
     ELSE
      CLOSE(71)
     ENDIF
     CLOSE(50)
     CLOSE(51)
     CLOSE(60)
     CLOSE(61)
     CLOSE(90)
     RETURN
    ELSE IF (NTRIALS_NEXT == NTRIALS) THEN
     CALL PABORT('ALGORITHM FAILED TO INCREASE THE SUBSPACE')
    ELSE IF (NROOTS > 1) THEN
     WRITE(6,'(I3,A)') NTRIALS_NEXT-NTRIALS,' TRIAL VECTORS HAVE BEEN ADDED'
    ENDIF
    NTRIALS=NTRIALS_NEXT

   ENDDO
   CALL PABORT('HIRAO-NAKATSUJI ALGORITHM FAILED TO CONVERGE')

END SUBROUTINE



SUBROUTINE REL_S_SQUARED(INFILE,OFFSET,ORDER,S2)
! OPERATE WITH S**2 = S+ S- - SZ + SZ**2 A INPUT VECTOR IN INFILE
! AND INTEGRATE WITH ITSELF TO GET AN EXPECTATION VALUE OF S**2.  
! THE ORDER LIMITS THE NUMBER EXCITATION IN THE CONFIGURATIONS CONSIDERED.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: INFILE,OFFSET
   INTEGER :: ORDER
   INTEGER :: ISIGN,JSIGN
   INTEGER :: I,J,K
   INTEGER :: IA,IB,IC,ID
   INTEGER(4) :: CFA0,CFB0,CFA1,CFB1,CFA2,CFB2
   REAL :: MEM
   DOUBLE PRECISION :: S2,NORM
   DOUBLE PRECISION,ALLOCATABLE :: INP(:,:),OUT(:,:)

!  CALL PCPU_TIME(ICPUS)
   MEM=16.0*2.0*NCF**2+4.0*2.0*NCF*(IALL(0,0,0)-IVIRTCORE)**2
!  IF (MEM > 1000000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
!  ELSE IF (MEM > 1000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
!  ELSE
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
!  ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 

   ALLOCATE(INP(NCF,NCF),OUT(NCF,NCF))

   ! READ INPUT VECTOR FROM FILE INFILE
   REWIND(INFILE)
   DO I=0,OFFSET
    READ(INFILE) INP
   ENDDO

   ! ZERO SCRATCH INPUT VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   NORM=0.0D0
   DO IA=1,NCF
    DO IB=1,NCF
     IF (NORDER(IA)+NORDER(IB) > ORDER) INP(IA,IB)=0.0D0
     NORM=NORM+INP(IA,IB)**2
    ENDDO
   ENDDO

   ! ZERO SCRATCH OUTPUT VECTOR
   OUT=0.0D0

   ! S+ S-
   DO IA=1,NCF
    DO IB=1,NCF
     CFA0=CFHALF(IA)
     CFB0=CFHALF(IB)
     ! OPERATE WITH S-
     DO I=1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFA0,I-1).AND.(.NOT.BTEST(CFB0,I-1))) THEN
       CFA1=IBCLR(CFA0,I-1)
       CFB1=IBSET(CFB0,I-1)
       ISIGN=1
       DO J=1,I
        IF (BTEST(CFA0,J-1)) ISIGN=-ISIGN
        IF (BTEST(CFB1,J-1)) ISIGN=-ISIGN
       ENDDO
       ! OPERATE WITH S+
       DO J=1,IALL(0,0,0)-IVIRTCORE
        IF ((.NOT.BTEST(CFA1,J-1)).AND.BTEST(CFB1,J-1)) THEN
         CFA2=IBSET(CFA1,J-1)
         CFB2=IBCLR(CFB1,J-1)
         JSIGN=1
         DO K=1,J
          IF (BTEST(CFA2,K-1)) JSIGN=-JSIGN
          IF (BTEST(CFB1,K-1)) JSIGN=-JSIGN
         ENDDO
         IC=ADDRSS(CFA2)
         ID=ADDRSS(CFB2)
         OUT(IC,ID)=OUT(IC,ID)+DFLOAT(ISIGN*JSIGN)*INP(IA,IB)
        ENDIF
       ENDDO
      ENDIF
     ENDDO
    ENDDO
   ENDDO

   S2=0.0D0
   DO IA=1,NCF
    DO IB=1,NCF
     IF (NORDER(IA)+NORDER(IB) > ORDER) CYCLE
     S2=S2+INP(IA,IB)*OUT(IA,IB)/NORM
    ENDDO
   ENDDO

   DEALLOCATE(INP,OUT)

   RETURN
END SUBROUTINE



SUBROUTINE REL_HAMILTONIAN_P_DEBUG(INFILE,OUTFILE,OFFSET,ORDER)
! FORM THE PRODUCT OF HAMILTONIAN MATRIX AND A TRIAL VECTOR IN INFILE
! AND STORE THE PRODUCT VECTOR IN OUTFILE.  THE ORDER LIMITS THE NUMBER
! EXCITATION IN THE CONFIGURATIONS CONSIDERED.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: INFILE,OUTFILE,OFFSET
   INTEGER :: ORDER
   INTEGER :: ISIGN,JSIGN
   INTEGER :: I,J,K,L,M
   INTEGER :: IA,IB,IC,ID
   INTEGER :: NIA,NIB,NJA,NJB
   INTEGER(4) :: CFONE,CFTWO
   REAL :: MEM,ICPUS,ICPUE,EST
   DOUBLE PRECISION :: X,Y
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:),PRD(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: GG(:,:,:,:)
   INTEGER,ALLOCATABLE :: PSIGN(:,:,:),PADRS(:,:,:)

!  CALL PCPU_TIME(ICPUS)
   MEM=16.0*2.0*NCF**2+4.0*2.0*NCF*(IALL(0,0,0)-IVIRTCORE)**2
!  IF (MEM > 1000000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
!  ELSE IF (MEM > 1000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
!  ELSE
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
!  ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 

   ALLOCATE(TRL(NCF,NCF),PRD(NCF,NCF),PSIGN(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,NCF),PADRS(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,NCF))

   ALLOCATE(GG(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE))
   GG = G
   DO I = IOCC+1,IALL(0,0,0)-IVIRTCORE
   DO J = ICORE+1,IOCC
   DO K = IOCC+1,IALL(0,0,0)-IVIRTCORE
   DO L = ICORE+1,IOCC
    GG(I,J,K,L) = G(I,J,K,L) / (REPSILON(J,0)+REPSILON(L,0)-REPSILON(I,0)-REPSILON(K,0))
    GG(J,I,L,K) = G(J,I,L,K) / (REPSILON(J,0)+REPSILON(L,0)-REPSILON(I,0)-REPSILON(K,0))
   ENDDO
   ENDDO
   ENDDO
   ENDDO

   ! READ TRIAL VECTOR FROM FILE INFILE
   REWIND(INFILE)
   DO I=0,OFFSET
    READ(INFILE) TRL
   ENDDO

   ! ZERO SCRATCH TRIAL VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   DO IA=1,NCF
    DO IB=1,NCF
     IF (NORDER(IA)+NORDER(IB) > ORDER) TRL(IA,IB)=0.0D0
    ENDDO
   ENDDO

   ! ZERO SCRATCH PRODUCT VECTOR
   PRD=0.0D0

   ! DIAGONAL ELEMENTS
   DO IA=1,NCF
    DO IB=1,NCF
     DO I=1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFHALF(IA),I-1)) PRD(IB,IA)=PRD(IB,IA)+H(I,I)*TRL(IB,IA)
      IF (BTEST(CFHALF(IB),I-1)) PRD(IB,IA)=PRD(IB,IA)+H(I,I)*TRL(IB,IA)
     ENDDO
     DO I=1,IALL(0,0,0)-IVIRTCORE
      DO J=1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),I-1)) THEN
        NIA=1
       ELSE
        NIA=0
       ENDIF
       IF (BTEST(CFHALF(IA),J-1)) THEN
        NJA=1
       ELSE
        NJA=0
       ENDIF
       IF (BTEST(CFHALF(IB),I-1)) THEN
        NIB=1
       ELSE
        NIB=0
       ENDIF
       IF (BTEST(CFHALF(IB),J-1)) THEN
        NJB=1
       ELSE
        NJB=0
       ENDIF
       PRD(IB,IA)=PRD(IB,IA)+0.5D0*(DFLOAT((NJA+NJB)*(NIA+NIB))*GG(J,J,I,I) &
                 -DFLOAT(NJA*NIA+NJB*NIB)*GG(J,I,I,J))*TRL(IB,IA)
      ENDDO
     ENDDO
    ENDDO
   ENDDO

   ! ONE SPIN ORBITAL DIFFERENCE
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(CFHALF(IA),I-1)) THEN
      DO K=1,IALL(0,0,0)-IVIRTCORE
       IF (.NOT.(BTEST(CFHALF(IA),K-1))) THEN
        CFONE=IBCLR(CFHALF(IA),I-1)
        CFONE=IBSET(CFONE,K-1)
        IC=ADDRSS(CFONE)
        X=H(K,I)
        DO J=1,IALL(0,0,0)-IVIRTCORE
         IF ((J /= I).AND.(J /= K).AND.(BTEST(CFONE,J-1))) X=X+GG(K,I,J,J)-GG(K,J,J,I)
        ENDDO
        ISIGN=1
        DO J=1,I
         IF (BTEST(CFHALF(IA),J-1)) ISIGN=-ISIGN
        ENDDO
        DO J=1,K
         IF (BTEST(CFONE,J-1)) ISIGN=-ISIGN
        ENDDO
        DO IB=1,NCF
         IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
          Y=0.0D0
          DO J=1,IALL(0,0,0)-IVIRTCORE
           IF (BTEST(CFHALF(IB),J-1)) Y=Y+GG(K,I,J,J)
          ENDDO
          PRD(IB,IC)=PRD(IB,IC)+(X+Y)*DFLOAT(ISIGN)*TRL(IB,IA)
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
   DO IB=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(CFHALF(IB),I-1)) THEN
      DO K=1,IALL(0,0,0)-IVIRTCORE
       IF (.NOT.(BTEST(CFHALF(IB),K-1))) THEN
        CFONE=IBCLR(CFHALF(IB),I-1)
        CFONE=IBSET(CFONE,K-1)
        IC=ADDRSS(CFONE)
        X=H(K,I)
        DO J=1,IALL(0,0,0)-IVIRTCORE
         IF ((J /= I).AND.(J /= K).AND.(BTEST(CFONE,J-1))) X=X+GG(K,I,J,J)-GG(K,J,J,I)
        ENDDO
        ISIGN=1
        DO J=1,I
         IF (BTEST(CFHALF(IB),J-1)) ISIGN=-ISIGN
        ENDDO
        DO J=1,K
         IF (BTEST(CFONE,J-1)) ISIGN=-ISIGN
        ENDDO
        DO IA=1,NCF
         IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
          Y=0.0D0
          DO J=1,IALL(0,0,0)-IVIRTCORE
           IF (BTEST(CFHALF(IA),J-1)) Y=Y+GG(K,I,J,J)
          ENDDO
          PRD(IC,IA)=PRD(IC,IA)+(X+Y)*DFLOAT(ISIGN)*TRL(IB,IA)
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO

   ! TWO SPIN ORBITAL DIFFERENCES, CASE 1
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE-1
     IF (BTEST(CFHALF(IA),I-1)) THEN
      DO J=I+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),J-1)) THEN
        DO K=1,IALL(0,0,0)-IVIRTCORE-1
         IF (.NOT.(BTEST(CFHALF(IA),K-1))) THEN
          DO L=K+1,IALL(0,0,0)-IVIRTCORE
           IF (.NOT.(BTEST(CFHALF(IA),L-1))) THEN
            CFTWO=IBCLR(CFHALF(IA),I-1)
            CFTWO=IBCLR(CFTWO,J-1)
            CFTWO=IBSET(CFTWO,K-1)
            CFTWO=IBSET(CFTWO,L-1)
            IC=ADDRSS(CFTWO)
            ISIGN=1
            DO M=1,I
             IF (BTEST(CFHALF(IA),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,J
             IF (BTEST(CFHALF(IA),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,K
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,L
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            Y=DFLOAT(ISIGN)*(GG(K,I,L,J)-GG(K,J,L,I))
            DO IB=1,NCF
             PRD(IB,IC)=PRD(IB,IC)+Y*TRL(IB,IA)
            ENDDO
           ENDIF
          ENDDO
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
   DO IB=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE-1
     IF (BTEST(CFHALF(IB),I-1)) THEN
      DO J=I+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IB),J-1)) THEN
        DO K=1,IALL(0,0,0)-IVIRTCORE-1
         IF (.NOT.(BTEST(CFHALF(IB),K-1))) THEN
          DO L=K+1,IALL(0,0,0)-IVIRTCORE
           IF (.NOT.(BTEST(CFHALF(IB),L-1))) THEN
            CFTWO=IBCLR(CFHALF(IB),I-1)
            CFTWO=IBCLR(CFTWO,J-1)
            CFTWO=IBSET(CFTWO,K-1)
            CFTWO=IBSET(CFTWO,L-1)
            IC=ADDRSS(CFTWO)
            ISIGN=1
            DO M=1,I
             IF (BTEST(CFHALF(IB),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,J
             IF (BTEST(CFHALF(IB),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,K
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,L
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            Y=DFLOAT(ISIGN)*(GG(K,I,L,J)-GG(K,J,L,I))
            DO IA=1,NCF
             PRD(IC,IA)=PRD(IC,IA)+Y*TRL(IB,IA)
            ENDDO
           ENDIF
          ENDDO
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
!  CALL PCPU_TIME(ICPUE)
!  EST=ICPUE-ICPUS
!  CALL PCPU_TIME(ICPUS)

   ! TWO SPIN ORBITAL DIFFERENCES, CASE 2
   DO IB=1,NCF
    DO K=ICORE+1,IALL(0,0,0)-IVIRTCORE
     DO L=1,IALL(0,0,0)-IVIRTCORE
      PSIGN(L,K,IB)=0
      PADRS(L,K,IB)=0
      IF ((BTEST(CFHALF(IB),K-1)).AND.(.NOT.(BTEST(CFHALF(IB),L-1)))) THEN
       CFONE=IBCLR(CFHALF(IB),K-1)
       CFONE=IBSET(CFONE,L-1)
       PADRS(L,K,IB)=ADDRSS(CFONE)
       JSIGN=1
       DO M=1,K
        IF (BTEST(CFHALF(IB),M-1)) JSIGN=-JSIGN
       ENDDO
       DO M=1,L
        IF (BTEST(CFONE,M-1)) JSIGN=-JSIGN
       ENDDO
       PSIGN(L,K,IB)=JSIGN
      ENDIF
     ENDDO
    ENDDO
   ENDDO
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     DO J=1,IALL(0,0,0)-IVIRTCORE
      IF ((BTEST(CFHALF(IA),I-1)).AND.(.NOT.(BTEST(CFHALF(IA),J-1)))) THEN
       CFONE=IBCLR(CFHALF(IA),I-1)
       CFONE=IBSET(CFONE,J-1)
       IC=ADDRSS(CFONE)
       ISIGN=1
       DO K=1,I
        IF (BTEST(CFHALF(IA),K-1)) ISIGN=-ISIGN
       ENDDO
       DO K=1,J
        IF (BTEST(CFONE,K-1)) ISIGN=-ISIGN
       ENDDO
       DO IB=1,NCF
        IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
         DO K=ICORE+1,IALL(0,0,0)-IVIRTCORE
          DO L=1,IALL(0,0,0)-IVIRTCORE
           IF (PADRS(L,K,IB) /= 0) PRD(PADRS(L,K,IB),IC)=PRD(PADRS(L,K,IB),IC)+DFLOAT(ISIGN*PSIGN(L,K,IB))*GG(J,I,L,K)*TRL(IB,IA)
          ENDDO
         ENDDO
        ENDIF
       ENDDO
      ENDIF
     ENDDO
    ENDDO
!   CALL PCPU_TIME(ICPUE)
!   IF (IA == 1) THEN
!    EST=EST+(ICPUE-ICPUS)*NCF
!    EST=EST/3600.0
!    IF (EST > 0.1) WRITE(6,'(A,F20.1,A)') '***** WARNING : ESTIMATED PRODUCT FORMATION TIME = ',EST,' HOURS'
!   ENDIF
   ENDDO

   ! ZERO SCRATCH PRODUCT VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   DO IA=1,NCF
    DO IB=1,NCF
     IF (NORDER(IA)+NORDER(IB) > ORDER) PRD(IA,IB)=0.0D0
    ENDDO
   ENDDO

   ! STORE PRODUCT VECTOR
   REWIND(OUTFILE)
   IF (OFFSET == 0) THEN
    WRITE(OUTFILE) PRD
   ELSE
    DO I=1,OFFSET
     READ(OUTFILE) TRL
    ENDDO
    WRITE(OUTFILE) PRD
   ENDIF

   DEALLOCATE(GG)
   DEALLOCATE(TRL,PRD,PSIGN,PADRS)

   RETURN
END SUBROUTINE



SUBROUTINE REL_GENERATE_IP_CONFIGURATIONS(ORDER)
! GENERATE CONFIGURATIONS FOR (N-1) ALPHA ELECTRONS

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: ORDER
   INTEGER :: I,J,K,L,M
   INTEGER :: I1,I2,I3,I4,I5,I6,I7,I8
   INTEGER(4) :: ICF
   INTEGER :: COMBINATION
   REAL :: MEM
   
   IF (IOCC-ICORE <= 1) CALL PABORT('TOO FEW ELECTRONS LEFT AFTER IONIZATION')
   WRITE(6,'(A,I3,A,I3,A)') 'GENERATE AND ORDER CONFIGURATIONS FOR BETA ELECTRONS UP TO ',&
   ORDER,'-HOLE ',ORDER-1,'-PARTICLE EXCITATIONS'
   IF (ICORE > 0) WRITE(6,'(A,I3,A)') '***** WARNING : ',ICORE,' CORE BETA ORBITALS ARE ALWAYS OCCUPIED'
   IF (IVIRTCORE > 0) WRITE(6,'(A,I3,A)') '***** WARNING : ',IVIRTCORE,' HIGHEST VIRTUAL BETA ORBITALS ARE ALWAYS UNOCCUPIED'
   WRITE(6,'(A,I3,A,I3,A)') 'THERE ARE ',IOCC-ICORE-1,' ACTIVE BETA ELECTRONS IN ',IALL(0,0,0)-ICORE-IVIRTCORE,' ACTIVE ORBITALS'
   MEM=4.0*2**(IALL(0,0,0)-IVIRTCORE)
   IF (MEM > 1000000.0) WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE FOR THE BETA STRINGS WILL BE ',MEM/1000000.0,' MB'
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY')
   IP_NCF=0
   DO I=1,ORDER
    J=COMBINATION(IOCC-ICORE,I)*COMBINATION(IALL(0,0,0)-IOCC-IVIRTCORE,I-1)
    WRITE(6,'(I4,A,I3,A,I7)') I,'-HOLE ',I-1,'-PARTICLE EXCITATIONS ',J
    IP_NCF=IP_NCF+J
   ENDDO
   WRITE(6,'(A,I7)') '    TOTAL BETA CONFIGURATIONS ',IP_NCF
   IF (IP_NCF /= COMBINATION(IALL(0,0,0)-ICORE-IVIRTCORE,IOCC-ICORE-1)) CALL PABORT('AN ERROR OCCURRED IN COMBINATION FUNCTION')

   ALLOCATE(IP_CFHALF(IP_NCF),IP_NORDER(IP_NCF),IP_ADDRSS(2**(IALLMAX-IVIRTCORE)))
   IP_ADDRSS=0
   I=0
   IF (IOCC == 2) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE
     J=0
     IF (I1 <= ICORE) J=J+1
     IF (J /= ICORE) CYCLE
     J=IOCC
     IF (I1 <= IOCC) J=J-1
     IF (J > ORDER) CYCLE
     ICF=0
     ICF=IBSET(ICF,I1-1) 
     I=I+1
     IP_CFHALF(I)=ICF
     IP_NORDER(I)=J
     IP_ADDRSS(ICF)=I
     IF (IP_NORDER(I) <= 3) THEN
      K=0
      DO L=0,IALL(0,0,0)-IVIRTCORE-1
       IF (BTEST(ICF,L)) K=K+10**L
       IF (BTEST(ICF,L)) M=L
      ENDDO
      IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' HOLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
     ENDIF
    ENDDO
   ELSE IF (IOCC == 3) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-1
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE
      J=0
      IF (I1 <= ICORE) J=J+1
      IF (I2 <= ICORE) J=J+1
      IF (J /= ICORE) CYCLE
      J=IOCC
      IF (I1 <= IOCC) J=J-1
      IF (I2 <= IOCC) J=J-1
      IF (J > ORDER) CYCLE
      ICF=0
      ICF=IBSET(ICF,I1-1) 
      ICF=IBSET(ICF,I2-1) 
      I=I+1
      IP_CFHALF(I)=ICF
      IP_NORDER(I)=J
      IP_ADDRSS(ICF)=I
      IF (IP_NORDER(I) <= 3) THEN
       K=0
       DO L=0,IALL(0,0,0)-IVIRTCORE-1
        IF (BTEST(ICF,L)) K=K+10**L
        IF (BTEST(ICF,L)) M=L
       ENDDO
       IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' HOLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
      ENDIF
     ENDDO
    ENDDO
   ELSE IF (IOCC == 4) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-2
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-1
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE
       J=0
       IF (I1 <= ICORE) J=J+1
       IF (I2 <= ICORE) J=J+1
       IF (I3 <= ICORE) J=J+1
       IF (J /= ICORE) CYCLE
       J=IOCC
       IF (I1 <= IOCC) J=J-1
       IF (I2 <= IOCC) J=J-1
       IF (I3 <= IOCC) J=J-1
       IF (J > ORDER) CYCLE
       ICF=0
       ICF=IBSET(ICF,I1-1) 
       ICF=IBSET(ICF,I2-1) 
       ICF=IBSET(ICF,I3-1) 
       I=I+1
       IP_CFHALF(I)=ICF
       IP_NORDER(I)=J
       IP_ADDRSS(ICF)=I
       IF (IP_NORDER(I) <= 3) THEN
        K=0
        DO L=0,IALL(0,0,0)-IVIRTCORE-1
         IF (BTEST(ICF,L)) K=K+10**L
         IF (BTEST(ICF,L)) M=L
        ENDDO
        IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' HOLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
       ENDIF
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 5) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-3
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-2
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-1
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE
        J=0
        IF (I1 <= ICORE) J=J+1
        IF (I2 <= ICORE) J=J+1
        IF (I3 <= ICORE) J=J+1
        IF (I4 <= ICORE) J=J+1
        IF (J /= ICORE) CYCLE
        J=IOCC
        IF (I1 <= IOCC) J=J-1
        IF (I2 <= IOCC) J=J-1
        IF (I3 <= IOCC) J=J-1
        IF (I4 <= IOCC) J=J-1
        IF (J > ORDER) CYCLE
        ICF=0
        ICF=IBSET(ICF,I1-1) 
        ICF=IBSET(ICF,I2-1) 
        ICF=IBSET(ICF,I3-1) 
        ICF=IBSET(ICF,I4-1) 
        I=I+1
        IP_CFHALF(I)=ICF
        IP_NORDER(I)=J
        IP_ADDRSS(ICF)=I
        IF (IP_NORDER(I) <= 3) THEN
         K=0
         DO L=0,IALL(0,0,0)-IVIRTCORE-1
          IF (BTEST(ICF,L)) K=K+10**L
          IF (BTEST(ICF,L)) M=L
         ENDDO
         IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' HOLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
        ENDIF
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 6) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-4
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-3
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-2
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-1
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE
         J=0
         IF (I1 <= ICORE) J=J+1
         IF (I2 <= ICORE) J=J+1
         IF (I3 <= ICORE) J=J+1
         IF (I4 <= ICORE) J=J+1
         IF (I5 <= ICORE) J=J+1
         IF (J /= ICORE) CYCLE
         J=IOCC
         IF (I1 <= IOCC) J=J-1
         IF (I2 <= IOCC) J=J-1
         IF (I3 <= IOCC) J=J-1
         IF (I4 <= IOCC) J=J-1
         IF (I5 <= IOCC) J=J-1
         IF (J > ORDER) CYCLE
         ICF=0
         ICF=IBSET(ICF,I1-1) 
         ICF=IBSET(ICF,I2-1) 
         ICF=IBSET(ICF,I3-1) 
         ICF=IBSET(ICF,I4-1) 
         ICF=IBSET(ICF,I5-1) 
         I=I+1
         IP_CFHALF(I)=ICF
         IP_NORDER(I)=J
         IP_ADDRSS(ICF)=I
         IF (IP_NORDER(I) <= 3) THEN
          K=0
          DO L=0,IALL(0,0,0)-IVIRTCORE-1
           IF (BTEST(ICF,L)) K=K+10**L
           IF (BTEST(ICF,L)) M=L
          ENDDO
          IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' HOLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
         ENDIF
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 7) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-5
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-4
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-3
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-2
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE-1
         DO I6=I5+1,IALL(0,0,0)-IVIRTCORE
          J=0
          IF (I1 <= ICORE) J=J+1
          IF (I2 <= ICORE) J=J+1
          IF (I3 <= ICORE) J=J+1
          IF (I4 <= ICORE) J=J+1
          IF (I5 <= ICORE) J=J+1
          IF (I6 <= ICORE) J=J+1
          IF (J /= ICORE) CYCLE
          J=IOCC
          IF (I1 <= IOCC) J=J-1
          IF (I2 <= IOCC) J=J-1
          IF (I3 <= IOCC) J=J-1
          IF (I4 <= IOCC) J=J-1
          IF (I5 <= IOCC) J=J-1
          IF (I6 <= IOCC) J=J-1
          IF (J > ORDER) CYCLE
          ICF=0
          ICF=IBSET(ICF,I1-1) 
          ICF=IBSET(ICF,I2-1) 
          ICF=IBSET(ICF,I3-1) 
          ICF=IBSET(ICF,I4-1) 
          ICF=IBSET(ICF,I5-1) 
          ICF=IBSET(ICF,I6-1) 
          I=I+1
          IP_CFHALF(I)=ICF
          IP_NORDER(I)=J
          IP_ADDRSS(ICF)=I
          IF (IP_NORDER(I) <= 3) THEN
           K=0
           DO L=0,IALL(0,0,0)-IVIRTCORE-1
            IF (BTEST(ICF,L)) K=K+10**L
            IF (BTEST(ICF,L)) M=L
           ENDDO
           IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' HOLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
          ENDIF
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 8) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-6
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-5
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-4
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-3
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE-2
         DO I6=I5+1,IALL(0,0,0)-IVIRTCORE-1
          DO I7=I6+1,IALL(0,0,0)-IVIRTCORE
           J=0
           IF (I1 <= ICORE) J=J+1
           IF (I2 <= ICORE) J=J+1
           IF (I3 <= ICORE) J=J+1
           IF (I4 <= ICORE) J=J+1
           IF (I5 <= ICORE) J=J+1
           IF (I6 <= ICORE) J=J+1
           IF (I7 <= ICORE) J=J+1
           IF (J /= ICORE) CYCLE
           J=IOCC
           IF (I1 <= IOCC) J=J-1
           IF (I2 <= IOCC) J=J-1
           IF (I3 <= IOCC) J=J-1
           IF (I4 <= IOCC) J=J-1
           IF (I5 <= IOCC) J=J-1
           IF (I6 <= IOCC) J=J-1
           IF (I7 <= IOCC) J=J-1
           IF (J > ORDER) CYCLE
           ICF=0
           ICF=IBSET(ICF,I1-1) 
           ICF=IBSET(ICF,I2-1) 
           ICF=IBSET(ICF,I3-1) 
           ICF=IBSET(ICF,I4-1) 
           ICF=IBSET(ICF,I5-1) 
           ICF=IBSET(ICF,I6-1) 
           ICF=IBSET(ICF,I7-1) 
           I=I+1
           IP_CFHALF(I)=ICF
           IP_NORDER(I)=J
           IP_ADDRSS(ICF)=I
           IF (IP_NORDER(I) <= 3) THEN
            K=0
            DO L=0,IALL(0,0,0)-IVIRTCORE-1
             IF (BTEST(ICF,L)) K=K+10**L
             IF (BTEST(ICF,L)) M=L
            ENDDO
            IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' HOLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
           ENDIF
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE
    CALL PABORT('NUMBER OF ELECTRONS IS TOO LARGE')
   ENDIF

   RETURN
END SUBROUTINE



SUBROUTINE REL_IP_HAMILTONIAN_PRODUCT(INFILE,OUTFILE,OFFSET,ORDER)
! FORM THE PRODUCT OF HAMILTONIAN MATRIX AND A TRIAL VECTOR IN INFILE
! AND STORE THE PRODUCT VECTOR IN OUTFILE.  THE ORDER LIMITS THE NUMBER
! EXCITATION IN THE CONFIGURATIONS CONSIDERED.  THE BETA ELECTRON IS
! ALWAYS ASSUMED TO BE IONIZED.  NOTICE THAT TRL(BETA,ALPHA) AND LIKEWISE
! FOR PRD ARRAYS.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: INFILE,OUTFILE,OFFSET
   INTEGER :: ORDER
   INTEGER :: ISIGN,JSIGN
   INTEGER :: I,J,K,L,M
   INTEGER :: IA,IB,IC,ID
   INTEGER :: NIA,NIB,NJA,NJB
   INTEGER(4) :: CFONE,CFTWO
   REAL :: MEM,ICPUS,ICPUE,EST
   DOUBLE PRECISION :: X,Y
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:),PRD(:,:)
   INTEGER,ALLOCATABLE :: IP_PSIGN(:,:,:),IP_PADRS(:,:,:)

!  CALL PCPU_TIME(ICPUS)
   MEM=16.0*2.0*NCF*IP_NCF+4.0*2.0*NCF*(IALL(0,0,0)-IVIRTCORE)**2
!  IF (MEM > 1000000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
!  ELSE IF (MEM > 1000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
!  ELSE
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
!  ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 

   ALLOCATE(TRL(IP_NCF,NCF),PRD(IP_NCF,NCF))
   ALLOCATE(IP_PSIGN(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IP_NCF),IP_PADRS(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,IP_NCF))

   ! READ TRIAL VECTOR FROM FILE INFILE
   REWIND(INFILE)
   DO I=0,OFFSET
    READ(INFILE) TRL
   ENDDO

   ! ZERO SCRATCH TRIAL VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   DO IA=1,NCF
    DO IB=1,IP_NCF
     IF (NORDER(IA)+IP_NORDER(IB) > ORDER) TRL(IB,IA)=0.0D0
    ENDDO
   ENDDO

   ! ZERO SCRATCH PRODUCT VECTOR
   PRD=0.0D0

   ! DIAGONAL ELEMENTS
   DO IA=1,NCF
    DO IB=1,IP_NCF
     DO I=1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFHALF(IA),I-1))    PRD(IB,IA)=PRD(IB,IA)+H(I,I)*TRL(IB,IA)
      IF (BTEST(IP_CFHALF(IB),I-1)) PRD(IB,IA)=PRD(IB,IA)+H(I,I)*TRL(IB,IA)
     ENDDO
     DO I=1,IALL(0,0,0)-IVIRTCORE
      DO J=1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),I-1)) THEN
        NIA=1
       ELSE
        NIA=0
       ENDIF
       IF (BTEST(CFHALF(IA),J-1)) THEN
        NJA=1
       ELSE
        NJA=0
       ENDIF
       IF (BTEST(IP_CFHALF(IB),I-1)) THEN
        NIB=1
       ELSE
        NIB=0
       ENDIF
       IF (BTEST(IP_CFHALF(IB),J-1)) THEN
        NJB=1
       ELSE
        NJB=0
       ENDIF
       PRD(IB,IA)=PRD(IB,IA)+0.5D0*(DFLOAT((NJA+NJB)*(NIA+NIB))*G(J,J,I,I) &
                 -DFLOAT(NJA*NIA+NJB*NIB)*G(J,I,I,J))*TRL(IB,IA)
      ENDDO
     ENDDO
    ENDDO
   ENDDO

   ! ONE SPIN ORBITAL DIFFERENCE
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(CFHALF(IA),I-1)) THEN
      DO K=1,IALL(0,0,0)-IVIRTCORE
       IF (.NOT.(BTEST(CFHALF(IA),K-1))) THEN
        CFONE=IBCLR(CFHALF(IA),I-1)
        CFONE=IBSET(CFONE,K-1)
        IC=ADDRSS(CFONE)
        X=H(K,I)
        DO J=1,IALL(0,0,0)-IVIRTCORE
         IF ((J /= I).AND.(J /= K).AND.(BTEST(CFONE,J-1))) X=X+G(K,I,J,J)-G(K,J,J,I)
        ENDDO
        ISIGN=1
        DO J=1,I
         IF (BTEST(CFHALF(IA),J-1)) ISIGN=-ISIGN
        ENDDO
        DO J=1,K
         IF (BTEST(CFONE,J-1)) ISIGN=-ISIGN
        ENDDO
        DO IB=1,IP_NCF
         IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
          Y=0.0D0
          DO J=1,IALL(0,0,0)-IVIRTCORE
           IF (BTEST(IP_CFHALF(IB),J-1)) Y=Y+G(K,I,J,J)
          ENDDO
          PRD(IB,IC)=PRD(IB,IC)+(X+Y)*DFLOAT(ISIGN)*TRL(IB,IA)
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
   DO IB=1,IP_NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(IP_CFHALF(IB),I-1)) THEN
      DO K=1,IALL(0,0,0)-IVIRTCORE
       IF (.NOT.(BTEST(IP_CFHALF(IB),K-1))) THEN
        CFONE=IBCLR(IP_CFHALF(IB),I-1)
        CFONE=IBSET(CFONE,K-1)
        IC=IP_ADDRSS(CFONE)
        X=H(K,I)
        DO J=1,IALL(0,0,0)-IVIRTCORE
         IF ((J /= I).AND.(J /= K).AND.(BTEST(CFONE,J-1))) X=X+G(K,I,J,J)-G(K,J,J,I)
        ENDDO
        ISIGN=1
        DO J=1,I
         IF (BTEST(IP_CFHALF(IB),J-1)) ISIGN=-ISIGN
        ENDDO
        DO J=1,K
         IF (BTEST(CFONE,J-1)) ISIGN=-ISIGN
        ENDDO
        DO IA=1,NCF
         IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
          Y=0.0D0
          DO J=1,IALL(0,0,0)-IVIRTCORE
           IF (BTEST(CFHALF(IA),J-1)) Y=Y+G(K,I,J,J)
          ENDDO
          PRD(IC,IA)=PRD(IC,IA)+(X+Y)*DFLOAT(ISIGN)*TRL(IB,IA)
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO

   ! TWO SPIN ORBITAL DIFFERENCES, CASE 1
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE-1
     IF (BTEST(CFHALF(IA),I-1)) THEN
      DO J=I+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),J-1)) THEN
        DO K=1,IALL(0,0,0)-IVIRTCORE-1
         IF (.NOT.(BTEST(CFHALF(IA),K-1))) THEN
          DO L=K+1,IALL(0,0,0)-IVIRTCORE
           IF (.NOT.(BTEST(CFHALF(IA),L-1))) THEN
            CFTWO=IBCLR(CFHALF(IA),I-1)
            CFTWO=IBCLR(CFTWO,J-1)
            CFTWO=IBSET(CFTWO,K-1)
            CFTWO=IBSET(CFTWO,L-1)
            IC=ADDRSS(CFTWO)
            ISIGN=1
            DO M=1,I
             IF (BTEST(CFHALF(IA),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,J
             IF (BTEST(CFHALF(IA),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,K
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,L
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            Y=DFLOAT(ISIGN)*(G(K,I,L,J)-G(K,J,L,I))
            DO IB=1,IP_NCF
             PRD(IB,IC)=PRD(IB,IC)+Y*TRL(IB,IA)
            ENDDO
           ENDIF
          ENDDO
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
   DO IB=1,IP_NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE-1
     IF (BTEST(IP_CFHALF(IB),I-1)) THEN
      DO J=I+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(IP_CFHALF(IB),J-1)) THEN
        DO K=1,IALL(0,0,0)-IVIRTCORE-1
         IF (.NOT.(BTEST(IP_CFHALF(IB),K-1))) THEN
          DO L=K+1,IALL(0,0,0)-IVIRTCORE
           IF (.NOT.(BTEST(IP_CFHALF(IB),L-1))) THEN
            CFTWO=IBCLR(IP_CFHALF(IB),I-1)
            CFTWO=IBCLR(CFTWO,J-1)
            CFTWO=IBSET(CFTWO,K-1)
            CFTWO=IBSET(CFTWO,L-1)
            IC=IP_ADDRSS(CFTWO)
            ISIGN=1
            DO M=1,I
             IF (BTEST(IP_CFHALF(IB),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,J
             IF (BTEST(IP_CFHALF(IB),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,K
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,L
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            Y=DFLOAT(ISIGN)*(G(K,I,L,J)-G(K,J,L,I))
            DO IA=1,NCF
             PRD(IC,IA)=PRD(IC,IA)+Y*TRL(IB,IA)
            ENDDO
           ENDIF
          ENDDO
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
!  CALL PCPU_TIME(ICPUE)
!  EST=ICPUE-ICPUS
!  CALL PCPU_TIME(ICPUS)

   ! TWO SPIN ORBITAL DIFFERENCES, CASE 2
   DO IB=1,IP_NCF
    DO K=ICORE+1,IALL(0,0,0)-IVIRTCORE
     DO L=1,IALL(0,0,0)-IVIRTCORE
      IP_PSIGN(L,K,IB)=0
      IP_PADRS(L,K,IB)=0
      IF ((BTEST(IP_CFHALF(IB),K-1)).AND.(.NOT.(BTEST(IP_CFHALF(IB),L-1)))) THEN
       CFONE=IBCLR(IP_CFHALF(IB),K-1)
       CFONE=IBSET(CFONE,L-1)
       IP_PADRS(L,K,IB)=IP_ADDRSS(CFONE)
       JSIGN=1
       DO M=1,K
        IF (BTEST(IP_CFHALF(IB),M-1)) JSIGN=-JSIGN
       ENDDO
       DO M=1,L
        IF (BTEST(CFONE,M-1)) JSIGN=-JSIGN
       ENDDO
       IP_PSIGN(L,K,IB)=JSIGN
      ENDIF
     ENDDO
    ENDDO
   ENDDO
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     DO J=1,IALL(0,0,0)-IVIRTCORE
      IF ((BTEST(CFHALF(IA),I-1)).AND.(.NOT.(BTEST(CFHALF(IA),J-1)))) THEN
       CFONE=IBCLR(CFHALF(IA),I-1)
       CFONE=IBSET(CFONE,J-1)
       IC=ADDRSS(CFONE)
       ISIGN=1
       DO K=1,I
        IF (BTEST(CFHALF(IA),K-1)) ISIGN=-ISIGN
       ENDDO
       DO K=1,J
        IF (BTEST(CFONE,K-1)) ISIGN=-ISIGN
       ENDDO
       DO IB=1,IP_NCF
        IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
         DO K=ICORE+1,IALL(0,0,0)-IVIRTCORE
          DO L=1,IALL(0,0,0)-IVIRTCORE
           IF (IP_PADRS(L,K,IB) /= 0) PRD(IP_PADRS(L,K,IB),IC)=PRD(IP_PADRS(L,K,IB),IC) &
           +DFLOAT(ISIGN*IP_PSIGN(L,K,IB))*G(J,I,L,K)*TRL(IB,IA)
          ENDDO
         ENDDO
        ENDIF
       ENDDO
      ENDIF
     ENDDO
    ENDDO
!   CALL PCPU_TIME(ICPUE)
!   IF (IA == 1) THEN
!    EST=EST+(ICPUE-ICPUS)*NCF
!    EST=EST/3600.0
!    IF (EST > 0.1) WRITE(6,'(A,F20.1,A)') '***** WARNING : ESTIMATED PRODUCT FORMATION TIME = ',EST,' HOURS'
!   ENDIF
   ENDDO

   ! ZERO SCRATCH PRODUCT VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   DO IA=1,NCF
    DO IB=1,IP_NCF
     IF (NORDER(IA)+IP_NORDER(IB) > ORDER) PRD(IB,IA)=0.0D0
    ENDDO
   ENDDO

   ! STORE PRODUCT VECTOR
   REWIND(OUTFILE)
   IF (OFFSET == 0) THEN
    WRITE(OUTFILE) PRD
   ELSE
    DO I=1,OFFSET
     READ(OUTFILE) TRL
    ENDDO
    WRITE(OUTFILE) PRD
   ENDIF

   DEALLOCATE(TRL,PRD,IP_PSIGN,IP_PADRS)

   RETURN
END SUBROUTINE



SUBROUTINE REL_FULL_IP_HAMILTONIAN(ORDER)
! FORM FULL HAMILTONIAN AND DIAGONALIZE IT BY THE STANDARD ALGORITHMS.
! CAUTION, DO NOT USE THIS FOR PRODUCTION RUN.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL,PARAMETER :: LEVEC = .FALSE.
   INTEGER :: ORDER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: INFO
   REAL :: MEM,DEV
   DOUBLE PRECISION,ALLOCATABLE :: HAM(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: VL(:,:),VR(:,:),ER(:),EI(:),WK(:)
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:)

   WRITE(6,'(I2,A,I2,A)') ORDER,'-HOLE',ORDER-1,'-PARTICLE CONFIGURATION INTERACTION CALCULATION FOR ALL STATES'
   IF (LEVEC) THEN 
    MEM=16.0*(2.0*(NCF*IP_NCF)**2+8.0*NCF*IP_NCF)
   ELSE
    MEM=16.0*((NCF*IP_NCF)**2+9.0*NCF*IP_NCF)
   ENDIF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   ALLOCATE(HAM(NCF*IP_NCF,NCF*IP_NCF),VL(1,NCF*IP_NCF),ER(NCF*IP_NCF),EI(NCF*IP_NCF),WK(4*NCF*IP_NCF))
   IF (LEVEC) THEN 
    ALLOCATE(VR(NCF*IP_NCF,NCF*IP_NCF))
   ELSE
    ALLOCATE(VR(1,NCF*IP_NCF))
   ENDIF
   ALLOCATE(TRL(IP_NCF,NCF))

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')

   ! FORM HAMILTONIAN AND KEEP IT IN MEMORY
   DO IA=1,NCF
    DO IB=1,IP_NCF
     TRL=0.0D0
     IF (NORDER(IA)+IP_NORDER(IB) <= ORDER) TRL(IB,IA)=1.0D0
     REWIND(50)
     WRITE(50) TRL
     CALL REL_IP_HAMILTONIAN_PRODUCT(50,60,0,ORDER)
     REWIND(60)
     READ(60) TRL
     DO IC=1,NCF
      DO ID=1,IP_NCF
       HAM((IA-1)*IP_NCF+IB,(IC-1)*IP_NCF+ID)=TRL(ID,IC)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
!  CALL DUMP5(HAM,NCF*IP_NCF)

   DEALLOCATE(TRL)
   CLOSE(50)
   CLOSE(60)

   ! DIAGONALIZE HAMILTONIAN
   IF (LEVEC) THEN
    CALL DGEEV('N','V',NCF*IP_NCF,HAM,NCF*IP_NCF,ER,EI,VL,1,VR,NCF*IP_NCF,WK,4*NCF*IP_NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF*IP_NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT(NCF*IP_NCF,NCF*IP_NCF,ER,VR,EI)
    DO IA=1,MIN(25,NCF*IP_NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
     DO IB=1,NCF*IP_NCF
      WRITE(6,'(I10,F20.15)') IB,VR(IB,IA)
     ENDDO
    ENDDO
   ELSE
    CALL DGEEV('N','N',NCF*IP_NCF,HAM,NCF*IP_NCF,ER,EI,VL,1,VR,1,WK,4*NCF*IP_NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF*IP_NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT_EVALONLY(NCF*IP_NCF,ER)
    DO IA=1,MIN(25,NCF*IP_NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
    ENDDO
   ENDIF
   CALL PFLUSH(6)

   DEALLOCATE(HAM,VL,VR,ER,EI,WK)

   RETURN
END SUBROUTINE



SUBROUTINE REL_CI_IP_GUESS(ORDER,NROOTS,NTRIALS)
! GENERATE INITIAL GUESS TRIAL VECTORS FOR CI CALCULATIONS.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER :: ORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: IA,IB
   INTEGER :: I,J
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:)

   IF (NROOTS < 1) CALL PABORT('ILLEGAL NUMBER OF CI ROOTS')
   IF ((ORDER < 1).OR.(ORDER > MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1))) &
   CALL PABORT('ILLEGAL NUMBER OF CI ORDER')

   WRITE(6,'(A)') 'INITIAL GUESS FOR THE CI/EOMCC VECTORS WILL BE GENERATED'

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   REWIND(50)

   ALLOCATE(VEC1(IP_NCF,NCF))
   ! GENERATE INITIAL GUESS
   IF (NROOTS <= IOCC-ICORE) THEN
    REWIND(50)
    NTRIALS=0
    DO IB=1,IP_NCF
     IF (IP_NORDER(IB) == 1) THEN
      NTRIALS=NTRIALS+1
      VEC1=0.0D0
      VEC1(IB,1)=1.0D0
      WRITE(50) VEC1
     ENDIF
    ENDDO
   ELSE IF (ORDER > 1) THEN
    REWIND(50)
    NTRIALS=0
    DO IA=1,NCF
     IF (NORDER(IA) == 1) THEN
      NTRIALS=NTRIALS+1
      VEC1=0.0D0
      VEC1(1,IA)=1.0D0
      WRITE(50) VEC1
     ENDIF
    ENDDO
    DO IB=1,IP_NCF
     IF (IP_NORDER(IB) == 1) THEN
      NTRIALS=NTRIALS+1
      VEC1=0.0D0
      VEC1(IB,1)=1.0D0
      WRITE(50) VEC1
     ENDIF
    ENDDO
    IF (NTRIALS < NROOTS) THEN
     REWIND(50)
     NTRIALS=0
     DO IA=1,NCF
      DO IB=1,IP_NCF
       IF (NORDER(IA)+IP_NORDER(IB) <= 2) THEN
        NTRIALS=NTRIALS+1
        VEC1=0.0D0
        VEC1(IB,IA)=1.0D0
        WRITE(50) VEC1
       ENDIF
      ENDDO
     ENDDO
    ENDIF
   ELSE
    CALL PABORT('DECREASE THE NUMBER OF ROOTS')
   ENDIF
 
   IF (NROOTS > NTRIALS) CALL PABORT('DECREASE THE NUMBER OF ROOTS')

   DEALLOCATE(VEC1)
   CLOSE(50)

   RETURN
END SUBROUTINE



SUBROUTINE REL_HIGHORDER_CI_IP(ORDER,NROOTS,NTRIALS)
! PERFORM HIGH-ORDER CONFIGURATION INTERACTION CALCULATIONS BY THE DAVIDSON'S ALGORITHM.

   USE CONSTANTS
   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER,PARAMETER :: MAXFILE = 1000
   INTEGER,PARAMETER :: MAXCYCLE = 1000
   INTEGER :: ICYCLE
   INTEGER :: ORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: NTRIALS_NEXT
   INTEGER :: IA,IB
   INTEGER :: I,J,K,L,NOPEN
   INTEGER,ALLOCATABLE :: N(:)
   REAL :: MEM,ICPUS,ICPUE
   LOGICAL :: LDONE(MAXFILE)
   DOUBLE PRECISION :: DEVSQ,DEVMAX,D,F,S2
   DOUBLE PRECISION :: SMALLH(MAXFILE,MAXFILE),LAMBDA(MAXFILE),ECI(MAXFILE)
   DOUBLE PRECISION :: W1(MAXFILE,MAXFILE),W2(MAXFILE)
   DOUBLE PRECISION :: PERCENTS,PERCENTD
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:)

   CALL PCPU_TIME(ICPUS)
   WRITE(6,'(A)') 'HIGH-ORDER IONIZATION CONFIGURATION INTERACTION CALCULATIONS WILL BE PERFORMED'
   WRITE(6,'(A,I2,A,I2,A)') 'CI ORDER IS ',ORDER,'-HOLE ',ORDER-1,'-PARTICLE'
   WRITE(6,'(A,I4)') 'THE NUMBER OF CI ROOTS SOUGHT ',NROOTS
   WRITE(6,'(A,I4)') 'THE NUMBER OF INITIAL TRIAL VECTORS ',NTRIALS
   MEM=16.0*2.0*NCF*IP_NCF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   IF (NROOTS > 1) THEN
    WRITE(6,'(A)') '--------------------------------------------------------'
    WRITE(6,'(A)') '             DEVIATION          TOTAL ENERGY   CPU / SEC'
   ELSE
    WRITE(6,'(A)') '-------------------------------------------------'
    WRITE(6,'(A)') 'ITR    DEVIATION         TOTAL ENERGY   CPU / SEC'
   ENDIF
   ALLOCATE(VEC1(IP_NCF,NCF),VEC2(IP_NCF,NCF),N(IALLMAX-IVIRTCORE))
   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fi1',FORM='UNFORMATTED')

   ! INITIALIZE
   LDONE=.FALSE.
   IF (NTRIALS > MAXFILE) CALL PABORT('TOO MANY INITIAL TRIAL VECTORS')

   ! DAVIDSON ITERATION
   DO ICYCLE=1,MAXCYCLE

    ! CALCULATE H|0> AND STORE IT IN FILE 70
    DEALLOCATE(VEC1,VEC2)
    DO I=1,NTRIALS
     IF (.NOT.LDONE(I)) THEN
      CALL REL_IP_HAMILTONIAN_PRODUCT(50,51,I-1,ORDER)
      LDONE(I)=.TRUE.
     ENDIF
    ENDDO
    ALLOCATE(VEC1(IP_NCF,NCF),VEC2(IP_NCF,NCF))

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|N> FOR DEBUG
!   WRITE(6,'(A)') 'SUBSPACE REPRESENTATION OF METRIC'
!   DO I=1,NTRIALS
!    REWIND(50)
!    DO J=1,I
!     READ(50) VEC1
!    ENDDO
!    REWIND(50)
!    DO L=1,NTRIALS
!     READ(50) VEC2
!     SMALLH(I,L)=0.0D0
!     DO IA=1,NCF
!      DO IB=1,IP_NCF
!       SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
!      ENDDO
!     ENDDO
!    ENDDO
!    WRITE(6,'(I3,100F10.5:)') I,(SMALLH(I,L),L=1,NTRIALS)
!   ENDDO

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|H|N>
    REWIND(50)
!   WRITE(6,'(A)') 'SUBSPACE REPRESENTATION OF HAMILTONIAN'
    DO I=1,NTRIALS
     READ(50) VEC1
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      SMALLH(I,L)=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
     ENDDO
!    WRITE(6,'(I3,100F10.5:)') I,(SMALLH(I,L),L=1,NTRIALS)
    ENDDO
      
    ! DIAGONALIZE SUBSPACE HAMILTONIAN
    IF (NTRIALS == 1) THEN
     LAMBDA(1)=SMALLH(1,1)
     W1(1,1)=1.0D0
    ELSE
     W1=SMALLH
     CALL TRED2(W1,NTRIALS,MAXFILE,LAMBDA,W2)
     CALL TQLI(LAMBDA,W2,NTRIALS,MAXFILE,W1)
     CALL PIKSRT(NTRIALS,MAXFILE,LAMBDA,W1,W2)
    ENDIF
      
    ! FORM RESIDUAL VECTORS
    CALL PCPU_TIME(ICPUE)
    DEVMAX=0.0D0
    IF (NROOTS > 1) WRITE(6,'(A,I3)') ' ITER ',ICYCLE
    NTRIALS_NEXT=NTRIALS
    DO K=1,NROOTS
     VEC1=0.0D0
     REWIND(50)
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      VEC1=VEC1+VEC2*W1(L,K)
      READ(50) VEC2
      VEC1=VEC1-LAMBDA(K)*VEC2*W1(L,K)
     ENDDO
     DEVSQ=0.0D0
     DO IA=1,NCF
      DO IB=1,IP_NCF
       DEVSQ=DEVSQ+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     DEVSQ=DSQRT(DEVSQ)
     IF (DEVSQ > DEVMAX) DEVMAX=DEVSQ
     ECI(K)=LAMBDA(K)+NUCLEAR_REPULSION
     IF (NROOTS == 1) THEN
      WRITE(6,'(I2,F15.10,F20.10,F12.1)') ICYCLE,DEVSQ,ECI(K),ICPUE-ICPUS
     ELSE
      WRITE(6,'(A,I3,F15.10,F20.10,F12.1)') ' ROOT ',K,DEVSQ,ECI(K),(ICPUE-ICPUS)/DFLOAT(NROOTS)
     ENDIF
      
     IF (DEVSQ < 1.0D-5) CYCLE

     ! FORM A NEW SUBSPACE VECTOR BY KNOWLES-HANDY SCHEME
     DO IA=1,NCF
      DO IB=1,IP_NCF
       NOPEN=0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        N(I)=0
        IF (BTEST(CFHALF(IA),I-1)) N(I)=1
        IF (BTEST(IP_CFHALF(IB),I-1)) N(I)=N(I)+1
        NOPEN=NOPEN+N(I)*(2-N(I))
       ENDDO
       IF ((NOPEN == 0).OR.(NOPEN == 1)) THEN
        F=0.0D0
       ELSE
        F=(3.0D0-DFLOAT(NOPEN))/DFLOAT(NOPEN*(NOPEN-1))
       ENDIF
       D=0.0D0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        D=D+DFLOAT(N(I))*H(I,I)-DFLOAT(N(I)*(2-N(I)))*G(I,I,I,I)/4.0D0
        DO J=1,IALL(0,0,0)-IVIRTCORE
         D=D+DFLOAT(N(I)*N(J))*(2.0D0*G(I,I,J,J)-G(I,J,J,I))/4.0D0
         IF (I /= J) D=D-F*DFLOAT(N(I)*(2-N(I))*N(J)*(2-N(J)))*G(I,J,J,I)/4.0D0
        ENDDO
       ENDDO
       IF ((LAMBDA(K)-D) /= 0.0D0) VEC1(IB,IA)=VEC1(IB,IA)/(LAMBDA(K)-D)
      ENDDO
     ENDDO
      
     ! ORTHONORMALIZE THE NEW SUBSPACE VECTOR
     REWIND(50)
     DO L=1,NTRIALS_NEXT
      READ(50) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        D=D+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
      VEC1=VEC1-D*VEC2
     ENDDO
     D=0.0D0
     DO IA=1,NCF
      DO IB=1,IP_NCF
       D=D+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     D=DSQRT(D)
     IF (D > 1.0D-8) THEN
      VEC1=VEC1/D
      NTRIALS_NEXT=NTRIALS_NEXT+1
      IF (NTRIALS_NEXT > MAXFILE) CALL PABORT('TOO MANY TRIAL VECTORS')
      REWIND(50)
      DO L=1,NTRIALS_NEXT-1
       READ(50) VEC2
      ENDDO
      WRITE(50) VEC1
     ENDIF

    ENDDO

    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    IF (DEVMAX < 1.0D-5) THEN
     IF (NROOTS > 1) THEN
      WRITE(6,'(A)') '--------------------------------------------------------'
     ELSE
      WRITE(6,'(A)') '-------------------------------------------------'
     ENDIF
     REWIND(51)
     DO I=1,NROOTS
      WRITE(6,'(A,I3,F20.15,A)') 'ROOT ',I,ECI(I),' HARTREE'
      REWIND(50)
      VEC1=0.0D0
      DO L=1,NTRIALS
       READ(50) VEC2
       VEC1=VEC1+VEC2*W1(L,I)
      ENDDO
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        D=D+VEC1(IB,IA)**2
       ENDDO
      ENDDO
      VEC1=VEC1/DSQRT(D)
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        IF (NORDER(IA)+IP_NORDER(IB) == 1) PERCENTS=PERCENTS+VEC1(IB,IA)**2
        IF (NORDER(IA)+IP_NORDER(IB) == 2) PERCENTD=PERCENTD+VEC1(IB,IA)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES = ',PERCENTD*1.0D2
      WRITE(51) VEC1
      CALL REL_S_SQUARED_IP(51,I-1,ORDER,S2)
      WRITE(6,'(A,F8.4)') ' < S**2 > = ',S2
      DO IA=1,NCF
       DO IB=1,IP_NCF
        IF (DABS(VEC1(IB,IA)) > 0.1D0) WRITE(6,'(A,I6,A,I6,A,F8.4)') ' DETERMINANT (',IA,'-ALPHA ',IB,'-BETA ) ',VEC1(IB,IA)
       ENDDO
      ENDDO
     ENDDO
!    REWIND(50)
!    REWIND(51)
!    DO I=1,NROOTS
!     READ(51) VEC1
!     WRITE(50) VEC1
!    ENDDO
     DEALLOCATE(VEC1,VEC2,N)
     CLOSE(50)
     CLOSE(51)
     RETURN
    ELSE IF (NTRIALS_NEXT == NTRIALS) THEN
     CALL PABORT('ALGORITHM FAILED TO INCREASE THE SUBSPACE')
    ELSE IF (NROOTS > 1) THEN
     WRITE(6,'(I3,A)') NTRIALS_NEXT-NTRIALS,' TRIAL VECTORS HAVE BEEN ADDED'
    ENDIF
    NTRIALS=NTRIALS_NEXT

   ENDDO
   CALL PABORT('DAVIDSON ALGORITHM FAILED TO CONVERGE')

END SUBROUTINE



SUBROUTINE REL_IP_EXPONENTIAL_OPERATOR(TFILE,INFILE,OUTFILE,ORDER,LMINUS)
! OPERATE WITH AN EXPONENTIAL OPERATOR ON ANY GIVEN (N-1)-ELECTRON WAVEFUNCTION.  
! THE T-AMPLITUDES ARE STORED IN TFILE, THE WAVEFUNCTION ON WHICH THE EXPONENTIAL OPERATOR ACTS IS 
! IN INFILE, AND THE EXPONENTIAL WAVEFUNCTION IS IN OUTFILE.  IF LMINUS=.TRUE.
! THE OPERATOR IS EXP(-T), OTHERWISE, EXP(T).  NOTE THAT THE T-AMPLITUDES ARE PREDETERMINED
! FOR THE CLOSED SHELL (N)-ELECTRON SYSTEM, BUT THE WAVEFUNCTION UPON WHICH EXP(T) OPERATES
! IS (N-1)-ELECTRON ONE.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL :: LMINUS
   LOGICAL :: LCYCLE
   INTEGER :: TFILE,INFILE,OUTFILE
   INTEGER :: ORDER
   INTEGER :: I,J,IPOWER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: HOLEA(ORDER),HOLEB(ORDER),PARTA(ORDER),PARTB(ORDER)
   INTEGER :: KSIGN(0:MIN(IOCC,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1)),ISIGN,JSIGN
   INTEGER(4) :: CFALPH,CFBETA
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:),VEC3(:,:)
   INTEGER,ALLOCATABLE :: AD1(:),IP_AD2(:),SN1(:),IP_SN2(:)
   LOGICAL,ALLOCATABLE :: LC1(:),IP_LC2(:)

   ALLOCATE(VEC1(NCF,NCF),VEC2(IP_NCF,NCF),VEC3(IP_NCF,NCF))
   ALLOCATE(AD1(NCF),IP_AD2(IP_NCF),SN1(NCF),IP_SN2(IP_NCF),LC1(NCF),IP_LC2(IP_NCF))

   ! SIGNS ASSOCIATED WITH THE PERMUTATION OF THE CLUSTER OPERATORS
   DO I=0,MIN(IOCC,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1)
    KSIGN(I)=(-1)**((I*(I-1))/2)
   ENDDO

   ! RETRIEVE T-AMPLITUDES FROM FILE
   REWIND(TFILE)
   READ(TFILE) VEC1
   IF (LMINUS) VEC1=-VEC1
   ! RETRIEVE INITIAL WAVEFUNCTION FROM FILE
   REWIND(INFILE)
   READ(INFILE) VEC2
   ! INITIALIZE OUTFILE WITH THE INITIAL WAVEFUNCTION
   REWIND(OUTFILE)
   WRITE(OUTFILE) VEC2

   ! LOOP OVER THE POWER
   DO IPOWER=1,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1)
    VEC3=0.0D0

    ! LOOP OVER ALPHA T-AMPLITUDE
    DO IA=1,NCF
     IF (NORDER(IA) > ORDER) CYCLE
     J=0
     DO I=1,IOCC
      IF (.NOT.BTEST(CFHALF(IA),I-1)) THEN
       J=J+1
       HOLEA(J)=I
      ENDIF
     ENDDO
     J=0
     DO I=IOCC+1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFHALF(IA),I-1)) THEN
       J=J+1
       PARTA(J)=I
      ENDIF
     ENDDO

     ! LOOP OVER ALPHA CONFIGURATIONS
     DO IC=1,NCF
      LCYCLE=.FALSE.
      CFALPH=CFHALF(IC)
      DO I=1,NORDER(IA)
       IF (.NOT.BTEST(CFALPH,HOLEA(I)-1)) LCYCLE=.TRUE.
       IF (BTEST(CFALPH,PARTA(I)-1)) LCYCLE=.TRUE.
      ENDDO
      LC1(IC)=LCYCLE
      IF (LCYCLE) CYCLE
      ISIGN=1
      DO I=1,NORDER(IA)
       IF (HOLEA(I) /= 1) THEN
        DO J=1,HOLEA(I)-1
         IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
        ENDDO
       ENDIF
       CFALPH=IBCLR(CFALPH,HOLEA(I)-1)
      ENDDO
      DO I=1,NORDER(IA)
       DO J=1,PARTA(I)-1
        IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
       ENDDO
       CFALPH=IBSET(CFALPH,PARTA(I)-1)
      ENDDO
      AD1(IC)=ADDRSS(CFALPH)
      SN1(IC)=ISIGN*KSIGN(NORDER(IA))
     ENDDO

     ! LOOP OVER BETA T-AMPLITUDE
     DO IB=1,NCF
      IF (NORDER(IA)+NORDER(IB) > ORDER) CYCLE
      IF (DABS(VEC1(IB,IA)) < 1.0D-15) CYCLE
      J=0
      DO I=1,IOCC
       IF (.NOT.BTEST(CFHALF(IB),I-1)) THEN
        J=J+1
        HOLEB(J)=I
       ENDIF
      ENDDO
      J=0
      DO I=IOCC+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IB),I-1)) THEN
        J=J+1
        PARTB(J)=I
       ENDIF
      ENDDO

      ! LOOP OVER BETA CONFIGURATIONS
      DO ID=1,IP_NCF
       LCYCLE=.FALSE.
       CFBETA=IP_CFHALF(ID)
       DO I=1,NORDER(IB)
        IF (.NOT.BTEST(CFBETA,HOLEB(I)-1)) LCYCLE=.TRUE.
        IF (BTEST(CFBETA,PARTB(I)-1)) LCYCLE=.TRUE.
       ENDDO
       IP_LC2(ID)=LCYCLE
       IF (LCYCLE) CYCLE
       JSIGN=1
       DO I=1,NORDER(IB)
        IF (HOLEB(I) /= 1) THEN
         DO J=1,HOLEB(I)-1
          IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
         ENDDO
        ENDIF
        CFBETA=IBCLR(CFBETA,HOLEB(I)-1)
       ENDDO
       DO I=1,NORDER(IB)
        DO J=1,PARTB(I)-1
         IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
        ENDDO
        CFBETA=IBSET(CFBETA,PARTB(I)-1)
       ENDDO
       IP_AD2(ID)=IP_ADDRSS(CFBETA)
       IP_SN2(ID)=JSIGN*KSIGN(NORDER(IB))
      ENDDO

      ! LOOP OVER ALPHA CONFIGURATIONS
      DO IC=1,NCF
       IF (LC1(IC)) CYCLE
       ! LOOP OVER BETA CONFIGURATIONS
       DO ID=1,IP_NCF
        IF (IP_LC2(ID)) CYCLE
        IF (DABS(VEC2(ID,IC)) < 1.0D-15) CYCLE
        VEC3(IP_AD2(ID),AD1(IC))=VEC3(IP_AD2(ID),AD1(IC))+DFLOAT(IP_SN2(ID)*SN1(IC))*VEC1(IB,IA)*VEC2(ID,IC)
       ENDDO
      ENDDO

     ENDDO
    ENDDO
    ! AT THIS POINT, VEC3 CONTAINS T TO THE POWER OF IPOWER.  VEC3 IS COPIED TO VEC2 FOR NEXT ITERATION,
    ! AND VEC3 IS ADDED TO THE VECTOR STORED IN 91.
    VEC3=VEC3/DFLOAT(IPOWER)
    REWIND(OUTFILE)
    READ(OUTFILE) VEC2
    VEC2=VEC2+VEC3
    REWIND(OUTFILE)
    WRITE(OUTFILE) VEC2
    VEC2=VEC3
   ENDDO
   
   DEALLOCATE(VEC1,VEC2,VEC3)
   DEALLOCATE(AD1,IP_AD2,SN1,IP_SN2,LC1,IP_LC2)

   RETURN
END SUBROUTINE



SUBROUTINE REL_FULL_IP_EFF_H(TORDER,RORDER)
! FORM FULL EFFECTIVE HAMILTONIAN EXP(-T)HEXP(T) AND DIAGONALIZE IT BY LINPACK/LAPACK/BLAS SUBROUTINES.
! CAUTION, DO NOT USE THIS FOR PRODUCTION RUN.  THE ORDER OF CLUSTER EXPANSION SHOULD BE GIVEN BY TORDER
! AND THE CORRESPONDING T-AMPLITUDES MUST BE PROVIDED IN FILE 90.  THE ORDER OF LINEAR OPERATOR SHOULD BE
! GIVEN BY RORDER.  IONIZATION POTENTIAL CALCULATIONS.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL,PARAMETER :: LEVEC = .FALSE.
   INTEGER :: RORDER,TORDER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: INFO
   REAL :: MEM,DEV
   DOUBLE PRECISION,ALLOCATABLE :: HAM(:,:),VL(:,:),VR(:,:),ER(:),EI(:),WK(:)
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:)

   WRITE(6,'(A)') 'IONIZATION-POTENTIAL EQUATION-OF-MOTION COUPLED CLUSTER CALCULATION FOR ALL STATES'
   WRITE(6,'(I2,A)') TORDER,'-ORDER COUPLED CLUSTER SIMILARITY TRANSFORMATION'
   WRITE(6,'(I2,A,I2,A)') RORDER,'-HOLE ',RORDER-1,'-PARTICLE LINEAR EXCITATION OPERATOR'
   IF (LEVEC) THEN
    MEM=16.0*(2.0D0*(NCF*IP_NCF)**2+8.0*NCF*IP_NCF)
   ELSE
    MEM=16.0*((NCF*IP_NCF)**2+9.0*NCF*IP_NCF)
   ENDIF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
    ALLOCATE(HAM(NCF*IP_NCF,NCF*IP_NCF),VL(1,NCF*IP_NCF),ER(NCF*IP_NCF),EI(NCF*IP_NCF),WK(4*NCF*IP_NCF))
   IF (LEVEC) THEN
    ALLOCATE(VR(NCF*IP_NCF,NCF*IP_NCF))
   ELSE
    ALLOCATE(VR(1,NCF*IP_NCF))
   ENDIF
   ALLOCATE(TRL(IP_NCF,NCF))

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')
   OPEN(90,FILE=TRIM(COPTN(1))//'.fq0',FORM='UNFORMATTED')

   ! FORM HAMILTONIAN AND KEEP IT IN MEMORY
   HAM=0.0D0
   DO IA=1,NCF
    DO IB=1,IP_NCF
     TRL=0.0D0
     IF (NORDER(IA)+IP_NORDER(IB) <= RORDER) TRL(IB,IA)=1.0D0
     ! |B>=EXP(T)|A>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_IP_EXPONENTIAL_OPERATOR(90,50,60,TORDER,.FALSE.)
     REWIND(60)
     READ(60) TRL
     ! |C>=H|B>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_IP_HAMILTONIAN_PRODUCT(50,60,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1))
     REWIND(60)
     READ(60) TRL
     ! |D>=EXP(-T)|C>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_IP_EXPONENTIAL_OPERATOR(90,50,60,TORDER,.TRUE.)
     REWIND(60)
     READ(60) TRL
     DO IC=1,NCF
      DO ID=1,IP_NCF
       HAM((IA-1)*IP_NCF+IB,(IC-1)*IP_NCF+ID)=TRL(ID,IC)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
!  CALL DUMP5(HAM,NCF*IP_NCF)

   DEALLOCATE(TRL)
   CLOSE(50)
   CLOSE(60)
   CLOSE(90)

   ! DIAGONALIZE HAMILTONIAN
   IF (LEVEC) THEN
    CALL DGEEV('N','V',NCF*IP_NCF,HAM,NCF*IP_NCF,ER,EI,VL,1,VR,NCF*IP_NCF,WK,4*NCF*IP_NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF*IP_NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT(NCF*IP_NCF,NCF*IP_NCF,ER,VR,EI)
    DO IA=1,MIN(25,NCF*IP_NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
     DO IB=1,NCF*IP_NCF
      WRITE(6,'(I10,F20.15)') IB,VR(IB,IA)
     ENDDO
    ENDDO
   ELSE
    CALL DGEEV('N','N',NCF*IP_NCF,HAM,NCF*IP_NCF,ER,EI,VL,1,VR,1,WK,4*NCF*IP_NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF*IP_NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT_EVALONLY(NCF*IP_NCF,ER)
    DO IA=1,MIN(25,NCF*IP_NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
    ENDDO
   ENDIF
   CALL PFLUSH(6)

   DEALLOCATE(HAM,ER,EI,VL,VR,WK)

   RETURN
END SUBROUTINE



SUBROUTINE REL_EOMIPCC(TORDER,RORDER,NROOTS,NTRIALS)
! PERFORM HIGH-ORDER IONIZATION POTENTIAL EQUATION-OF-MOTION COUPLED CLUSTER CALCULATIONS BY HIRAO-NAKATSUJI ALGORITHM.
! K.HIRAO & H.NAKATSUJI,J.COMPUT.PHYS.45,246(1982).

   USE CONSTANTS
   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER,PARAMETER :: MAXFILE = 1000
   INTEGER,PARAMETER :: MAXCYCLE = 1000
   INTEGER :: ICYCLE
   INTEGER :: TORDER
   INTEGER :: RORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: NTRIALS_NEXT
   INTEGER :: IA,IB
   INTEGER :: I,J,K,L,NOPEN
   INTEGER :: INFO
   INTEGER,ALLOCATABLE :: N(:)
   REAL :: MEM,ICPUS,ICPUE
   LOGICAL :: LDONE(MAXFILE)
   DOUBLE PRECISION :: DEVSQ,DEVMAX,D,F,S2
   DOUBLE PRECISION :: SMALLH(MAXFILE,MAXFILE),EEOMCC(MAXFILE)
   DOUBLE PRECISION :: VR(MAXFILE,MAXFILE),VL(1,MAXFILE),ER(MAXFILE),EI(MAXFILE),WK(4*MAXFILE)
   DOUBLE PRECISION :: PERCENTS,PERCENTD
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:)

   CALL PCPU_TIME(ICPUS)
   WRITE(6,'(A)') 'HIGH-ORDER IONIZATION-POTENTIAL EQUATION-OF-MOTION COUPLED CLUSTER CALCULATIONS WILL BE PERFORMED'
   WRITE(6,'(A,I2)') 'THE ORDER OF COUPLED CLUSTER            = ',TORDER
   WRITE(6,'(A,I2,A,I2,A)') 'THE ORDER OF IONIZATION OPERATOR = ',RORDER,'-HOLE ',RORDER-1,'-PARTICLE'
   WRITE(6,'(A,I4)') 'THE NUMBER OF IPEOMCC ROOTS SOUGHT ',NROOTS
   WRITE(6,'(A,I4)') 'THE NUMBER OF INITIAL TRIAL VECTORS ',NTRIALS
   MEM=16.0*2.0*NCF*IP_NCF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   WRITE(6,'(A)') '--------------------------------------------------------'
   WRITE(6,'(A)') '             DEVIATION          TOTAL ENERGY   CPU / SEC'
   ALLOCATE(VEC1(IP_NCF,NCF),VEC2(IP_NCF,NCF),N(IALLMAX-IVIRTCORE))
   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fw0',FORM='UNFORMATTED')
   OPEN(61,FILE=TRIM(COPTN(1))//'.fw1',FORM='UNFORMATTED')
   OPEN(90,FILE=TRIM(COPTN(1))//'.fq0',FORM='UNFORMATTED')

   ! INITIALIZE
   LDONE=.FALSE.
   IF (NTRIALS > MAXFILE) CALL PABORT('TOO MANY INITIAL TRIAL VECTORS')

   ! HIRAO-NAKATSUJI ITERATION
   DO ICYCLE=1,MAXCYCLE

    ! FORM EXP(-T) H EXP(T)|A> AND STORE THEM IN FILE 51
    REWIND(50)
    REWIND(51)
    DO I=1,NTRIALS
     READ(50) VEC1 ! RETRIEVE A TRIAL VECTOR
     IF (.NOT.LDONE(I)) THEN
      ! |B>=EXP(T)|A>
      REWIND(60)
      WRITE(60) VEC1
      CALL REL_IP_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.FALSE.)
      REWIND(61)
      READ(61) VEC1
      ! |C>=H|B>
      REWIND(60)
      WRITE(60) VEC1
      DEALLOCATE(VEC1,VEC2)
      CALL REL_IP_HAMILTONIAN_PRODUCT(60,61,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1))
      ALLOCATE(VEC1(IP_NCF,NCF),VEC2(IP_NCF,NCF))
      REWIND(61)
      READ(61) VEC1
      ! |D>=EXP(-T)|C>
      REWIND(60)
      WRITE(60) VEC1
      CALL REL_IP_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.TRUE.)
      REWIND(61)
      READ(61) VEC1
      WRITE(51) VEC1
      LDONE(I)=.TRUE.
     ELSE
      READ(51) VEC2 ! DUMMY READING
     ENDIF
    ENDDO

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|N> FOR DEBUG
!   DO I=1,NTRIALS
!    REWIND(50)
!    DO J=1,I
!     READ(50) VEC1
!    ENDDO
!    REWIND(50)
!    DO L=1,NTRIALS
!     READ(50) VEC2
!     SMALLH(I,L)=0.0D0
!     DO IA=1,NCF
!      DO IB=1,IP_NCF
!       SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
!      ENDDO
!     ENDDO
!    ENDDO
!   ENDDO
!   CALL DUMP10(SMALLH,NTRIALS,MAXFILE)

    ! FOR DEBUG
!   REWIND(50)
!   REWIND(51)
!   DO I=1,NTRIALS
!    READ(50) VEC1
!    READ(51) VEC2
!    WRITE(6,'(I3,A)') I," TRIAL VECTOR, PRODUCT VECTOR"
!    DO IA=1,NCF
!     DO IB=1,IP_NCF
!      WRITE(6,'(2I3,2F20.15)') IA,IB,VEC1(IB,IA),VEC2(IB,IA)
!     ENDDO
!    ENDDO
!   ENDDO

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|H|N>
    REWIND(50)
    DO I=1,NTRIALS
     READ(50) VEC1
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      SMALLH(I,L)=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
    CALL DUMP10(SMALLH,NTRIALS,MAXFILE)
      
    ! DIAGONALIZE SUBSPACE HAMILTONIAN
    IF (NTRIALS == 1) THEN
     ER(1)=SMALLH(1,1)
     VR(1,1)=1.0D0
    ELSE
     CALL DGEEV('N','V',NTRIALS,SMALLH,MAXFILE,ER,EI,VL,1,VR,MAXFILE,WK,4*MAXFILE,INFO)
     IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
     CALL PIKSRT(NTRIALS,MAXFILE,ER,VR,EI)
    ENDIF
!   DO I=1,NTRIALS
!    WRITE(6,'(A,I2,A,F20.15)') 'ROOT ',I,' = ',ER(I)+NUCLEAR_REPULSION
!   ENDDO
      
    ! FORM RESIDUAL VECTORS
    CALL PCPU_TIME(ICPUE)
    DEVMAX=0.0D0
    WRITE(6,'(A,I3)') ' ITER ',ICYCLE
    NTRIALS_NEXT=NTRIALS
    DO K=1,NROOTS
     VEC1=0.0D0
     REWIND(50)
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      VEC1=VEC1+VEC2*VR(L,K)
      READ(50) VEC2
      VEC1=VEC1-ER(K)*VEC2*VR(L,K)
     ENDDO
     DEVSQ=0.0D0
     DO IA=1,NCF
      DO IB=1,IP_NCF
       IF (NORDER(IA)+IP_NORDER(IB) > RORDER) VEC1(IB,IA)=0.0D0
       DEVSQ=DEVSQ+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     DEVSQ=DSQRT(DEVSQ)
     IF (DEVSQ > DEVMAX) DEVMAX=DEVSQ
     EEOMCC(K)=ER(K)+NUCLEAR_REPULSION
     WRITE(6,'(A,I3,F15.10,F20.10,F12.1)') ' ROOT ',K,DEVSQ,EEOMCC(K),(ICPUE-ICPUS)/DFLOAT(NROOTS)
      
     IF (DEVSQ < 1.0D-9) CYCLE

     ! FORM A NEW SUBSPACE VECTOR BY HIRAO-NAKATSUJI SCHEME
     DO IA=1,NCF
      DO IB=1,IP_NCF
       NOPEN=0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        N(I)=0
        IF (BTEST(CFHALF(IA),I-1)) N(I)=1
        IF (BTEST(IP_CFHALF(IB),I-1)) N(I)=N(I)+1
        NOPEN=NOPEN+N(I)*(2-N(I))
       ENDDO
       IF ((NOPEN == 0).OR.(NOPEN == 1)) THEN
        F=0.0D0
       ELSE
        F=(3.0D0-DFLOAT(NOPEN))/DFLOAT(NOPEN*(NOPEN-1))
       ENDIF
       D=0.0D0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        D=D+DFLOAT(N(I))*H(I,I)-DFLOAT(N(I)*(2-N(I)))*G(I,I,I,I)/4.0D0
        DO J=1,IALL(0,0,0)-IVIRTCORE
         D=D+DFLOAT(N(I)*N(J))*(2.0D0*G(I,I,J,J)-G(I,J,J,I))/4.0D0
         IF (I /= J) D=D-F*DFLOAT(N(I)*(2-N(I))*N(J)*(2-N(J)))*G(I,J,J,I)/4.0D0
        ENDDO
       ENDDO
       IF ((ER(K)-D) /= 0.0D0) VEC1(IB,IA)=VEC1(IB,IA)/(ER(K)-D)
      ENDDO
     ENDDO
      
     ! ORTHONORMALIZE THE NEW SUBSPACE VECTOR
     REWIND(50)
     DO L=1,NTRIALS_NEXT
      READ(50) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        D=D+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
      VEC1=VEC1-D*VEC2
     ENDDO
     D=0.0D0
     DO IA=1,NCF
      DO IB=1,IP_NCF
       D=D+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     D=DSQRT(D)
     IF (D > 1.0D-8) THEN
      VEC1=VEC1/D
      NTRIALS_NEXT=NTRIALS_NEXT+1
      IF (NTRIALS_NEXT > MAXFILE) CALL PABORT('TOO MANY TRIAL VECTORS')
      REWIND(50)
      DO L=1,NTRIALS_NEXT-1
       READ(50) VEC2
      ENDDO
      WRITE(50) VEC1
     ENDIF

    ENDDO

    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    IF (DEVMAX < 1.0D-9) THEN
     WRITE(6,'(A)') '--------------------------------------------------------'
!    REWIND(51)
     DO I=1,NROOTS
      WRITE(6,'(A,I3,F20.15,A)') 'ROOT ',I,EEOMCC(I),' HARTREE'
      REWIND(50)
      VEC1=0.0D0
      DO L=1,NTRIALS
       READ(50) VEC2
       VEC1=VEC1+VEC2*VR(L,I)
      ENDDO
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        D=D+VEC1(IB,IA)**2
       ENDDO
      ENDDO
      VEC1=VEC1/DSQRT(D)
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        IF (NORDER(IA)+IP_NORDER(IB) == 1) PERCENTS=PERCENTS+VEC1(IB,IA)**2
        IF (NORDER(IA)+IP_NORDER(IB) == 2) PERCENTD=PERCENTD+VEC1(IB,IA)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES (CC) = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES (CC) = ',PERCENTD*1.0D2
!     WRITE(51) VEC1
      REWIND(60)
      WRITE(60) VEC1
      CALL REL_IP_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.FALSE.)
      CALL REL_S_SQUARED_IP(61,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE+1),S2)
      WRITE(6,'(A,F8.4)') ' < S**2 > = ',S2
      REWIND(61)
      READ(61) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        D=D+VEC2(IB,IA)**2
       ENDDO
      ENDDO
      VEC2=VEC2/DSQRT(D)
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,IP_NCF
        IF (NORDER(IA)+IP_NORDER(IB) == 1) PERCENTS=PERCENTS+VEC2(IB,IA)**2
        IF (NORDER(IA)+IP_NORDER(IB) == 2) PERCENTD=PERCENTD+VEC2(IB,IA)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES (CI) = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES (CI) = ',PERCENTD*1.0D2
      DO IA=1,NCF
       DO IB=1,IP_NCF
        IF (DABS(VEC1(IB,IA)) > 0.1D0) WRITE(6,'(A,I6,A,I6,A,F8.4)') &
        ' EFFFECTIVE DETERMINANT (',IA,'-ALPHA ',IB,'-BETA ) ',VEC1(IB,IA)
       ENDDO
      ENDDO
     ENDDO
!    REWIND(50)
!    REWIND(51)
!    DO I=1,NROOTS
!     READ(51) VEC1
!     WRITE(50) VEC1
!    ENDDO
     DEALLOCATE(VEC1,VEC2,N)
     CLOSE(50)
     CLOSE(51)
     CLOSE(60)
     CLOSE(61)
     CLOSE(90)
     RETURN
    ELSE IF (NTRIALS_NEXT == NTRIALS) THEN
     CALL PABORT('ALGORITHM FAILED TO INCREASE THE SUBSPACE')
    ELSE IF (NROOTS > 1) THEN
     WRITE(6,'(I3,A)') NTRIALS_NEXT-NTRIALS,' TRIAL VECTORS HAVE BEEN ADDED'
    ENDIF
    NTRIALS=NTRIALS_NEXT

   ENDDO
   CALL PABORT('HIRAO-NAKATSUJI ALGORITHM FAILED TO CONVERGE')

END SUBROUTINE



SUBROUTINE REL_S_SQUARED_IP(INFILE,OFFSET,ORDER,S2)
! OPERATE WITH S**2 = S+ S- - SZ + SZ**2 A INPUT VECTOR IN INFILE
! AND INTEGRATE WITH ITSELF TO GET AN EXPECTATION VALUE OF S**2.  
! THE ORDER LIMITS THE NUMBER EXCITATION IN THE CONFIGURATIONS CONSIDERED.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: INFILE,OFFSET
   INTEGER :: ORDER
   INTEGER :: ISIGN,JSIGN
   INTEGER :: I,J,K
   INTEGER :: IA,IB,IC,ID
   INTEGER(4) :: CFA0,CFB0,CFA1,CFB1,CFA2,CFB2
   REAL :: MEM
   DOUBLE PRECISION :: S2,NORM
   DOUBLE PRECISION,ALLOCATABLE :: INP(:,:),OUT(:,:)

!  CALL PCPU_TIME(ICPUS)
   MEM=16.0*2.0*NCF*IP_NCF+4.0*2.0*NCF*(IALL(0,0,0)-IVIRTCORE)**2
!  IF (MEM > 1000000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
!  ELSE IF (MEM > 1000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
!  ELSE
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
!  ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 

   ALLOCATE(INP(IP_NCF,NCF),OUT(IP_NCF,NCF))

   ! READ INPUT VECTOR FROM FILE INFILE
   REWIND(INFILE)
   DO I=0,OFFSET
    READ(INFILE) INP
   ENDDO

   ! ZERO SCRATCH INPUT VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   NORM=0.0D0
   DO IA=1,NCF
    DO IB=1,IP_NCF
     IF (NORDER(IA)+IP_NORDER(IB) > ORDER) INP(IB,IA)=0.0D0
     NORM=NORM+INP(IB,IA)**2
    ENDDO
   ENDDO

   ! ZERO SCRATCH OUTPUT VECTOR
   OUT=0.0D0

   ! S+ S-
   DO IA=1,NCF
    DO IB=1,IP_NCF
     CFA0=CFHALF(IA)
     CFB0=IP_CFHALF(IB)
     ! OPERATE WITH S-
     DO I=1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFA0,I-1).AND.(.NOT.BTEST(CFB0,I-1))) THEN
       CFA1=IBCLR(CFA0,I-1)
       CFB1=IBSET(CFB0,I-1)
       ISIGN=1
       DO J=1,I
        IF (BTEST(CFA0,J-1)) ISIGN=-ISIGN
        IF (BTEST(CFB1,J-1)) ISIGN=-ISIGN
       ENDDO
       ! OPERATE WITH S+
       DO J=1,IALL(0,0,0)-IVIRTCORE
        IF ((.NOT.BTEST(CFA1,J-1)).AND.BTEST(CFB1,J-1)) THEN
         CFA2=IBSET(CFA1,J-1)
         CFB2=IBCLR(CFB1,J-1)
         JSIGN=1
         DO K=1,J
          IF (BTEST(CFA2,K-1)) JSIGN=-JSIGN
          IF (BTEST(CFB1,K-1)) JSIGN=-JSIGN
         ENDDO
         IC=ADDRSS(CFA2)
         ID=IP_ADDRSS(CFB2)
         OUT(ID,IC)=OUT(ID,IC)+DFLOAT(ISIGN*JSIGN)*INP(IB,IA)
        ENDIF
       ENDDO
      ENDIF
     ENDDO
    ENDDO
   ENDDO

   ! SZ ( SZ-1 )
   DO IA=1,NCF
    DO IB=1,IP_NCF
     OUT(IB,IA)=OUT(IB,IA)-(1.0D0/4.0D0)*INP(IB,IA)
    ENDDO
   ENDDO

   S2=0.0D0
   DO IA=1,NCF
    DO IB=1,IP_NCF
     IF (NORDER(IA)+IP_NORDER(IB) > ORDER) CYCLE
     S2=S2+INP(IB,IA)*OUT(IB,IA)/NORM
    ENDDO
   ENDDO

   DEALLOCATE(INP,OUT)

   RETURN
END SUBROUTINE



SUBROUTINE REL_GENERATE_EA_CONFIGURATIONS(ORDER)
! GENERATE CONFIGURATIONS FOR (N+1) ALPHA ELECTRONS

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: ORDER
   INTEGER :: I,J,K,L,M
   INTEGER :: I1,I2,I3,I4,I5,I6,I7,I8
   INTEGER(4) :: ICF
   INTEGER :: COMBINATION
   REAL :: MEM
   
   WRITE(6,'(A,I3,A,I3,A)') 'GENERATE AND ORDER CONFIGURATIONS FOR BETA ELECTRONS UP TO ',&
   ORDER-1,'-HOLE ',ORDER,'-PARTICLE EXCITATIONS'
   IF (ICORE > 0) WRITE(6,'(A,I3,A)') '***** WARNING : ',ICORE,' CORE BETA ORBITALS ARE ALWAYS OCCUPIED'
   IF (IVIRTCORE > 0) WRITE(6,'(A,I3,A)') '***** WARNING : ',IVIRTCORE,' HIGHEST VIRTUAL BETA ORBITALS ARE ALWAYS UNOCCUPIED'
   WRITE(6,'(A,I3,A,I3,A)') 'THERE ARE ',IOCC-ICORE+1,' ACTIVE BETA ELECTRONS IN ',IALL(0,0,0)-ICORE-IVIRTCORE,' ACTIVE ORBITALS'
   MEM=4.0*2**(IALL(0,0,0)-IVIRTCORE)
   IF (MEM > 1000000.0) WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE FOR THE BETA STRINGS WILL BE ',MEM/1000000.0,' MB'  
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY')
   EA_NCF=0
   DO I=1,ORDER
    J=COMBINATION(IOCC-ICORE,I-1)*COMBINATION(IALL(0,0,0)-IOCC-IVIRTCORE,I)
    WRITE(6,'(I4,A,I3,A,I7)') I-1,'-HOLE ',I,'-PARTICLE EXCITATIONS ',J
    EA_NCF=EA_NCF+J
   ENDDO
   WRITE(6,'(A,I7)') '    TOTAL BETA CONFIGURATIONS ',EA_NCF
   IF (EA_NCF /= COMBINATION(IALL(0,0,0)-ICORE-IVIRTCORE,IOCC-ICORE+1)) CALL PABORT('AN ERROR OCCURRED IN COMBINATION FUNCTION')

   ALLOCATE(EA_CFHALF(EA_NCF),EA_NORDER(EA_NCF),EA_ADDRSS(2**(IALLMAX-IVIRTCORE)))
   EA_ADDRSS=0
   I=0
   IF (IOCC == 1) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-1
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE
      J=0
      IF (I1 <= ICORE) J=J+1
      IF (I2 <= ICORE) J=J+1
      IF (J /= ICORE) CYCLE
      J=IOCC+1
      IF (I1 <= IOCC) J=J-1
      IF (I2 <= IOCC) J=J-1
      IF (J > ORDER) CYCLE
      ICF=0
      ICF=IBSET(ICF,I1-1) 
      ICF=IBSET(ICF,I2-1) 
      I=I+1
      EA_CFHALF(I)=ICF
      EA_NORDER(I)=J
      EA_ADDRSS(ICF)=I
      IF (EA_NORDER(I) <= 3) THEN
       K=0
       DO L=0,IALL(0,0,0)-IVIRTCORE-1
        IF (BTEST(ICF,L)) K=K+10**L
        IF (BTEST(ICF,L)) M=L
       ENDDO
       IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' PARTICLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
      ENDIF
     ENDDO
    ENDDO
   ELSE IF (IOCC == 2) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-2
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-1
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE
       J=0
       IF (I1 <= ICORE) J=J+1
       IF (I2 <= ICORE) J=J+1
       IF (I3 <= ICORE) J=J+1
       IF (J /= ICORE) CYCLE
       J=IOCC+1
       IF (I1 <= IOCC) J=J-1
       IF (I2 <= IOCC) J=J-1
       IF (I3 <= IOCC) J=J-1
       IF (J > ORDER) CYCLE
       ICF=0
       ICF=IBSET(ICF,I1-1) 
       ICF=IBSET(ICF,I2-1) 
       ICF=IBSET(ICF,I3-1) 
       I=I+1
       EA_CFHALF(I)=ICF
       EA_NORDER(I)=J
       EA_ADDRSS(ICF)=I
       IF (EA_NORDER(I) <= 3) THEN
        K=0
        DO L=0,IALL(0,0,0)-IVIRTCORE-1
         IF (BTEST(ICF,L)) K=K+10**L
         IF (BTEST(ICF,L)) M=L
        ENDDO
        IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' PARTICLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
       ENDIF
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 3) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-3
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-2
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-1
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE
        J=0
        IF (I1 <= ICORE) J=J+1
        IF (I2 <= ICORE) J=J+1
        IF (I3 <= ICORE) J=J+1
        IF (I4 <= ICORE) J=J+1
        IF (J /= ICORE) CYCLE
        J=IOCC+1
        IF (I1 <= IOCC) J=J-1
        IF (I2 <= IOCC) J=J-1
        IF (I3 <= IOCC) J=J-1
        IF (I4 <= IOCC) J=J-1
        IF (J > ORDER) CYCLE
        ICF=0
        ICF=IBSET(ICF,I1-1) 
        ICF=IBSET(ICF,I2-1) 
        ICF=IBSET(ICF,I3-1) 
        ICF=IBSET(ICF,I4-1) 
        I=I+1
        EA_CFHALF(I)=ICF
        EA_NORDER(I)=J
        EA_ADDRSS(ICF)=I
        IF (EA_NORDER(I) <= 3) THEN
         K=0
         DO L=0,IALL(0,0,0)-IVIRTCORE-1
          IF (BTEST(ICF,L)) K=K+10**L
          IF (BTEST(ICF,L)) M=L
         ENDDO
         IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' PARTICLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
        ENDIF
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 4) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-4
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-3
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-2
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-1
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE
         J=0
         IF (I1 <= ICORE) J=J+1
         IF (I2 <= ICORE) J=J+1
         IF (I3 <= ICORE) J=J+1
         IF (I4 <= ICORE) J=J+1
         IF (I5 <= ICORE) J=J+1
         IF (J /= ICORE) CYCLE
         J=IOCC+1
         IF (I1 <= IOCC) J=J-1
         IF (I2 <= IOCC) J=J-1
         IF (I3 <= IOCC) J=J-1
         IF (I4 <= IOCC) J=J-1
         IF (I5 <= IOCC) J=J-1
         IF (J > ORDER) CYCLE
         ICF=0
         ICF=IBSET(ICF,I1-1) 
         ICF=IBSET(ICF,I2-1) 
         ICF=IBSET(ICF,I3-1) 
         ICF=IBSET(ICF,I4-1) 
         ICF=IBSET(ICF,I5-1) 
         I=I+1
         EA_CFHALF(I)=ICF
         EA_NORDER(I)=J
         EA_ADDRSS(ICF)=I
         IF (EA_NORDER(I) <= 3) THEN
          K=0
          DO L=0,IALL(0,0,0)-IVIRTCORE-1
           IF (BTEST(ICF,L)) K=K+10**L
           IF (BTEST(ICF,L)) M=L
          ENDDO
          IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' PARTICLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
         ENDIF
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 5) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-5
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-4
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-3
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-2
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE-1
         DO I6=I5+1,IALL(0,0,0)-IVIRTCORE
          J=0
          IF (I1 <= ICORE) J=J+1
          IF (I2 <= ICORE) J=J+1
          IF (I3 <= ICORE) J=J+1
          IF (I4 <= ICORE) J=J+1
          IF (I5 <= ICORE) J=J+1
          IF (I6 <= ICORE) J=J+1
          IF (J /= ICORE) CYCLE
          J=IOCC+1
          IF (I1 <= IOCC) J=J-1
          IF (I2 <= IOCC) J=J-1
          IF (I3 <= IOCC) J=J-1
          IF (I4 <= IOCC) J=J-1
          IF (I5 <= IOCC) J=J-1
          IF (I6 <= IOCC) J=J-1
          IF (J > ORDER) CYCLE
          ICF=0
          ICF=IBSET(ICF,I1-1) 
          ICF=IBSET(ICF,I2-1) 
          ICF=IBSET(ICF,I3-1) 
          ICF=IBSET(ICF,I4-1) 
          ICF=IBSET(ICF,I5-1) 
          ICF=IBSET(ICF,I6-1) 
          I=I+1
          EA_CFHALF(I)=ICF
          EA_NORDER(I)=J
          EA_ADDRSS(ICF)=I
          IF (EA_NORDER(I) <= 3) THEN
           K=0
           DO L=0,IALL(0,0,0)-IVIRTCORE-1
            IF (BTEST(ICF,L)) K=K+10**L
            IF (BTEST(ICF,L)) M=L
           ENDDO
           IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' PARTICLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
          ENDIF
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 6) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-6
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-5
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-4
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-3
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE-2
         DO I6=I5+1,IALL(0,0,0)-IVIRTCORE-1
          DO I7=I6+1,IALL(0,0,0)-IVIRTCORE
           J=0
           IF (I1 <= ICORE) J=J+1
           IF (I2 <= ICORE) J=J+1
           IF (I3 <= ICORE) J=J+1
           IF (I4 <= ICORE) J=J+1
           IF (I5 <= ICORE) J=J+1
           IF (I6 <= ICORE) J=J+1
           IF (I7 <= ICORE) J=J+1
           IF (J /= ICORE) CYCLE
           J=IOCC+1
           IF (I1 <= IOCC) J=J-1
           IF (I2 <= IOCC) J=J-1
           IF (I3 <= IOCC) J=J-1
           IF (I4 <= IOCC) J=J-1
           IF (I5 <= IOCC) J=J-1
           IF (I6 <= IOCC) J=J-1
           IF (I7 <= IOCC) J=J-1
           IF (J > ORDER) CYCLE
           ICF=0
           ICF=IBSET(ICF,I1-1) 
           ICF=IBSET(ICF,I2-1) 
           ICF=IBSET(ICF,I3-1) 
           ICF=IBSET(ICF,I4-1) 
           ICF=IBSET(ICF,I5-1) 
           ICF=IBSET(ICF,I6-1) 
           ICF=IBSET(ICF,I7-1) 
           I=I+1
           EA_CFHALF(I)=ICF
           EA_NORDER(I)=J
           EA_ADDRSS(ICF)=I
           IF (EA_NORDER(I) <= 3) THEN
            K=0
            DO L=0,IALL(0,0,0)-IVIRTCORE-1
             IF (BTEST(ICF,L)) K=K+10**L
             IF (BTEST(ICF,L)) M=L
            ENDDO
            IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' PARTICLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
           ENDIF
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE IF (IOCC == 7) THEN
    DO I1=1,IALL(0,0,0)-IVIRTCORE-7
     DO I2=I1+1,IALL(0,0,0)-IVIRTCORE-6
      DO I3=I2+1,IALL(0,0,0)-IVIRTCORE-5
       DO I4=I3+1,IALL(0,0,0)-IVIRTCORE-4
        DO I5=I4+1,IALL(0,0,0)-IVIRTCORE-3
         DO I6=I5+1,IALL(0,0,0)-IVIRTCORE-2
          DO I7=I6+1,IALL(0,0,0)-IVIRTCORE-1
           DO I8=I7+1,IALL(0,0,0)-IVIRTCORE
            J=0
            IF (I1 <= ICORE) J=J+1
            IF (I2 <= ICORE) J=J+1
            IF (I3 <= ICORE) J=J+1
            IF (I4 <= ICORE) J=J+1
            IF (I5 <= ICORE) J=J+1
            IF (I6 <= ICORE) J=J+1
            IF (I7 <= ICORE) J=J+1
            IF (I8 <= ICORE) J=J+1
            IF (J /= ICORE) CYCLE
            J=0
            IF (I1 > IOCC) J=J+1
            IF (I2 > IOCC) J=J+1
            IF (I3 > IOCC) J=J+1
            IF (I4 > IOCC) J=J+1
            IF (I5 > IOCC) J=J+1
            IF (I6 > IOCC) J=J+1
            IF (I7 > IOCC) J=J+1
            IF (I8 > IOCC) J=J+1
            IF (J > ORDER) CYCLE
            ICF=0
            ICF=IBSET(ICF,I1-1)
            ICF=IBSET(ICF,I2-1)
            ICF=IBSET(ICF,I3-1)
            ICF=IBSET(ICF,I4-1)
            ICF=IBSET(ICF,I5-1)
            ICF=IBSET(ICF,I6-1)
            ICF=IBSET(ICF,I7-1)
            ICF=IBSET(ICF,I8-1)
            I=I+1
            EA_CFHALF(I)=ICF
            EA_NORDER(I)=J
            EA_ADDRSS(ICF)=I
            IF (EA_NORDER(I) <= 3) THEN
             K=0
             DO L=0,IALL(0,0,0)-IVIRTCORE-1
              IF (BTEST(ICF,L)) K=K+10**L
              IF (BTEST(ICF,L)) M=L
             ENDDO
             IF (M < 10) WRITE(6,'(I6,A,I3,A,I6,A,I12)') I,' PARTICLES = ',J,' CF(NUM) = ',ICF,' CF(BIT) = ',K
            ENDIF
           ENDDO
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ELSE
    CALL PABORT('NUMBER OF ELECTRONS IS TOO LARGE')
   ENDIF

   RETURN
END SUBROUTINE



SUBROUTINE REL_EA_HAMILTONIAN_PRODUCT(INFILE,OUTFILE,OFFSET,ORDER)
! FORM THE PRODUCT OF HAMILTONIAN MATRIX AND A TRIAL VECTOR IN INFILE
! AND STORE THE PRODUCT VECTOR IN OUTFILE.  THE ORDER LIMITS THE NUMBER
! EXCITATION IN THE CONFIGURATIONS CONSIDERED.  A BETA ELECTRON IS
! ALWAYS ASSUMED TO BE ADDED.  NOTICE THAT TRL(BETA,ALPHA) AND LIKEWISE
! FOR PRD ARRAYS.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: INFILE,OUTFILE,OFFSET
   INTEGER :: ORDER
   INTEGER :: ISIGN,JSIGN
   INTEGER :: I,J,K,L,M
   INTEGER :: IA,IB,IC,ID
   INTEGER :: NIA,NIB,NJA,NJB
   INTEGER(4) :: CFONE,CFTWO
   REAL :: MEM,ICPUS,ICPUE,EST
   DOUBLE PRECISION :: X,Y
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:),PRD(:,:)
   INTEGER,ALLOCATABLE :: EA_PSIGN(:,:,:),EA_PADRS(:,:,:)

!  CALL PCPU_TIME(ICPUS)
   MEM=16.0*2.0*NCF*EA_NCF+4.0*2.0*NCF*(IALL(0,0,0)-IVIRTCORE)**2
!  IF (MEM > 1000000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
!  ELSE IF (MEM > 1000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
!  ELSE
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
!  ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 

   ALLOCATE(TRL(EA_NCF,NCF),PRD(EA_NCF,NCF))
   ALLOCATE(EA_PSIGN(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,EA_NCF),EA_PADRS(IALLMAX-IVIRTCORE,IALLMAX-IVIRTCORE,EA_NCF))

   ! READ TRIAL VECTOR FROM FILE INFILE
   REWIND(INFILE)
   DO I=0,OFFSET
    READ(INFILE) TRL
   ENDDO

   ! ZERO SCRATCH TRIAL VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   DO IA=1,NCF
    DO IB=1,EA_NCF
     IF (NORDER(IA)+EA_NORDER(IB) > ORDER) TRL(IB,IA)=0.0D0
    ENDDO
   ENDDO

   ! ZERO SCRATCH PRODUCT VECTOR
   PRD=0.0D0

   ! DIAGONAL ELEMENTS
   DO IA=1,NCF
    DO IB=1,EA_NCF
     DO I=1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFHALF(IA),I-1))    PRD(IB,IA)=PRD(IB,IA)+H(I,I)*TRL(IB,IA)
      IF (BTEST(EA_CFHALF(IB),I-1)) PRD(IB,IA)=PRD(IB,IA)+H(I,I)*TRL(IB,IA)
     ENDDO
     DO I=1,IALL(0,0,0)-IVIRTCORE
      DO J=1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),I-1)) THEN
        NIA=1
       ELSE
        NIA=0
       ENDIF
       IF (BTEST(CFHALF(IA),J-1)) THEN
        NJA=1
       ELSE
        NJA=0
       ENDIF
       IF (BTEST(EA_CFHALF(IB),I-1)) THEN
        NIB=1
       ELSE
        NIB=0
       ENDIF
       IF (BTEST(EA_CFHALF(IB),J-1)) THEN
        NJB=1
       ELSE
        NJB=0
       ENDIF
       PRD(IB,IA)=PRD(IB,IA)+0.5D0*(DFLOAT((NJA+NJB)*(NIA+NIB))*G(J,J,I,I) &
                 -DFLOAT(NJA*NIA+NJB*NIB)*G(J,I,I,J))*TRL(IB,IA)
      ENDDO
     ENDDO
    ENDDO
   ENDDO

   ! ONE SPIN ORBITAL DIFFERENCE
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(CFHALF(IA),I-1)) THEN
      DO K=1,IALL(0,0,0)-IVIRTCORE
       IF (.NOT.(BTEST(CFHALF(IA),K-1))) THEN
        CFONE=IBCLR(CFHALF(IA),I-1)
        CFONE=IBSET(CFONE,K-1)
        IC=ADDRSS(CFONE)
        X=H(K,I)
        DO J=1,IALL(0,0,0)-IVIRTCORE
         IF ((J /= I).AND.(J /= K).AND.(BTEST(CFONE,J-1))) X=X+G(K,I,J,J)-G(K,J,J,I)
        ENDDO
        ISIGN=1
        DO J=1,I
         IF (BTEST(CFHALF(IA),J-1)) ISIGN=-ISIGN
        ENDDO
        DO J=1,K
         IF (BTEST(CFONE,J-1)) ISIGN=-ISIGN
        ENDDO
        DO IB=1,EA_NCF
         IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
          Y=0.0D0
          DO J=1,IALL(0,0,0)-IVIRTCORE
           IF (BTEST(EA_CFHALF(IB),J-1)) Y=Y+G(K,I,J,J)
          ENDDO
          PRD(IB,IC)=PRD(IB,IC)+(X+Y)*DFLOAT(ISIGN)*TRL(IB,IA)
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
   DO IB=1,EA_NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     IF (BTEST(EA_CFHALF(IB),I-1)) THEN
      DO K=1,IALL(0,0,0)-IVIRTCORE
       IF (.NOT.(BTEST(EA_CFHALF(IB),K-1))) THEN
        CFONE=IBCLR(EA_CFHALF(IB),I-1)
        CFONE=IBSET(CFONE,K-1)
        IC=EA_ADDRSS(CFONE)
        X=H(K,I)
        DO J=1,IALL(0,0,0)-IVIRTCORE
         IF ((J /= I).AND.(J /= K).AND.(BTEST(CFONE,J-1))) X=X+G(K,I,J,J)-G(K,J,J,I)
        ENDDO
        ISIGN=1
        DO J=1,I
         IF (BTEST(EA_CFHALF(IB),J-1)) ISIGN=-ISIGN
        ENDDO
        DO J=1,K
         IF (BTEST(CFONE,J-1)) ISIGN=-ISIGN
        ENDDO
        DO IA=1,NCF
         IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
          Y=0.0D0
          DO J=1,IALL(0,0,0)-IVIRTCORE
           IF (BTEST(CFHALF(IA),J-1)) Y=Y+G(K,I,J,J)
          ENDDO
          PRD(IC,IA)=PRD(IC,IA)+(X+Y)*DFLOAT(ISIGN)*TRL(IB,IA)
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO

   ! TWO SPIN ORBITAL DIFFERENCES, CASE 1
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE-1
     IF (BTEST(CFHALF(IA),I-1)) THEN
      DO J=I+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IA),J-1)) THEN
        DO K=1,IALL(0,0,0)-IVIRTCORE-1
         IF (.NOT.(BTEST(CFHALF(IA),K-1))) THEN
          DO L=K+1,IALL(0,0,0)-IVIRTCORE
           IF (.NOT.(BTEST(CFHALF(IA),L-1))) THEN
            CFTWO=IBCLR(CFHALF(IA),I-1)
            CFTWO=IBCLR(CFTWO,J-1)
            CFTWO=IBSET(CFTWO,K-1)
            CFTWO=IBSET(CFTWO,L-1)
            IC=ADDRSS(CFTWO)
            ISIGN=1
            DO M=1,I
             IF (BTEST(CFHALF(IA),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,J
             IF (BTEST(CFHALF(IA),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,K
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,L
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            Y=DFLOAT(ISIGN)*(G(K,I,L,J)-G(K,J,L,I))
            DO IB=1,EA_NCF
             PRD(IB,IC)=PRD(IB,IC)+Y*TRL(IB,IA)
            ENDDO
           ENDIF
          ENDDO
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
   DO IB=1,EA_NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE-1
     IF (BTEST(EA_CFHALF(IB),I-1)) THEN
      DO J=I+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(EA_CFHALF(IB),J-1)) THEN
        DO K=1,IALL(0,0,0)-IVIRTCORE-1
         IF (.NOT.(BTEST(EA_CFHALF(IB),K-1))) THEN
          DO L=K+1,IALL(0,0,0)-IVIRTCORE
           IF (.NOT.(BTEST(EA_CFHALF(IB),L-1))) THEN
            CFTWO=IBCLR(EA_CFHALF(IB),I-1)
            CFTWO=IBCLR(CFTWO,J-1)
            CFTWO=IBSET(CFTWO,K-1)
            CFTWO=IBSET(CFTWO,L-1)
            IC=EA_ADDRSS(CFTWO)
            ISIGN=1
            DO M=1,I
             IF (BTEST(EA_CFHALF(IB),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,J
             IF (BTEST(EA_CFHALF(IB),M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,K
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            DO M=1,L
             IF (BTEST(CFTWO,M-1)) ISIGN=-ISIGN
            ENDDO
            Y=DFLOAT(ISIGN)*(G(K,I,L,J)-G(K,J,L,I))
            DO IA=1,NCF
             PRD(IC,IA)=PRD(IC,IA)+Y*TRL(IB,IA)
            ENDDO
           ENDIF
          ENDDO
         ENDIF
        ENDDO
       ENDIF
      ENDDO
     ENDIF
    ENDDO
   ENDDO
!  CALL PCPU_TIME(ICPUE)
!  EST=ICPUE-ICPUS
!  CALL PCPU_TIME(ICPUS)

   ! TWO SPIN ORBITAL DIFFERENCES, CASE 2
   DO IB=1,EA_NCF
    DO K=ICORE+1,IALL(0,0,0)-IVIRTCORE
     DO L=1,IALL(0,0,0)-IVIRTCORE
      EA_PSIGN(L,K,IB)=0
      EA_PADRS(L,K,IB)=0
      IF ((BTEST(EA_CFHALF(IB),K-1)).AND.(.NOT.(BTEST(EA_CFHALF(IB),L-1)))) THEN
       CFONE=IBCLR(EA_CFHALF(IB),K-1)
       CFONE=IBSET(CFONE,L-1)
       EA_PADRS(L,K,IB)=EA_ADDRSS(CFONE)
       JSIGN=1
       DO M=1,K
        IF (BTEST(EA_CFHALF(IB),M-1)) JSIGN=-JSIGN
       ENDDO
       DO M=1,L
        IF (BTEST(CFONE,M-1)) JSIGN=-JSIGN
       ENDDO
       EA_PSIGN(L,K,IB)=JSIGN
      ENDIF
     ENDDO
    ENDDO
   ENDDO
   DO IA=1,NCF
    DO I=ICORE+1,IALL(0,0,0)-IVIRTCORE
     DO J=1,IALL(0,0,0)-IVIRTCORE
      IF ((BTEST(CFHALF(IA),I-1)).AND.(.NOT.(BTEST(CFHALF(IA),J-1)))) THEN
       CFONE=IBCLR(CFHALF(IA),I-1)
       CFONE=IBSET(CFONE,J-1)
       IC=ADDRSS(CFONE)
       ISIGN=1
       DO K=1,I
        IF (BTEST(CFHALF(IA),K-1)) ISIGN=-ISIGN
       ENDDO
       DO K=1,J
        IF (BTEST(CFONE,K-1)) ISIGN=-ISIGN
       ENDDO
       DO IB=1,EA_NCF
        IF (DABS(TRL(IB,IA)) > 1.0D-15) THEN
         DO K=ICORE+1,IALL(0,0,0)-IVIRTCORE
          DO L=1,IALL(0,0,0)-IVIRTCORE
           IF (EA_PADRS(L,K,IB) /= 0) PRD(EA_PADRS(L,K,IB),IC)=PRD(EA_PADRS(L,K,IB),IC) &
           +DFLOAT(ISIGN*EA_PSIGN(L,K,IB))*G(J,I,L,K)*TRL(IB,IA)
          ENDDO
         ENDDO
        ENDIF
       ENDDO
      ENDIF
     ENDDO
    ENDDO
!   CALL PCPU_TIME(ICPUE)
!   IF (IA == 1) THEN
!    EST=EST+(ICPUE-ICPUS)*NCF
!    EST=EST/3600.0
!    IF (EST > 0.1) WRITE(6,'(A,F20.1,A)') '***** WARNING : ESTIMATED PRODUCT FORMATION TIME = ',EST,' HOURS'
!   ENDIF
   ENDDO

   ! ZERO SCRATCH PRODUCT VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   DO IA=1,NCF
    DO IB=1,EA_NCF
     IF (NORDER(IA)+EA_NORDER(IB) > ORDER) PRD(IB,IA)=0.0D0
    ENDDO
   ENDDO

   ! STORE PRODUCT VECTOR
   REWIND(OUTFILE)
   IF (OFFSET == 0) THEN
    WRITE(OUTFILE) PRD
   ELSE
    DO I=1,OFFSET
     READ(OUTFILE) TRL
    ENDDO
    WRITE(OUTFILE) PRD
   ENDIF

   DEALLOCATE(TRL,PRD,EA_PSIGN,EA_PADRS)

   RETURN
END SUBROUTINE



SUBROUTINE REL_FULL_EA_HAMILTONIAN(ORDER)
! FORM FULL HAMILTONIAN AND DIAGONALIZE IT BY THE STANDARD ALGORITHMS.
! CAUTION, DO NOT USE THIS FOR PRODUCTION RUN.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL,PARAMETER :: LEVEC = .FALSE.
   INTEGER :: ORDER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: INFO
   REAL :: MEM,DEV
   DOUBLE PRECISION,ALLOCATABLE :: HAM(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: VL(:,:),VR(:,:),ER(:),EI(:),WK(:)
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:)

   WRITE(6,'(I2,A,I2,A)') ORDER-1,'-HOLE',ORDER,'-PARTICLE CONFIGURATION INTERACTION CALCULATION FOR ALL STATES'
   IF (LEVEC) THEN 
    MEM=16.0*(2.0*(NCF*EA_NCF)**2+8.0*NCF*EA_NCF)
   ELSE
    MEM=16.0*((NCF*EA_NCF)**2+9.0*NCF*EA_NCF)
   ENDIF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   ALLOCATE(HAM(NCF*EA_NCF,NCF*EA_NCF),VL(1,NCF*EA_NCF),ER(NCF*EA_NCF),EI(NCF*EA_NCF),WK(4*NCF*EA_NCF))
   IF (LEVEC) THEN 
    ALLOCATE(VR(NCF*EA_NCF,NCF*EA_NCF))
   ELSE
    ALLOCATE(VR(1,NCF*EA_NCF))
   ENDIF
   ALLOCATE(TRL(EA_NCF,NCF))

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')

   ! FORM HAMILTONIAN AND KEEP IT IN MEMORY
   DO IA=1,NCF
    DO IB=1,EA_NCF
     TRL=0.0D0
     IF (NORDER(IA)+EA_NORDER(IB) <= ORDER) TRL(IB,IA)=1.0D0
     REWIND(50)
     WRITE(50) TRL
     CALL REL_EA_HAMILTONIAN_PRODUCT(50,60,0,ORDER)
     REWIND(60)
     READ(60) TRL
     DO IC=1,NCF
      DO ID=1,EA_NCF
       HAM((IA-1)*EA_NCF+IB,(IC-1)*EA_NCF+ID)=TRL(ID,IC)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
!  CALL DUMP5(HAM,NCF*EA_NCF)

   DEALLOCATE(TRL)
   CLOSE(50)
   CLOSE(60)

   ! DIAGONALIZE HAMILTONIAN
   IF (LEVEC) THEN
    CALL DGEEV('N','V',NCF*EA_NCF,HAM,NCF*EA_NCF,ER,EI,VL,1,VR,NCF*EA_NCF,WK,4*NCF*EA_NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF*EA_NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT(NCF*EA_NCF,NCF*EA_NCF,ER,VR,EI)
    DO IA=1,MIN(25,NCF*EA_NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
     DO IB=1,NCF*EA_NCF
      WRITE(6,'(I10,F20.15)') IB,VR(IB,IA)
     ENDDO
    ENDDO
   ELSE
    CALL DGEEV('N','N',NCF*EA_NCF,HAM,NCF*EA_NCF,ER,EI,VL,1,VR,1,WK,4*NCF*EA_NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF*EA_NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT_EVALONLY(NCF*EA_NCF,ER)
    DO IA=1,MIN(25,NCF*EA_NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
    ENDDO
   ENDIF
   CALL PFLUSH(6)

   DEALLOCATE(HAM,VL,VR,ER,EI,WK)

   RETURN
END SUBROUTINE



SUBROUTINE REL_CI_EA_GUESS(ORDER,NROOTS,NTRIALS)
! GENERATE INITIAL GUESS TRIAL VECTORS FOR CI CALCULATIONS.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER :: ORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: IA,IB
   INTEGER :: I,J
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:)

   IF (NROOTS < 1) CALL PABORT('ILLEGAL NUMBER OF CI ROOTS')
   IF ((ORDER < 1).OR.(ORDER > MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE))) &
   CALL PABORT('ILLEGAL NUMBER OF CI ORDER')

   WRITE(6,'(A)') 'INITIAL GUESS FOR THE CI/EOMCC VECTORS WILL BE GENERATED'

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   REWIND(50)

   ALLOCATE(VEC1(EA_NCF,NCF))
   ! GENERATE INITIAL GUESS
   IF (NROOTS <= IALL(0,0,0)-IOCC-IVIRTCORE) THEN
    REWIND(50)
    NTRIALS=0
    DO IB=1,EA_NCF
     IF (EA_NORDER(IB) == 1) THEN
      NTRIALS=NTRIALS+1
      VEC1=0.0D0
      VEC1(IB,1)=1.0D0
      WRITE(50) VEC1
     ENDIF
    ENDDO
   ELSE IF (ORDER > 1) THEN
    REWIND(50)
    NTRIALS=0
    DO IA=1,NCF
     IF (NORDER(IA) == 1) THEN
      NTRIALS=NTRIALS+1
      VEC1=0.0D0
      VEC1(1,IA)=1.0D0
      WRITE(50) VEC1
     ENDIF
    ENDDO
    DO IB=1,EA_NCF
     IF (EA_NORDER(IB) == 1) THEN
      NTRIALS=NTRIALS+1
      VEC1=0.0D0
      VEC1(IB,1)=1.0D0
      WRITE(50) VEC1
     ENDIF
    ENDDO
    IF (NTRIALS < NROOTS) THEN
     REWIND(50)
     NTRIALS=0
     DO IA=1,NCF
      DO IB=1,EA_NCF
       IF (NORDER(IA)+EA_NORDER(IB) <= 2) THEN
        NTRIALS=NTRIALS+1
        VEC1=0.0D0
        VEC1(IB,IA)=1.0D0
        WRITE(50) VEC1
       ENDIF
      ENDDO
     ENDDO
    ENDIF
   ELSE
    CALL PABORT('DECREASE THE NUMBER OF ROOTS')
   ENDIF
 
   IF (NROOTS > NTRIALS) CALL PABORT('DECREASE THE NUMBER OF ROOTS')

   DEALLOCATE(VEC1)
   CLOSE(50)

   RETURN
END SUBROUTINE



SUBROUTINE REL_HIGHORDER_CI_EA(ORDER,NROOTS,NTRIALS)
! PERFORM HIGH-ORDER CONFIGURATION INTERACTION CALCULATIONS BY THE DAVIDSON'S ALGORITHM.

   USE CONSTANTS
   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER,PARAMETER :: MAXFILE = 1000
   INTEGER,PARAMETER :: MAXCYCLE = 1000
   INTEGER :: ICYCLE
   INTEGER :: ORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: NTRIALS_NEXT
   INTEGER :: IA,IB
   INTEGER :: I,J,K,L,NOPEN
   INTEGER,ALLOCATABLE :: N(:)
   REAL :: MEM,ICPUS,ICPUE
   LOGICAL :: LDONE(MAXFILE)
   DOUBLE PRECISION :: DEVSQ,DEVMAX,D,F,S2
   DOUBLE PRECISION :: SMALLH(MAXFILE,MAXFILE),LAMBDA(MAXFILE),ECI(MAXFILE)
   DOUBLE PRECISION :: W1(MAXFILE,MAXFILE),W2(MAXFILE)
   DOUBLE PRECISION :: PERCENTS,PERCENTD
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:)

   CALL PCPU_TIME(ICPUS)
   WRITE(6,'(A)') 'HIGH-ORDER ELECTRON AFFINITY CONFIGURATION INTERACTION CALCULATIONS WILL BE PERFORMED'
   WRITE(6,'(A,I2,A,I2,A)') 'CI ORDER IS ',ORDER-1,'-HOLE ',ORDER,'-PARTICLE'
   WRITE(6,'(A,I4)') 'THE NUMBER OF CI ROOTS SOUGHT ',NROOTS
   WRITE(6,'(A,I4)') 'THE NUMBER OF INITIAL TRIAL VECTORS ',NTRIALS
   MEM=16.0*2.0*NCF*EA_NCF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   IF (NROOTS > 1) THEN
    WRITE(6,'(A)') '--------------------------------------------------------'
    WRITE(6,'(A)') '             DEVIATION          TOTAL ENERGY   CPU / SEC'
   ELSE
    WRITE(6,'(A)') '-------------------------------------------------'
    WRITE(6,'(A)') 'ITR    DEVIATION         TOTAL ENERGY   CPU / SEC'
   ENDIF
   ALLOCATE(VEC1(EA_NCF,NCF),VEC2(EA_NCF,NCF),N(IALLMAX-IVIRTCORE))
   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fi1',FORM='UNFORMATTED')

   ! INITIALIZE
   LDONE=.FALSE.
   IF (NTRIALS > MAXFILE) CALL PABORT('TOO MANY INITIAL TRIAL VECTORS')

   ! DAVIDSON ITERATION
   DO ICYCLE=1,MAXCYCLE

    ! CALCULATE H|0> AND STORE IT IN FILE 70
    DEALLOCATE(VEC1,VEC2)
    DO I=1,NTRIALS
     IF (.NOT.LDONE(I)) THEN
      CALL REL_EA_HAMILTONIAN_PRODUCT(50,51,I-1,ORDER)
      LDONE(I)=.TRUE.
     ENDIF
    ENDDO
    ALLOCATE(VEC1(EA_NCF,NCF),VEC2(EA_NCF,NCF))

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|N> FOR DEBUG
!   WRITE(6,'(A)') 'SUBSPACE REPRESENTATION OF METRIC'
!   DO I=1,NTRIALS
!    REWIND(50)
!    DO J=1,I
!     READ(50) VEC1
!    ENDDO
!    REWIND(50)
!    DO L=1,NTRIALS
!     READ(50) VEC2
!     SMALLH(I,L)=0.0D0
!     DO IA=1,NCF
!      DO IB=1,EA_NCF
!       SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
!      ENDDO
!     ENDDO
!    ENDDO
!    WRITE(6,'(I3,100F10.5:)') I,(SMALLH(I,L),L=1,NTRIALS)
!   ENDDO

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|H|N>
    REWIND(50)
!   WRITE(6,'(A)') 'SUBSPACE REPRESENTATION OF HAMILTONIAN'
    DO I=1,NTRIALS
     READ(50) VEC1
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      SMALLH(I,L)=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
     ENDDO
!    WRITE(6,'(I3,100F10.5:)') I,(SMALLH(I,L),L=1,NTRIALS)
    ENDDO
      
    ! DIAGONALIZE SUBSPACE HAMILTONIAN
    IF (NTRIALS == 1) THEN
     LAMBDA(1)=SMALLH(1,1)
     W1(1,1)=1.0D0
    ELSE
     W1=SMALLH
     CALL TRED2(W1,NTRIALS,MAXFILE,LAMBDA,W2)
     CALL TQLI(LAMBDA,W2,NTRIALS,MAXFILE,W1)
     CALL PIKSRT(NTRIALS,MAXFILE,LAMBDA,W1,W2)
    ENDIF
      
    ! FORM RESIDUAL VECTORS
    CALL PCPU_TIME(ICPUE)
    DEVMAX=0.0D0
    IF (NROOTS > 1) WRITE(6,'(A,I3)') ' ITER ',ICYCLE
    NTRIALS_NEXT=NTRIALS
    DO K=1,NROOTS
     VEC1=0.0D0
     REWIND(50)
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      VEC1=VEC1+VEC2*W1(L,K)
      READ(50) VEC2
      VEC1=VEC1-LAMBDA(K)*VEC2*W1(L,K)
     ENDDO
     DEVSQ=0.0D0
     DO IA=1,NCF
      DO IB=1,EA_NCF
       DEVSQ=DEVSQ+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     DEVSQ=DSQRT(DEVSQ)
     IF (DEVSQ > DEVMAX) DEVMAX=DEVSQ
     ECI(K)=LAMBDA(K)+NUCLEAR_REPULSION
     IF (NROOTS == 1) THEN
      WRITE(6,'(I2,F15.10,F20.10,F12.1)') ICYCLE,DEVSQ,ECI(K),ICPUE-ICPUS
     ELSE
      WRITE(6,'(A,I3,F15.10,F20.10,F12.1)') ' ROOT ',K,DEVSQ,ECI(K),(ICPUE-ICPUS)/DFLOAT(NROOTS)
     ENDIF
      
     IF (DEVSQ < 1.0D-5) CYCLE

     ! FORM A NEW SUBSPACE VECTOR BY KNOWLES-HANDY SCHEME
     DO IA=1,NCF
      DO IB=1,EA_NCF
       NOPEN=0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        N(I)=0
        IF (BTEST(CFHALF(IA),I-1)) N(I)=1
        IF (BTEST(EA_CFHALF(IB),I-1)) N(I)=N(I)+1
        NOPEN=NOPEN+N(I)*(2-N(I))
       ENDDO
       IF ((NOPEN == 0).OR.(NOPEN == 1)) THEN
        F=0.0D0
       ELSE
        F=(3.0D0-DFLOAT(NOPEN))/DFLOAT(NOPEN*(NOPEN-1))
       ENDIF
       D=0.0D0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        D=D+DFLOAT(N(I))*H(I,I)-DFLOAT(N(I)*(2-N(I)))*G(I,I,I,I)/4.0D0
        DO J=1,IALL(0,0,0)-IVIRTCORE
         D=D+DFLOAT(N(I)*N(J))*(2.0D0*G(I,I,J,J)-G(I,J,J,I))/4.0D0
         IF (I /= J) D=D-F*DFLOAT(N(I)*(2-N(I))*N(J)*(2-N(J)))*G(I,J,J,I)/4.0D0
        ENDDO
       ENDDO
       IF ((LAMBDA(K)-D) /= 0.0D0) VEC1(IB,IA)=VEC1(IB,IA)/(LAMBDA(K)-D)
      ENDDO
     ENDDO
      
     ! ORTHONORMALIZE THE NEW SUBSPACE VECTOR
     REWIND(50)
     DO L=1,NTRIALS_NEXT
      READ(50) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        D=D+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
      VEC1=VEC1-D*VEC2
     ENDDO
     D=0.0D0
     DO IA=1,NCF
      DO IB=1,EA_NCF
       D=D+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     D=DSQRT(D)
     IF (D > 1.0D-8) THEN
      VEC1=VEC1/D
      NTRIALS_NEXT=NTRIALS_NEXT+1
      IF (NTRIALS_NEXT > MAXFILE) CALL PABORT('TOO MANY TRIAL VECTORS')
      REWIND(50)
      DO L=1,NTRIALS_NEXT-1
       READ(50) VEC2
      ENDDO
      WRITE(50) VEC1
     ENDIF

    ENDDO

    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    IF (DEVMAX < 1.0D-5) THEN
     IF (NROOTS > 1) THEN
      WRITE(6,'(A)') '--------------------------------------------------------'
     ELSE
      WRITE(6,'(A)') '-------------------------------------------------'
     ENDIF
     REWIND(51)
     DO I=1,NROOTS
      WRITE(6,'(A,I3,F20.15,A)') 'ROOT ',I,ECI(I),' HARTREE'
      REWIND(50)
      VEC1=0.0D0
      DO L=1,NTRIALS
       READ(50) VEC2
       VEC1=VEC1+VEC2*W1(L,I)
      ENDDO
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        D=D+VEC1(IB,IA)**2
       ENDDO
      ENDDO
      VEC1=VEC1/DSQRT(D)
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        IF (NORDER(IA)+EA_NORDER(IB) == 1) PERCENTS=PERCENTS+VEC1(IB,IA)**2
        IF (NORDER(IA)+EA_NORDER(IB) == 2) PERCENTD=PERCENTD+VEC1(IB,IA)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES = ',PERCENTD*1.0D2
      WRITE(51) VEC1
      CALL REL_S_SQUARED_EA(51,I-1,ORDER,S2)
      WRITE(6,'(A,F8.4)') ' < S**2 > = ',S2
      DO IA=1,NCF
       DO IB=1,EA_NCF
        IF (DABS(VEC1(IB,IA)) > 0.1D0) WRITE(6,'(A,I6,A,I6,A,F8.4)') ' DETERMINANT (',IA,'-ALPHA ',IB,'-BETA ) ',VEC1(IB,IA)
       ENDDO
      ENDDO
     ENDDO
!    REWIND(50)
!    REWIND(51)
!    DO I=1,NROOTS
!     READ(51) VEC1
!     WRITE(50) VEC1
!    ENDDO
     DEALLOCATE(VEC1,VEC2,N)
     CLOSE(50)
     CLOSE(51)
     RETURN
    ELSE IF (NTRIALS_NEXT == NTRIALS) THEN
     CALL PABORT('ALGORITHM FAILED TO INCREASE THE SUBSPACE')
    ELSE IF (NROOTS > 1) THEN
     WRITE(6,'(I3,A)') NTRIALS_NEXT-NTRIALS,' TRIAL VECTORS HAVE BEEN ADDED'
    ENDIF
    NTRIALS=NTRIALS_NEXT

   ENDDO
   CALL PABORT('DAVIDSON ALGORITHM FAILED TO CONVERGE')

END SUBROUTINE



SUBROUTINE REL_EA_EXPONENTIAL_OPERATOR(TFILE,INFILE,OUTFILE,ORDER,LMINUS)
! OPERATE WITH AN EXPONENTIAL OPERATOR ON ANY GIVEN (N+1)-ELECTRON WAVEFUNCTION.  
! THE T-AMPLITUDES ARE STORED IN TFILE, THE WAVEFUNCTION ON WHICH THE EXPONENTIAL OPERATOR ACTS IS 
! IN INFILE, AND THE EXPONENTIAL WAVEFUNCTION IS IN OUTFILE.  IF LMINUS=.TRUE.
! THE OPERATOR IS EXP(-T), OTHERWISE, EXP(T).  NOTE THAT THE T-AMPLITUDES ARE PREDETERMINED
! FOR THE CLOSED SHELL (N)-ELECTRON SYSTEM, BUT THE WAVEFUNCTION UPON WHICH EXP(T) OPERATES
! IS (N+1)-ELECTRON ONE.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL :: LMINUS
   LOGICAL :: LCYCLE
   INTEGER :: TFILE,INFILE,OUTFILE
   INTEGER :: ORDER
   INTEGER :: I,J,IPOWER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: HOLEA(ORDER),HOLEB(ORDER),PARTA(ORDER),PARTB(ORDER)
   INTEGER :: KSIGN(0:MIN(IOCC,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE)),ISIGN,JSIGN
   INTEGER(4) :: CFALPH,CFBETA
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:),VEC3(:,:)
   INTEGER,ALLOCATABLE :: AD1(:),EA_AD2(:),SN1(:),EA_SN2(:)
   LOGICAL,ALLOCATABLE :: LC1(:),EA_LC2(:)

   ALLOCATE(VEC1(NCF,NCF),VEC2(EA_NCF,NCF),VEC3(EA_NCF,NCF))
   ALLOCATE(AD1(NCF),EA_AD2(EA_NCF),SN1(NCF),EA_SN2(EA_NCF),LC1(NCF),EA_LC2(EA_NCF))

   ! SIGNS ASSOCIATED WITH THE PERMUTATION OF THE CLUSTER OPERATORS
   DO I=0,MIN(IOCC,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE)
    KSIGN(I)=(-1)**((I*(I-1))/2)
   ENDDO

   ! RETRIEVE T-AMPLITUDES FROM FILE
   REWIND(TFILE)
   READ(TFILE) VEC1
   IF (LMINUS) VEC1=-VEC1
   ! RETRIEVE INITIAL WAVEFUNCTION FROM FILE
   REWIND(INFILE)
   READ(INFILE) VEC2
   ! INITIALIZE OUTFILE WITH THE INITIAL WAVEFUNCTION
   REWIND(OUTFILE)
   WRITE(OUTFILE) VEC2

   ! LOOP OVER THE POWER
   DO IPOWER=1,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE)
    VEC3=0.0D0

    ! LOOP OVER ALPHA T-AMPLITUDE
    DO IA=1,NCF
     IF (NORDER(IA) > ORDER) CYCLE
     J=0
     DO I=1,IOCC
      IF (.NOT.BTEST(CFHALF(IA),I-1)) THEN
       J=J+1
       HOLEA(J)=I
      ENDIF
     ENDDO
     J=0
     DO I=IOCC+1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFHALF(IA),I-1)) THEN
       J=J+1
       PARTA(J)=I
      ENDIF
     ENDDO

     ! LOOP OVER ALPHA CONFIGURATIONS
     DO IC=1,NCF
      LCYCLE=.FALSE.
      CFALPH=CFHALF(IC)
      DO I=1,NORDER(IA)
       IF (.NOT.BTEST(CFALPH,HOLEA(I)-1)) LCYCLE=.TRUE.
       IF (BTEST(CFALPH,PARTA(I)-1)) LCYCLE=.TRUE.
      ENDDO
      LC1(IC)=LCYCLE
      IF (LCYCLE) CYCLE
      ISIGN=1
      DO I=1,NORDER(IA)
       IF (HOLEA(I) /= 1) THEN
        DO J=1,HOLEA(I)-1
         IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
        ENDDO
       ENDIF
       CFALPH=IBCLR(CFALPH,HOLEA(I)-1)
      ENDDO
      DO I=1,NORDER(IA)
       DO J=1,PARTA(I)-1
        IF (BTEST(CFALPH,J-1)) ISIGN=-ISIGN
       ENDDO
       CFALPH=IBSET(CFALPH,PARTA(I)-1)
      ENDDO
      AD1(IC)=ADDRSS(CFALPH)
      SN1(IC)=ISIGN*KSIGN(NORDER(IA))
     ENDDO

     ! LOOP OVER BETA T-AMPLITUDE
     DO IB=1,NCF
      IF (NORDER(IA)+NORDER(IB) > ORDER) CYCLE
      IF (DABS(VEC1(IB,IA)) < 1.0D-15) CYCLE
      J=0
      DO I=1,IOCC
       IF (.NOT.BTEST(CFHALF(IB),I-1)) THEN
        J=J+1
        HOLEB(J)=I
       ENDIF
      ENDDO
      J=0
      DO I=IOCC+1,IALL(0,0,0)-IVIRTCORE
       IF (BTEST(CFHALF(IB),I-1)) THEN
        J=J+1
        PARTB(J)=I
       ENDIF
      ENDDO

      ! LOOP OVER BETA CONFIGURATIONS
      DO ID=1,EA_NCF
       LCYCLE=.FALSE.
       CFBETA=EA_CFHALF(ID)
       DO I=1,NORDER(IB)
        IF (.NOT.BTEST(CFBETA,HOLEB(I)-1)) LCYCLE=.TRUE.
        IF (BTEST(CFBETA,PARTB(I)-1)) LCYCLE=.TRUE.
       ENDDO
       EA_LC2(ID)=LCYCLE
       IF (LCYCLE) CYCLE
       JSIGN=1
       DO I=1,NORDER(IB)
        IF (HOLEB(I) /= 1) THEN
         DO J=1,HOLEB(I)-1
          IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
         ENDDO
        ENDIF
        CFBETA=IBCLR(CFBETA,HOLEB(I)-1)
       ENDDO
       DO I=1,NORDER(IB)
        DO J=1,PARTB(I)-1
         IF (BTEST(CFBETA,J-1)) JSIGN=-JSIGN
        ENDDO
        CFBETA=IBSET(CFBETA,PARTB(I)-1)
       ENDDO
       EA_AD2(ID)=EA_ADDRSS(CFBETA)
       EA_SN2(ID)=JSIGN*KSIGN(NORDER(IB))
      ENDDO

      ! LOOP OVER ALPHA CONFIGURATIONS
      DO IC=1,NCF
       IF (LC1(IC)) CYCLE
       ! LOOP OVER BETA CONFIGURATIONS
       DO ID=1,EA_NCF
        IF (EA_LC2(ID)) CYCLE
        IF (DABS(VEC2(ID,IC)) < 1.0D-15) CYCLE
        VEC3(EA_AD2(ID),AD1(IC))=VEC3(EA_AD2(ID),AD1(IC))+DFLOAT(EA_SN2(ID)*SN1(IC))*VEC1(IB,IA)*VEC2(ID,IC)
       ENDDO
      ENDDO

     ENDDO
    ENDDO
    ! AT THIS POINT, VEC3 CONTAINS T TO THE POWER OF IPOWER.  VEC3 IS COPIED TO VEC2 FOR NEXT ITERATION,
    ! AND VEC3 IS ADDED TO THE VECTOR STORED IN 91.
    VEC3=VEC3/DFLOAT(IPOWER)
    REWIND(OUTFILE)
    READ(OUTFILE) VEC2
    VEC2=VEC2+VEC3
    REWIND(OUTFILE)
    WRITE(OUTFILE) VEC2
    VEC2=VEC3
   ENDDO
   
   DEALLOCATE(VEC1,VEC2,VEC3)
   DEALLOCATE(AD1,EA_AD2,SN1,EA_SN2,LC1,EA_LC2)

   RETURN
END SUBROUTINE



SUBROUTINE REL_FULL_EA_EFF_H(TORDER,RORDER)
! FORM FULL EFFECTIVE HAMILTONIAN EXP(-T)HEXP(T) AND DIAGONALIZE IT BY LINPACK/LAPACK/BLAS SUBROUTINES.
! CAUTION, DO NOT USE THIS FOR PRODUCTION RUN.  THE ORDER OF CLUSTER EXPANSION SHOULD BE GIVEN BY TORDER
! AND THE CORRESPONDING T-AMPLITUDES MUST BE PROVIDED IN FILE 90.  THE ORDER OF LINEAR OPERATOR SHOULD BE
! GIVEN BY RORDER.  ELECTRON AFFINITY CALCULATIONS.

   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   LOGICAL,PARAMETER :: LEVEC = .FALSE.
   INTEGER :: RORDER,TORDER
   INTEGER :: IA,IB,IC,ID
   INTEGER :: INFO
   REAL :: MEM,DEV
   DOUBLE PRECISION,ALLOCATABLE :: HAM(:,:),VL(:,:),VR(:,:),ER(:),EI(:),WK(:)
   DOUBLE PRECISION,ALLOCATABLE :: TRL(:,:)

   WRITE(6,'(A)') 'ELECTRON-AFFINITY EQUATION-OF-MOTION COUPLED CLUSTER CALCULATION FOR ALL STATES'
   WRITE(6,'(I2,A)') TORDER,'-ORDER COUPLED CLUSTER SIMILARITY TRANSFORMATION'
   WRITE(6,'(I2,A,I2,A)') RORDER-1,'-HOLE ',RORDER,'-PARTICLE LINEAR EXCITATION OPERATOR'
   IF (LEVEC) THEN
    MEM=16.0*(2.0D0*(NCF*EA_NCF)**2+8.0*NCF*EA_NCF)
   ELSE
    MEM=16.0*((NCF*EA_NCF)**2+9.0*NCF*EA_NCF)
   ENDIF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
    ALLOCATE(HAM(NCF*EA_NCF,NCF*EA_NCF),VL(1,NCF*EA_NCF),ER(NCF*EA_NCF),EI(NCF*EA_NCF),WK(4*NCF*EA_NCF))
   IF (LEVEC) THEN
    ALLOCATE(VR(NCF*EA_NCF,NCF*EA_NCF))
   ELSE
    ALLOCATE(VR(1,NCF*EA_NCF))
   ENDIF
   ALLOCATE(TRL(EA_NCF,NCF))

   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')
   OPEN(90,FILE=TRIM(COPTN(1))//'.fq0',FORM='UNFORMATTED')

   ! FORM HAMILTONIAN AND KEEP IT IN MEMORY
   HAM=0.0D0
   DO IA=1,NCF
    DO IB=1,EA_NCF
     TRL=0.0D0
     IF (NORDER(IA)+EA_NORDER(IB) <= RORDER) TRL(IB,IA)=1.0D0
     ! |B>=EXP(T)|A>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_EA_EXPONENTIAL_OPERATOR(90,50,60,TORDER,.FALSE.)
     REWIND(60)
     READ(60) TRL
     ! |C>=H|B>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_EA_HAMILTONIAN_PRODUCT(50,60,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE))
     REWIND(60)
     READ(60) TRL
     ! |D>=EXP(-T)|C>
     REWIND(50)
     WRITE(50) TRL
     CALL REL_EA_EXPONENTIAL_OPERATOR(90,50,60,TORDER,.TRUE.)
     REWIND(60)
     READ(60) TRL
     DO IC=1,NCF
      DO ID=1,EA_NCF
       HAM((IA-1)*EA_NCF+IB,(IC-1)*EA_NCF+ID)=TRL(ID,IC)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
!  CALL DUMP5(HAM,NCF*EA_NCF)

   DEALLOCATE(TRL)
   CLOSE(50)
   CLOSE(60)
   CLOSE(90)

   ! DIAGONALIZE HAMILTONIAN
   IF (LEVEC) THEN
    CALL DGEEV('N','V',NCF*EA_NCF,HAM,NCF*EA_NCF,ER,EI,VL,1,VR,NCF*EA_NCF,WK,4*NCF*EA_NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF*EA_NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT(NCF*EA_NCF,NCF*EA_NCF,ER,VR,EI)
    DO IA=1,MIN(25,NCF*EA_NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
     DO IB=1,NCF*EA_NCF
      WRITE(6,'(I10,F20.15)') IB,VR(IB,IA)
     ENDDO
    ENDDO
   ELSE
    CALL DGEEV('N','N',NCF*EA_NCF,HAM,NCF*EA_NCF,ER,EI,VL,1,VR,1,WK,4*NCF*EA_NCF,INFO)
    IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
    DEV=0.0D0
    DO IA=1,NCF*EA_NCF
     DEV=DEV+EI(IA)**2
    ENDDO
    IF (DEV > 1.0E-5) THEN
     CALL WARNING('THE IMAGINARY PART OF THE EIGENVALUES IS NOT ZERO')
     WRITE(6,'(A,F20.10)') 'DEVIATION = ',DEV
    ENDIF
    CALL PIKSRT_EVALONLY(NCF*EA_NCF,ER)
    DO IA=1,MIN(25,NCF*EA_NCF)
     WRITE(6,'(A,I3,A,F20.15,A)') 'STATE ',IA,' ENERGY = ', ER(IA)+NUCLEAR_REPULSION,' HARTREE'
    ENDDO
   ENDIF
   CALL PFLUSH(6)

   DEALLOCATE(HAM,ER,EI,VL,VR,WK)

   RETURN
END SUBROUTINE



SUBROUTINE REL_EOMEACC(TORDER,RORDER,NROOTS,NTRIALS)
! PERFORM HIGH-ORDER ELECTRON AFFINITY EQUATION-OF-MOTION COUPLED CLUSTER CALCULATIONS BY HIRAO-NAKATSUJI ALGORITHM.
! K.HIRAO & H.NAKATSUJI,J.COMPUT.PHYS.45,246(1982).

   USE CONSTANTS
   USE CONTROL
   USE GRADIENT
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI

   IMPLICIT NONE
   INTEGER,PARAMETER :: MAXFILE = 1000
   INTEGER,PARAMETER :: MAXCYCLE = 1000
   INTEGER :: ICYCLE
   INTEGER :: TORDER
   INTEGER :: RORDER
   INTEGER :: NROOTS
   INTEGER :: NTRIALS
   INTEGER :: NTRIALS_NEXT
   INTEGER :: IA,IB
   INTEGER :: I,J,K,L,NOPEN
   INTEGER :: INFO
   INTEGER,ALLOCATABLE :: N(:)
   REAL :: MEM,ICPUS,ICPUE
   LOGICAL :: LDONE(MAXFILE)
   DOUBLE PRECISION :: DEVSQ,DEVMAX,D,F,S2
   DOUBLE PRECISION :: SMALLH(MAXFILE,MAXFILE),EEOMCC(MAXFILE)
   DOUBLE PRECISION :: VR(MAXFILE,MAXFILE),VL(1,MAXFILE),ER(MAXFILE),EI(MAXFILE),WK(4*MAXFILE)
   DOUBLE PRECISION :: PERCENTS,PERCENTD
   DOUBLE PRECISION,ALLOCATABLE :: VEC1(:,:),VEC2(:,:)

   CALL PCPU_TIME(ICPUS)
   WRITE(6,'(A)') 'HIGH-ORDER ELECTRON-AFFINITY EQUATION-OF-MOTION COUPLED CLUSTER CALCULATIONS WILL BE PERFORMED'
   WRITE(6,'(A,I2)') 'THE ORDER OF COUPLED CLUSTER            = ',TORDER
   WRITE(6,'(A,I2,A,I2,A)') 'THE ORDER OF ELECTRON ATTACHMENT OPERATOR = ',RORDER-1,'-HOLE ',RORDER,'-PARTICLE'
   WRITE(6,'(A,I4)') 'THE NUMBER OF EAEOMCC ROOTS SOUGHT ',NROOTS
   WRITE(6,'(A,I4)') 'THE NUMBER OF INITIAL TRIAL VECTORS ',NTRIALS
   MEM=16.0*2.0*NCF*EA_NCF
   IF (MEM > 1000000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
   ELSE IF (MEM > 1000.0) THEN
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
   ELSE
    WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
   ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 
   WRITE(6,'(A)') '--------------------------------------------------------'
   WRITE(6,'(A)') '             DEVIATION          TOTAL ENERGY   CPU / SEC'
   ALLOCATE(VEC1(EA_NCF,NCF),VEC2(EA_NCF,NCF),N(IALLMAX-IVIRTCORE))
   OPEN(50,FILE=TRIM(COPTN(1))//'.fi0',FORM='UNFORMATTED')
   OPEN(51,FILE=TRIM(COPTN(1))//'.fo0',FORM='UNFORMATTED')
   OPEN(60,FILE=TRIM(COPTN(1))//'.fw0',FORM='UNFORMATTED')
   OPEN(61,FILE=TRIM(COPTN(1))//'.fw1',FORM='UNFORMATTED')
   OPEN(90,FILE=TRIM(COPTN(1))//'.fq0',FORM='UNFORMATTED')

   ! INITIALIZE
   LDONE=.FALSE.
   IF (NTRIALS > MAXFILE) CALL PABORT('TOO MANY INITIAL TRIAL VECTORS')

   ! HIRAO-NAKATSUJI ITERATIONS
   DO ICYCLE=1,MAXCYCLE

    ! FORM EXP(-T) H EXP(T)|A> AND STORE THEM IN FILE 51
    REWIND(50)
    REWIND(51)
    DO I=1,NTRIALS
     READ(50) VEC1 ! RETRIEVE A TRIAL VECTOR
     IF (.NOT.LDONE(I)) THEN
      ! |B>=EXP(T)|A>
      REWIND(60)
      WRITE(60) VEC1
      CALL REL_EA_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.FALSE.)
      REWIND(61)
      READ(61) VEC1
      ! |C>=H|B>
      REWIND(60)
      WRITE(60) VEC1
      DEALLOCATE(VEC1,VEC2)
      CALL REL_EA_HAMILTONIAN_PRODUCT(60,61,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE))
      ALLOCATE(VEC1(EA_NCF,NCF),VEC2(EA_NCF,NCF))
      REWIND(61)
      READ(61) VEC1
      ! |D>=EXP(-T)|C>
      REWIND(60)
      WRITE(60) VEC1
      CALL REL_EA_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.TRUE.)
      REWIND(61)
      READ(61) VEC1
      WRITE(51) VEC1
      LDONE(I)=.TRUE.
     ELSE
      READ(51) VEC2 ! DUMMY READING
     ENDIF
    ENDDO

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|N> FOR DEBUG
!   DO I=1,NTRIALS
!    REWIND(50)
!    DO J=1,I
!     READ(50) VEC1
!    ENDDO
!    REWIND(50)
!    DO L=1,NTRIALS
!     READ(50) VEC2
!     SMALLH(I,L)=0.0D0
!     DO IA=1,NCF
!      DO IB=1,EA_NCF
!       SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
!      ENDDO
!     ENDDO
!    ENDDO
!   ENDDO
!   CALL DUMP10(SMALLH,NTRIALS,MAXFILE)

    ! CONSTRUCT SUBSPACE HAMILTONIAN MATRIX <N|H|N>
    REWIND(50)
    DO I=1,NTRIALS
     READ(50) VEC1
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      SMALLH(I,L)=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        SMALLH(I,L)=SMALLH(I,L)+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
!   CALL DUMP10(SMALLH,NTRIALS,MAXFILE)
      
    ! DIAGONALIZE SUBSPACE HAMILTONIAN
    IF (NTRIALS == 1) THEN
     ER(1)=SMALLH(1,1)
     VR(1,1)=1.0D0
    ELSE
     CALL DGEEV('N','V',NTRIALS,SMALLH,MAXFILE,ER,EI,VL,1,VR,MAXFILE,WK,4*MAXFILE,INFO)
     IF (INFO /= 0) CALL PABORT('DGEEV FAILED TO DIAGONALIZE A MATRIX')
     CALL PIKSRT(NTRIALS,MAXFILE,ER,VR,EI)
    ENDIF
!   DO I=1,NTRIALS
!    WRITE(6,'(A,I2,A,F20.15)') 'ROOT ',I,' = ',ER(I)+NUCLEAR_REPULSION
!   ENDDO
      
    ! FORM RESIDUAL VECTORS
    CALL PCPU_TIME(ICPUE)
    DEVMAX=0.0D0
    WRITE(6,'(A,I3)') ' ITER ',ICYCLE
    NTRIALS_NEXT=NTRIALS
    DO K=1,NROOTS
     VEC1=0.0D0
     REWIND(50)
     REWIND(51)
     DO L=1,NTRIALS
      READ(51) VEC2
      VEC1=VEC1+VEC2*VR(L,K)
      READ(50) VEC2
      VEC1=VEC1-ER(K)*VEC2*VR(L,K)
     ENDDO
     DEVSQ=0.0D0
     DO IA=1,NCF
      DO IB=1,EA_NCF
       IF (NORDER(IA)+EA_NORDER(IB) > RORDER) VEC1(IB,IA)=0.0D0
       DEVSQ=DEVSQ+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     DEVSQ=DSQRT(DEVSQ)
     IF (DEVSQ > DEVMAX) DEVMAX=DEVSQ
     EEOMCC(K)=ER(K)+NUCLEAR_REPULSION
     WRITE(6,'(A,I3,F15.10,F20.10,F12.1)') ' ROOT ',K,DEVSQ,EEOMCC(K),(ICPUE-ICPUS)/DFLOAT(NROOTS)
      
     IF (DEVSQ < 1.0D-5) CYCLE

     ! FORM A NEW SUBSPACE VECTOR BY HIRAO-NAKATSUJI SCHEME
     DO IA=1,NCF
      DO IB=1,EA_NCF
       NOPEN=0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        N(I)=0
        IF (BTEST(CFHALF(IA),I-1)) N(I)=1
        IF (BTEST(CFHALF(IB),I-1)) N(I)=N(I)+1
        NOPEN=NOPEN+N(I)*(2-N(I))
       ENDDO
       IF ((NOPEN == 0).OR.(NOPEN == 1)) THEN
        F=0.0D0
       ELSE
        F=(3.0D0-DFLOAT(NOPEN))/DFLOAT(NOPEN*(NOPEN-1))
       ENDIF
       D=0.0D0
       DO I=1,IALL(0,0,0)-IVIRTCORE
        D=D+DFLOAT(N(I))*H(I,I)-DFLOAT(N(I)*(2-N(I)))*G(I,I,I,I)/4.0D0
        DO J=1,IALL(0,0,0)-IVIRTCORE
         D=D+DFLOAT(N(I)*N(J))*(2.0D0*G(I,I,J,J)-G(I,J,J,I))/4.0D0
         IF (I /= J) D=D-F*DFLOAT(N(I)*(2-N(I))*N(J)*(2-N(J)))*G(I,J,J,I)/4.0D0
        ENDDO
       ENDDO
       IF ((ER(K)-D) /= 0.0D0) VEC1(IB,IA)=VEC1(IB,IA)/(ER(K)-D)
      ENDDO
     ENDDO
      
     ! ORTHONORMALIZE THE NEW SUBSPACE VECTOR
     REWIND(50)
     DO L=1,NTRIALS_NEXT
      READ(50) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        D=D+VEC1(IB,IA)*VEC2(IB,IA)
       ENDDO
      ENDDO
      VEC1=VEC1-D*VEC2
     ENDDO
     D=0.0D0
     DO IA=1,NCF
      DO IB=1,EA_NCF
       D=D+VEC1(IB,IA)**2
      ENDDO
     ENDDO
     D=DSQRT(D)
     IF (D > 1.0D-8) THEN
      VEC1=VEC1/D
      NTRIALS_NEXT=NTRIALS_NEXT+1
      IF (NTRIALS_NEXT > MAXFILE) CALL PABORT('TOO MANY TRIAL VECTORS')
      REWIND(50)
      DO L=1,NTRIALS_NEXT-1
       READ(50) VEC2
      ENDDO
      WRITE(50) VEC1
     ENDIF

    ENDDO

    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    IF (DEVMAX < 1.0D-5) THEN
     WRITE(6,'(A)') '--------------------------------------------------------'
!    REWIND(51)
     DO I=1,NROOTS
      WRITE(6,'(A,I3,F20.15,A)') 'ROOT ',I,EEOMCC(I),' HARTREE'
      REWIND(50)
      VEC1=0.0D0
      DO L=1,NTRIALS
       READ(50) VEC2
       VEC1=VEC1+VEC2*VR(L,I)
      ENDDO
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        D=D+VEC1(IB,IA)**2
       ENDDO
      ENDDO
      VEC1=VEC1/DSQRT(D)
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        IF (NORDER(IA)+EA_NORDER(IB) == 1) PERCENTS=PERCENTS+VEC1(IB,IA)**2
        IF (NORDER(IA)+EA_NORDER(IB) == 2) PERCENTD=PERCENTD+VEC1(IB,IA)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES (CC) = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES (CC) = ',PERCENTD*1.0D2
!     WRITE(51) VEC1
      REWIND(60)
      WRITE(60) VEC1
      CALL REL_EA_EXPONENTIAL_OPERATOR(90,60,61,TORDER,.FALSE.)
      CALL REL_S_SQUARED_EA(61,0,MIN(IOCC-ICORE,IALL(0,0,0)-IOCC-IVIRTCORE)+MIN(IOCC-ICORE+1,IALL(0,0,0)-IOCC-IVIRTCORE),S2)
      WRITE(6,'(A,F8.4)') ' < S**2 > = ',S2
      REWIND(61)
      READ(61) VEC2
      D=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        D=D+VEC2(IB,IA)**2
       ENDDO
      ENDDO
      VEC2=VEC2/DSQRT(D)
      PERCENTS=0.0D0
      PERCENTD=0.0D0
      DO IA=1,NCF
       DO IB=1,EA_NCF
        IF (NORDER(IA)+EA_NORDER(IB) == 1) PERCENTS=PERCENTS+VEC2(IB,IA)**2
        IF (NORDER(IA)+EA_NORDER(IB) == 2) PERCENTD=PERCENTD+VEC2(IB,IA)**2
       ENDDO
      ENDDO
      WRITE(6,'(A,F6.2)') ' %SINGLES (CI) = ',PERCENTS*1.0D2
      WRITE(6,'(A,F6.2)') ' %DOUBLES (CI) = ',PERCENTD*1.0D2
      DO IA=1,NCF
       DO IB=1,EA_NCF
        IF (DABS(VEC1(IB,IA)) > 0.1D0) WRITE(6,'(A,I6,A,I6,A,F8.4)') &
        ' EFFECTIVE DETERMINANT (',IA,'-ALPHA ',IB,'-BETA ) ',VEC1(IB,IA)
       ENDDO
      ENDDO
     ENDDO
!    REWIND(50)
!    REWIND(51)
!    DO I=1,NROOTS
!     READ(51) VEC1
!     WRITE(50) VEC1
!    ENDDO
     DEALLOCATE(VEC1,VEC2,N)
     CLOSE(50)
     CLOSE(51)
     CLOSE(60)
     CLOSE(61)
     CLOSE(90)
     RETURN
    ELSE IF (NTRIALS_NEXT == NTRIALS) THEN
     CALL PABORT('ALGORITHM FAILED TO INCREASE THE SUBSPACE')
    ELSE IF (NROOTS > 1) THEN
     WRITE(6,'(I3,A)') NTRIALS_NEXT-NTRIALS,' TRIAL VECTORS HAVE BEEN ADDED'
    ENDIF
    NTRIALS=NTRIALS_NEXT

   ENDDO
   CALL PABORT('HIRAO-NAKATSUJI ALGORITHM FAILED TO CONVERGE')

END SUBROUTINE



SUBROUTINE REL_S_SQUARED_EA(INFILE,OFFSET,ORDER,S2)
! OPERATE WITH S**2 = S+ S- - SZ + SZ**2 A INPUT VECTOR IN INFILE
! AND INTEGRATE WITH ITSELF TO GET AN EXPECTATION VALUE OF S**2.  
! THE ORDER LIMITS THE NUMBER EXCITATION IN THE CONFIGURATIONS CONSIDERED.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE REL_FULLCI
   
   IMPLICIT NONE
   INTEGER :: INFILE,OFFSET
   INTEGER :: ORDER
   INTEGER :: ISIGN,JSIGN
   INTEGER :: I,J,K
   INTEGER :: IA,IB,IC,ID
   INTEGER(4) :: CFA0,CFB0,CFA1,CFB1,CFA2,CFB2
   REAL :: MEM
   DOUBLE PRECISION :: S2,NORM
   DOUBLE PRECISION,ALLOCATABLE :: INP(:,:),OUT(:,:)

!  CALL PCPU_TIME(ICPUS)
   MEM=16.0*2.0*NCF*EA_NCF+4.0*2.0*NCF*(IALL(0,0,0)-IVIRTCORE)**2
!  IF (MEM > 1000000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000000.0,' MB'
!  ELSE IF (MEM > 1000.0) THEN
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM/1000.0,' KB'
!  ELSE
!   WRITE(6,'(A,F7.1,A)') 'ESTIMATED MEMORY USAGE WILL BE ',MEM,' B'
!  ENDIF
   IF (MEM > DOPTN(28)*1000000.0) CALL PABORT('OUT OF MEMORY') 

   ALLOCATE(INP(EA_NCF,NCF),OUT(EA_NCF,NCF))

   ! READ INPUT VECTOR FROM FILE INFILE
   REWIND(INFILE)
   DO I=0,OFFSET
    READ(INFILE) INP
   ENDDO

   ! ZERO SCRATCH INPUT VECTOR ELEMENTS ASSOCIATED WITH EXCITATION HIGHER THAN THE ORDER
   NORM=0.0D0
   DO IA=1,NCF
    DO IB=1,EA_NCF
     IF (NORDER(IA)+EA_NORDER(IB) > ORDER) INP(IB,IA)=0.0D0
     NORM=NORM+INP(IB,IA)**2
    ENDDO
   ENDDO

   ! ZERO SCRATCH OUTPUT VECTOR
   OUT=0.0D0

   ! S+ S-
   DO IA=1,NCF
    DO IB=1,EA_NCF
     CFA0=CFHALF(IA)
     CFB0=EA_CFHALF(IB)
     ! OPERATE WITH S-
     DO I=1,IALL(0,0,0)-IVIRTCORE
      IF (BTEST(CFA0,I-1).AND.(.NOT.BTEST(CFB0,I-1))) THEN
       CFA1=IBCLR(CFA0,I-1)
       CFB1=IBSET(CFB0,I-1)
       ISIGN=1
       DO J=1,I
        IF (BTEST(CFA0,J-1)) ISIGN=-ISIGN
        IF (BTEST(CFB1,J-1)) ISIGN=-ISIGN
       ENDDO
       ! OPERATE WITH S+
       DO J=1,IALL(0,0,0)-IVIRTCORE
        IF ((.NOT.BTEST(CFA1,J-1)).AND.BTEST(CFB1,J-1)) THEN
         CFA2=IBSET(CFA1,J-1)
         CFB2=IBCLR(CFB1,J-1)
         JSIGN=1
         DO K=1,J
          IF (BTEST(CFA2,K-1)) JSIGN=-JSIGN
          IF (BTEST(CFB1,K-1)) JSIGN=-JSIGN
         ENDDO
         IC=ADDRSS(CFA2)
         ID=EA_ADDRSS(CFB2)
         OUT(ID,IC)=OUT(ID,IC)+DFLOAT(ISIGN*JSIGN)*INP(IB,IA)
        ENDIF
       ENDDO
      ENDIF
     ENDDO
    ENDDO
   ENDDO

   ! SZ ( SZ-1 )
   DO IA=1,NCF
    DO IB=1,EA_NCF
     OUT(IB,IA)=OUT(IB,IA)+(3.0D0/4.0D0)*INP(IB,IA)
    ENDDO
   ENDDO

   S2=0.0D0
   DO IA=1,NCF
    DO IB=1,EA_NCF
     IF (NORDER(IA)+EA_NORDER(IB) > ORDER) CYCLE
     S2=S2+INP(IB,IA)*OUT(IB,IA)/NORM
    ENDDO
   ENDDO

   DEALLOCATE(INP,OUT)

   RETURN
END SUBROUTINE

