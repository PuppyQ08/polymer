SUBROUTINE OPTIMIZED_EFFECTIVE_POTENTIAL(ISCF,N,EXPAND)
! FORM THE EXCHANGE INTEGRAL MATRIX BASED ON THE OPTIMIZED EFFECTIVE POTENTIAL METHOD.
! USES THE THREE-CENTER OVERLAP INTEGRALS STORED EXTERNALLY.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE AUXILIARY
   USE BASISSET
   USE INTEGRAL
   USE OEP
   USE DFT

   IMPLICIT NONE
   INTEGER :: ISCF
   INTEGER :: N
   INTEGER,PARAMETER :: CASHESIZE = 1000
   INTEGER :: REDUCED_NAGS,REDUCED_REDUCED_NAGS
   INTEGER :: MOP,MOQ,MOA,MOI
   INTEGER :: ICASHECOUNT,EOF
   INTEGER,ALLOCATABLE :: INDX(:)
   INTEGER(4),ALLOCATABLE :: ICASHE1(:),ICASHE2(:)
   INTEGER :: I,J,K,L,P,Q
   DOUBLE PRECISION :: EXPAND(N)
   DOUBLE COMPLEX,ALLOCATABLE :: X_M(:,:)    ! MO BASED HF EXCHANGE MATRIX
   DOUBLE COMPLEX,ALLOCATABLE :: Y_M(:,:)    ! MO BASED SLATER EXCHANGE MATRIX
   DOUBLE COMPLEX,ALLOCATABLE :: S(:,:),V1(:,:),V2(:,:),WC1(:,:),WC2(:),WC3(:)
   DOUBLE COMPLEX,ALLOCATABLE :: CANN1(:,:,:),CANN2(:,:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: CHI(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: WR1(:,:),WR2(:)
   DOUBLE PRECISION,ALLOCATABLE :: DCASHE(:)
   DOUBLE PRECISION :: A,B

   IF ((KVC /= 0).OR.(CEL1 /= 0)) CALL PABORT('OEP CALCULATIONS CAN ONLY BE PERFORMED FOR MOLECULES')
   IF ((ICORE /= 0).OR.(IVIRTCORE /= 0)) CALL PABORT('FROZEN CORE/VIRTUAL NYI')
   
   ! CONSTRUCT HF EXCHANGE MATRIX IN THE MO BASIS
   ALLOCATE(X_M(IALLMAX,IALLMAX))
   ALLOCATE(WC1(NCGS,IALLMAX))
   DO MOP=1,IALL(0)
    DO I=1,NCGS
     WC1(I,MOP)=DCMPLX(0.0D0,0.0D0)
     DO J=1,NCGS
      WC1(I,MOP)=WC1(I,MOP)+X_C(I,J,0)*DCONJG(CO(J,MOP,0))
     ENDDO
    ENDDO
   ENDDO
   DO MOQ=1,IALL(0)
    DO MOP=1,IALL(0)
     X_M(MOQ,MOP)=DCMPLX(0.0D0,0.0D0)
     DO I=1,NCGS
      X_M(MOQ,MOP)=X_M(MOQ,MOP)+WC1(I,MOP)*CO(I,MOQ,0)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(WC1)
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'HF EXCHANGE MATRIX IN THE MO BASIS'
    CALL DUMP7(X_M,IALLMAX)
   ENDIF

   ! CONSTRUCT SLATER EXCHANGE MATRIX IN THE MO BASIS
   IF (IOPTN(71) >= 3) THEN
    CALL LOCAL_EXCHANGE_CORRELATION
    ALLOCATE(Y_M(IALLMAX,IALLMAX))
    ALLOCATE(WC1(NCGS,IALLMAX))
    DO MOP=1,IALL(0)
     DO I=1,NCGS
      WC1(I,MOP)=DCMPLX(0.0D0,0.0D0)
      DO J=1,NCGS
       WC1(I,MOP)=WC1(I,MOP)+Y_C(I,J,0)*DCONJG(CO(J,MOP,0))
      ENDDO
     ENDDO
    ENDDO
    DO MOQ=1,IALL(0)
     DO MOP=1,IALL(0)
      Y_M(MOQ,MOP)=DCMPLX(0.0D0,0.0D0)
      DO I=1,NCGS
       Y_M(MOQ,MOP)=Y_M(MOQ,MOP)+WC1(I,MOP)*CO(I,MOQ,0)
      ENDDO
     ENDDO
    ENDDO
    DEALLOCATE(WC1)
    IF (IOPTN(9) == 3) THEN
     WRITE(6,'(A)') 'SLATER EXCHANGE MATRIX IN THE MO BASIS'
     CALL DUMP7(Y_M,IALLMAX)
    ENDIF
   ENDIF

   ! FORM AUXILIARY OVERLAP
   ALLOCATE(S(NAGS,NAGS),V1(NAGS,NAGS))
   ALLOCATE(WC1(NAGS,NAGS),WR1(NAGS,NAGS),WR2(NAGS))
   IF (IOPTN(71) == 1) CALL TWOINDEX_V(WR1,NAGS,0)
   IF (IOPTN(71) >= 2) CALL TWOINDEX_S(WR1,NAGS,0)
   DO I=1,NAGS
    DO J=1,NAGS
     S(J,I)=DCMPLX(WR1(J,I),0.0D0)
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'TWO-CENTER AUXILIARY OVERLAP MATRIX'
    CALL DUMP7(S,NAGS)
   ENDIF

   ! DIAGONALIZE AUXILIARY OVERLAP
   CALL HHBS(NAGS,NAGS,S,WR2,WC1)
   REDUCED_NAGS=0
   DO I=1,NAGS
    IF (WR2(I) > DOPTN(85)) THEN
     REDUCED_NAGS=REDUCED_NAGS+1
     DO J=1,NAGS
      V1(J,REDUCED_NAGS)=WC1(J,I)/DSQRT(WR2(I))
     ENDDO
    ENDIF
   ENDDO
   DEALLOCATE(S,WC1,WR1,WR2)
   IF ((ISCF == 1).AND.(REDUCED_NAGS < NAGS)) &
   WRITE(6,'(I3,A)') NAGS-REDUCED_NAGS,' LINEARLY DEPENDENT AUXILIARY FUNCTIONS HAVE BEEN DISCARDED'

   ! RESTORE THREE-INDEX OVERLAP INTEGRALS
   ALLOCATE(ICASHE1(CASHESIZE),ICASHE2(CASHESIZE),DCASHE(CASHESIZE))
   ALLOCATE(CANN1(REDUCED_NAGS,NCGS,NCGS))
   CANN1(1:REDUCED_NAGS,1:NCGS,1:NCGS)=DCMPLX(0.0D0,0.0D0)
   DO K=1,REDUCED_NAGS
    IF (IOPTN(71) == 1) REWIND(32) ! AO-BASED THREE-INDEX ELECTRON REPULSION INTEGRAL FILE
    IF (IOPTN(71) >= 2) REWIND(35) ! AO-BASED THREE-INDEX OVERLAP INTEGRAL FILE
    DO
     IF (IOPTN(71) == 1) READ(32,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
     IF (IOPTN(71) >= 2) READ(35,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
     IF (EOF /= 0) EXIT
     DO ICASHECOUNT=1,CASHESIZE
      IF (ICASHE1(ICASHECOUNT) == -1) EXIT
      P=0
      Q=0
      I=0
      J=0
      L=0
      CALL MVBITS(ICASHE1(ICASHECOUNT), 8, 8,P,0)
      CALL MVBITS(ICASHE1(ICASHECOUNT), 0, 8,Q,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT),24, 8,I,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT),16, 8,J,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT), 0,16,L,0)
      CANN1(K,I,J)=CANN1(K,I,J)+V1(L,K)*DCASHE(ICASHECOUNT)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(ICASHE1,ICASHE2,DCASHE)

   ! TRANSFORM THREE-INDEX OVERLAP INTEGRALS FROM AO TO MO BASIS
   ALLOCATE(CANN2(REDUCED_NAGS,IALLMAX,IALLMAX),WC1(NCGS,IALLMAX))
   CANN2(1:REDUCED_NAGS,1:IALLMAX,1:IALLMAX)=DCMPLX(0.0D0,0.0D0)
   DO L=1,REDUCED_NAGS
    DO I=1,NCGS
     DO MOP=1,IALL(0)
      WC1(I,MOP)=DCMPLX(0.0D0,0.0D0)
      DO J=1,NCGS
       WC1(I,MOP)=WC1(I,MOP)+CO(J,MOP,0)*CANN1(L,I,J)
      ENDDO
     ENDDO
    ENDDO
    DO MOP=1,IALL(0)
     DO MOQ=1,IALL(0)
      DO I=1,NCGS
       CANN2(L,MOQ,MOP)=CANN2(L,MOQ,MOP)+DCONJG(CO(I,MOQ,0))*WC1(I,MOP)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(WC1)

   ! FORM MATRIX REPRESENTATION OF CHI
   ALLOCATE(CHI(REDUCED_NAGS,REDUCED_NAGS))
   DO I=1,REDUCED_NAGS
    DO J=1,REDUCED_NAGS
     CHI(J,I)=DCMPLX(0.0D0,0.0D0)
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       CHI(J,I)=CHI(J,I)+2.0D0*CANN2(J,MOI,MOA)*CANN2(I,MOA,MOI)/(EPSILON(MOI,0)-EPSILON(MOA,0))
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'MATRIX REPRESENTATION OF CHI'
    CALL DUMP7(CHI,REDUCED_NAGS)
   ENDIF

   ! DIAGONALIZE CHI REP TO SEE HOW MANY SINGULARITIES ARE THERE
   ALLOCATE(WR2(REDUCED_NAGS),WC1(REDUCED_NAGS,REDUCED_NAGS),V2(REDUCED_NAGS,REDUCED_NAGS))
   CALL HHBS(REDUCED_NAGS,REDUCED_NAGS,CHI,WR2,WC1)
   REDUCED_REDUCED_NAGS=0
   DO I=1,REDUCED_NAGS
    IF (DABS(WR2(I)) > DABS(WR2(1))*DOPTN(96)) THEN
     REDUCED_REDUCED_NAGS=REDUCED_REDUCED_NAGS+1
     DO J=1,REDUCED_NAGS
      V2(J,REDUCED_REDUCED_NAGS)=WC1(J,I)
     ENDDO
    ENDIF
   ENDDO
   IF ((ISCF == 1).AND.(REDUCED_REDUCED_NAGS < REDUCED_NAGS)) WRITE(6,'(I3,A)') REDUCED_NAGS-REDUCED_REDUCED_NAGS, &
   ' SINGULARITIES IN THE MATRIX REPRESENTATION OF THE RESPONSE FUNCTION HAVE BEEN REMOVED'
   DEALLOCATE(CHI,WC1)

   ! FORM INVERSE OF CHI
   DO I=1,REDUCED_NAGS
    DO J=1,REDUCED_NAGS
     CHI_INVERSE(J,I)=DCMPLX(0.0D0,0.0D0)
     DO K=1,REDUCED_REDUCED_NAGS
      CHI_INVERSE(J,I)=CHI_INVERSE(J,I)+V2(J,K)*V2(I,K)/WR2(K)
     ENDDO
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'MATRIX REPRESENTATION OF CHI INVERSE'
    CALL DUMP7(CHI_INVERSE,NAGS)
   ENDIF
   DEALLOCATE(V2,WR2)

   ! FORM OEP EXCHANGE INTEGRAL MATRIX
   ALLOCATE(WC2(REDUCED_NAGS),WC3(REDUCED_NAGS))
   IF (IOPTN(71) <= 2) THEN
    DO I=1,REDUCED_NAGS
     WC2(I)=DCMPLX(0.0D0,0.0D0)
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       WC2(I)=WC2(I)+(CANN2(I,MOA,MOI)*X_M(MOI,MOA)+CANN2(I,MOI,MOA)*X_M(MOA,MOI))/(EPSILON(MOI,0)-EPSILON(MOA,0))
      ENDDO
     ENDDO
    ENDDO
   ELSE
    DO I=1,REDUCED_NAGS
     WC2(I)=DCMPLX(0.0D0,0.0D0)
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       WC2(I)=WC2(I)+(CANN2(I,MOA,MOI)*(X_M(MOI,MOA)+2.0D0*Y_M(MOI,MOA))+CANN2(I,MOI,MOA)*(X_M(MOA,MOI)+2.0D0*Y_M(MOA,MOI))) &
       /(EPSILON(MOI,0)-EPSILON(MOA,0))
      ENDDO
     ENDDO
    ENDDO
    DEALLOCATE(Y_M)
   ENDIF
   DO I=1,REDUCED_NAGS
    WC3(I)=DCMPLX(0.0D0,0.0D0)
    DO J=1,REDUCED_NAGS
     WC3(I)=WC3(I)+CHI_INVERSE(I,J)*WC2(J)
    ENDDO
   ENDDO
   DO I=1,NCGS
    DO J=1,NCGS
     IF (IOPTN(71) <= 2) O_C(J,I,0)=0.0D0
     IF (IOPTN(71) >= 3) O_C(J,I,0)=-2.0D0*Y_C(J,I,0)
     DO K=1,REDUCED_NAGS
      O_C(J,I,0)=O_C(J,I,0)+DREAL(CANN1(K,J,I)*WC3(K))
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(WC2,CANN1,CANN2)
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'OEP EXCHANGE INTEGRAL MATRIX'
    CALL DUMP1(O_C,NCGS,0)
   ENDIF

   ! COMPUTE CONSTANT SHIFT IN THE ONE-ELECTRON ENERGIES
   A=X_M(IOCC,IOCC)
   ALLOCATE(WC2(NCGS))
   DO I=1,NCGS
    WC2(I)=DCMPLX(0.0D0,0.0D0)
    DO J=1,NCGS
     WC2(I)=WC2(I)+O_C(I,J,0)*DCONJG(CO(J,IOCC,0))
    ENDDO
   ENDDO
   B=0.0D0
   DO I=1,NCGS
    B=B+WC2(I)*CO(I,IOCC,0)
   ENDDO
   DEALLOCATE(WC2,X_M)
   OEPSHIFT=(B-A)/2.0D0

   ! COMPUTE THE EXPANSION COEFFICIENT FOR POTENTIAL PLOT
   IF (ISCF == -1) THEN
    IF (N /= NAGS) CALL PABORT('THE LENGTH OF ARRAY EXPAND IS INCONSISTENT')
    DO I=1,NAGS
     EXPAND(I)=0.0D0
     DO J=1,REDUCED_NAGS
      EXPAND(I)=EXPAND(I)+DREAL(V1(I,J)*WC3(J))
     ENDDO
    ENDDO
   ENDIF
   DEALLOCATE(WC3,V1)

   RETURN
END SUBROUTINE



SUBROUTINE POTENTIAL_DUMP
! DUMP THE NUMERICAL VALUES OF THE EXCHANGE POTENTIALS (OEP, SLATER, BECKE88)
! AT LEBEDEV-CHEBYSHEV GRID POINTS.

   USE CONTROL
   USE STRUCTURE
   USE GRADIENT
   USE INTEGRAL
   USE BASISSET
   USE AUXILIARY
   USE DFT
   USE OEP

   IMPLICIT NONE
   INTEGER :: I,J,N
   REAL :: ICPUS,ICPUE
   DOUBLE PRECISION :: X,Y,Z,DUMMY1,DUMMY2
   DOUBLE PRECISION :: VIRIAL
   DOUBLE PRECISION,ALLOCATABLE :: P0(:),P1(:),P2(:),P3(:),P4(:),P5(:),P6(:)
   DOUBLE PRECISION,ALLOCATABLE :: E0(:)

   WRITE(6,'(A,I2,A)') 'DUMP EXCHANGE POTENTIALS'
   ALLOCATE(P0(MAXNGRID*NATOM),P1(MAXNGRID*NATOM),P2(MAXNGRID*NATOM),P3(MAXNGRID*NATOM), &
            P4(MAXNGRID*NATOM),P5(MAXNGRID*NATOM),P6(MAXNGRID*NATOM),E0(NAGS))

   IF (IOPTN(74) == -1) THEN

    ! GRID POINTS
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P0(N)=GRIDX(J,I)+ATOMX(I)
      ENDIF
     ENDDO
    ENDDO

    ! OEP
    CALL PCPU_TIME(ICPUS)
    IF (IOPTN(71) == 3) THEN
     CALL ELECTRON_DENSITY
     D1F1=0.0D0
     CALL SLATER51_EXCHANGE
     D1F1_GUESS=D1F1
    ELSE IF (IOPTN(71) == 4) THEN
     CALL ELECTRON_DENSITY
     D1F1=0.0D0
     CALL KLI_EXCHANGE
     D1F1_GUESS=D1F1
    ENDIF
    CALL OPTIMIZED_EFFECTIVE_POTENTIAL(-1,NAGS,E0)
    DO I=1,NATOM
     DO J=1,NGRID(I)
      CALL CONTRACT_POTENTIAL(NAGS,E0,GRIDX(J,I)+ATOMX(I),GRIDY(J,I)+ATOMY(I),GRIDZ(J,I)+ATOMZ(I),D1F1(J,I))
     ENDDO
    ENDDO
    IF (IOPTN(71) >= 3) D1F1=D1F1+D1F1_GUESS
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P6(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    CALL EXCHANGE_VIRIAL_RELATION(OEPSHIFT,VIRIAL)
    WRITE(6,'(A,F20.14,A)') 'OEP EXCHANGE ENERGY FROM VIRIAL RELATIONSHIP = ',VIRIAL,' HARTREE'
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'OEP POTENTIAL HAS BEEN GENERATED      (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PFLUSH(6)

    ! RETRIEVE SVWN
    CALL PCPU_TIME(ICPUS)
    DUMMY1=DOPTN(20)
    DUMMY2=DOPTN(21)
    DOPTN(20)=1.0D0
    DOPTN(21)=1.0D0
    D1F1=0.0D0
    CALL SLATER_EXCHANGE(0)
    CALL VOSKO_WILK_NUSAIR_CORRELATION(0)
    DOPTN(20)=DUMMY1
    DOPTN(21)=DUMMY2
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P1(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    CALL EXCHANGE_VIRIAL_RELATION(0.0D0,VIRIAL)
    WRITE(6,'(A,F20.14,A)') 'SVWN ENERGY FROM VIRIAL RELATIONSHIP = ',VIRIAL,' HARTREE'
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'SVWN POTENTIAL HAS BEEN GENERATED   (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    ! RETRIEVE ASYMPTOTICALLY-CORRECTED SVWN
    CALL PCPU_TIME(ICPUS)
    DUMMY1=DOPTN(20)
    DUMMY2=DOPTN(21)
    DOPTN(20)=1.0D0
    DOPTN(21)=1.0D0
    D1F1=0.0D0
    CALL SLATER_EXCHANGE(0)
    CALL VOSKO_WILK_NUSAIR_CORRELATION(0)
    CALL LOCAL_EXCHANGE_CORRELATION
    IF (LOPTN(25)) THEN
     CALL FOURINDEX_ERI
    ELSE
     CALL RESTORE_FOURINDEX_ERI
    ENDIF
    CALL ASYMPTOTIC_CORRECTION
    DOPTN(20)=DUMMY1
    DOPTN(21)=DUMMY2
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P2(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    CALL EXCHANGE_VIRIAL_RELATION(0.0D0,VIRIAL)
    WRITE(6,'(A,F20.14,A)') 'SVWN (AC) EXCHANGE ENERGY FROM VIRIAL RELATIONSHIP = ',VIRIAL,' HARTREE'
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'SVWN (AC) POTENTIAL HAS BEEN GENERATED   (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    ! RETRIEVE VWN CORRELATION
!   CALL PCPU_TIME(ICPUS)
!   DUMMY1=DOPTN(21)
!   DOPTN(21)=1.0D0
!   D1F1=0.0D0
!   CALL VOSKO_WILK_NUSAIR_CORRELATION(0)
!   DOPTN(21)=DUMMY1
!   N=0
!   DO I=1,NATOM
!    DO J=1,NGRID(I)
!     IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
!      N=N+1
!      P2(N)=D1F1(J,I)
!     ENDIF
!    ENDDO
!   ENDDO
!   CALL PCPU_TIME(ICPUE)
!   WRITE(6,'(A,F10.1,A)') 'VWN POTENTIAL HAS BEEN GENERATED  (CPU / SEC = ',ICPUE-ICPUS,')'
!   CALL PCPU_TIME(ICPUS)
!   CALL PFLUSH(6)

    ! RETRIEVE BECKE88 EXCHANGE
!   CALL PCPU_TIME(ICPUS)
!   DUMMY1=DOPTN(22)
!   DOPTN(22)=1.0D0
!   D1F1=0.0D0
!   CALL BECKE88_EXCHANGE(0)
!   DOPTN(22)=DUMMY1
!   N=0
!   DO I=1,NATOM
!    DO J=1,NGRID(I)
!     IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
!      N=N+1
!      P2(N)=D1F1(J,I)
!     ENDIF
!    ENDDO
!   ENDDO
!   CALL EXCHANGE_VIRIAL_RELATION(0.0D0,VIRIAL)
!   WRITE(6,'(A,F20.14,A)') 'BECKE88 EXCHANGE ENERGY FROM VIRIAL RELATIONSHIP = ',VIRIAL,' HARTREE'
!   CALL PCPU_TIME(ICPUE)
!   WRITE(6,'(A,F10.1,A)') 'BECKE88 POTENTIAL HAS BEEN GENERATED  (CPU / SEC = ',ICPUE-ICPUS,')'
!   CALL PCPU_TIME(ICPUS)
!   CALL PFLUSH(6)

    ! RETRIEVE LYP CORRELATION
!   CALL PCPU_TIME(ICPUS)
!   DUMMY1=DOPTN(23)
!   DOPTN(23)=1.0D0
!   D1F1=0.0D0
!   CALL LEE_YANG_PARR_CORRELATION(0)
!   DOPTN(23)=DUMMY1
!   N=0
!   DO I=1,NATOM
!    DO J=1,NGRID(I)
!     IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
!      N=N+1
!      P1(N)=D1F1(J,I)
!     ENDIF
!    ENDDO
!   ENDDO
!   CALL PCPU_TIME(ICPUE)
!   WRITE(6,'(A,F10.1,A)') 'LYP POTENTIAL HAS BEEN GENERATED  (CPU / SEC = ',ICPUE-ICPUS,')'
!   CALL PCPU_TIME(ICPUS)
!   CALL PFLUSH(6)

    ! ASYMPTOTE
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P3(N)=-1.0D0/MAX(DSQRT((GRIDX(J,I)+ATOMX(I))**2+(GRIDY(J,I)+ATOMY(I))**2+(GRIDZ(J,I)+ATOMZ(I))**2),1.0D-4+1.0D-16)
      ENDIF
     ENDDO
    ENDDO

    ! RETRIEVE SLATER51 EXCHANGE
    CALL PCPU_TIME(ICPUS)
    D1F1=0.0D0
    CALL SLATER51_EXCHANGE
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P4(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    CALL EXCHANGE_VIRIAL_RELATION(0.0D0,VIRIAL)
    WRITE(6,'(A,F20.14,A)') 'SLATER51 EXCHANGE ENERGY FROM VIRIAL RELATIONSHIP = ',VIRIAL,' HARTREE'
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'SLATER51 POTENTIAL HAS BEEN GENERATED (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    ! RETRIEVE KLI EXCHANGE
    CALL PCPU_TIME(ICPUS)
    D1F1=0.0D0
    CALL KLI_EXCHANGE
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P5(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    CALL EXCHANGE_VIRIAL_RELATION(0.0D0,VIRIAL)
    WRITE(6,'(A,F20.14,A)') 'KLI EXCHANGE ENERGY FROM VIRIAL RELATIONSHIP = ',VIRIAL,' HARTREE'
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'KLI POTENTIAL HAS BEEN GENERATED      (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    CALL SORT(N,MAXNGRID*NATOM,P0,P1,P2,P3,P4,P5,P6)
    WRITE(6,'(A)') '----------------------------------------------------------------------------------------------------------'
!   WRITE(6,'(A)') 'COORDINATE          XALPHA         BECKE88       ASYMPTOTE        SLATER51             KLI             OEP'
!   WRITE(6,'(A)') 'COORDINATE          XALPHA     XALPHA (AC)       ASYMPTOTE        SLATER51             KLI             OEP'
    WRITE(6,'(A)') 'COORDINATE            SVWN       SVWN (AC)       ASYMPTOTE        SLATER51             KLI             OEP'
    DO I=1,N
     WRITE(6,'(F10.5,6(1X,F15.8))') P0(I),P1(I),P2(I),P3(I),P4(I),P5(I),P6(I)
    ENDDO
    WRITE(6,'(A)') '----------------------------------------------------------------------------------------------------------'

   ELSE
    CALL PABORT('UNRECOGNIZED POTDUMP VARIABLE')
   ENDIF

   DEALLOCATE(P0,P1,P2,P3,P4,P5,P6,E0)

   RETURN
END SUBROUTINE



SUBROUTINE DENSITY_DUMP
! DUMP THE NUMERICAL VALUES OF THE (EXCHANGE) ELECTRON DENSITIES
! AT LEBEDEV-CHEBYSHEV GRID POINTS.

   USE CONTROL
   USE STRUCTURE
   USE GRADIENT
   USE INTEGRAL
   USE BASISSET
   USE AUXILIARY
   USE DFT
   USE OEP

   IMPLICIT NONE
   INTEGER :: I,J,N
   REAL :: ICPUS,ICPUE
   DOUBLE PRECISION :: X,Y,Z,DUMMY
   DOUBLE PRECISION,ALLOCATABLE :: P0(:),P1(:),P2(:),P3(:),P4(:),P5(:),P6(:)
   DOUBLE PRECISION,ALLOCATABLE :: E0(:)
   DOUBLE PRECISION :: Q1,Q2,Q3,Q4,Q5,Q6
   DOUBLE PRECISION :: R1,R2,R3,R4,R5,R6

   WRITE(6,'(A,I2,A)') 'DUMP (EXCHANGE) ELECTRON DENSITIES'
   ALLOCATE(P0(MAXNGRID*NATOM),P1(MAXNGRID*NATOM),P2(MAXNGRID*NATOM),P3(MAXNGRID*NATOM),&
            P4(MAXNGRID*NATOM),P5(MAXNGRID*NATOM),P6(MAXNGRID*NATOM),E0(NAGS))

   IF (IOPTN(75) == -1) THEN

    ! GRID POINTS
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P0(N)=GRIDX(J,I)+ATOMX(I)
      ENDIF
     ENDDO
    ENDDO

    ! OEP
    CALL PCPU_TIME(ICPUS)
    IF (IOPTN(71) == 3) THEN
     CALL ELECTRON_DENSITY
     D1F1=0.0D0
     CALL SLATER51_EXCHANGE
     D1F1_GUESS=D1F1
    ELSE IF (IOPTN(71) == 4) THEN
     CALL ELECTRON_DENSITY
     D1F1=0.0D0
     CALL KLI_EXCHANGE
     D1F1_GUESS=D1F1
    ENDIF
    CALL OPTIMIZED_EFFECTIVE_POTENTIAL(-1,NAGS,E0)
    DO I=1,NATOM
     DO J=1,NGRID(I)
      CALL CONTRACT_POTENTIAL(NAGS,E0,GRIDX(J,I)+ATOMX(I),GRIDY(J,I)+ATOMY(I),GRIDZ(J,I)+ATOMZ(I),D1F1(J,I))
     ENDDO
    ENDDO
    IF (IOPTN(71) >= 3) D1F1=D1F1+D1F1_GUESS
    CALL POTENTIAL_TO_DENSITY(R6)
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P6(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    Q6=0.0D0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      Q6=Q6+GRIDW(J,I)*D1F1(J,I)
     ENDDO
    ENDDO
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'OEP POTENTIAL HAS BEEN GENERATED      (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    ! RETRIEVE SLATER EXCHANGE
    CALL PCPU_TIME(ICPUS)
    DUMMY=DOPTN(20)
    DOPTN(20)=1.0D0
    D1F1=0.0D0
    CALL SLATER_EXCHANGE(0)
    DOPTN(20)=DUMMY
    CALL POTENTIAL_TO_DENSITY(R1)
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P1(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    Q1=0.0D0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      Q1=Q1+GRIDW(J,I)*D1F1(J,I)
     ENDDO
    ENDDO
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'XALPHA POTENTIAL HAS BEEN GENERATED   (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    ! RETRIEVE BECKE88 EXCHANGE
    CALL PCPU_TIME(ICPUS)
    DUMMY=DOPTN(22)
    DOPTN(22)=1.0D0
    D1F1=0.0D0
    CALL BECKE88_EXCHANGE(0)
    DOPTN(22)=DUMMY
    CALL POTENTIAL_TO_DENSITY(R2)
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P2(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    Q2=0.0D0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      Q2=Q2+GRIDW(J,I)*D1F1(J,I)
     ENDDO
    ENDDO
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'BECKE88 POTENTIAL HAS BEEN GENERATED  (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    ! ELECTRON DENSITY
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P3(N)=RHO(J,I)
      ENDIF
     ENDDO
    ENDDO
    Q3=0.0D0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      Q3=Q3+GRIDW(J,I)*RHO(J,I)
     ENDDO
    ENDDO

    ! RETRIEVE SLATER51 EXCHANGE
    CALL PCPU_TIME(ICPUS)
    D1F1=0.0D0
    CALL SLATER51_EXCHANGE
    CALL POTENTIAL_TO_DENSITY(R4)
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P4(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    Q4=0.0D0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      Q4=Q4+GRIDW(J,I)*D1F1(J,I)
     ENDDO
    ENDDO
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'SLATER51 POTENTIAL HAS BEEN GENERATED (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    ! RETRIEVE KLI EXCHANGE
    CALL PCPU_TIME(ICPUS)
    D1F1=0.0D0
    CALL KLI_EXCHANGE
    CALL POTENTIAL_TO_DENSITY(R5)
    N=0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      IF ((GRIDY(J,I)+ATOMY(I) == 0.0D0).AND.(GRIDZ(J,I)+ATOMZ(I) == 0.0D0)) THEN
       N=N+1
       P5(N)=D1F1(J,I)
      ENDIF
     ENDDO
    ENDDO
    Q5=0.0D0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      Q5=Q5+GRIDW(J,I)*D1F1(J,I)
     ENDDO
    ENDDO
    CALL PCPU_TIME(ICPUE)
    WRITE(6,'(A,F10.1,A)') 'KLI POTENTIAL HAS BEEN GENERATED      (CPU / SEC = ',ICPUE-ICPUS,')'
    CALL PCPU_TIME(ICPUS)
    CALL PFLUSH(6)

    CALL SORT(N,MAXNGRID*NATOM,P0,P1,P2,P3,P4,P5,P6)
    WRITE(6,'(A)') '----------------------------------------------------------------------------------------------------------'
    WRITE(6,'(A)') 'COORDINATE         DENSITY          XALPHA         BECKE88        SLATER51             KLI             OEP'
    DO I=1,N
     WRITE(6,'(F10.5,6(1X,F15.8))') P0(I),P3(I),P1(I),P2(I),P4(I),P5(I),P6(I)
    ENDDO
    WRITE(6,'(A)') '----------------------------------------------------------------------------------------------------------'
    WRITE(6,'(A)') 'INTEGRATED ELECTRON DENSITIES'
    WRITE(6,'(A,6(1X,F15.8))') '          ',Q3,Q1,Q2,Q4,Q5,Q6
    WRITE(6,'(A)') 'ERRORS IN THE FITTED POTENTIALS'
    WRITE(6,'(A,5(1X,F15.8))') '                          ',R1,R2,R4,R5,R6

   ELSE
    CALL PABORT('UNRECOGNIZED POTDUMP VARIABLE')
   ENDIF

   DEALLOCATE(P0,P1,P2,P3,P4,P5,P6,E0)

   RETURN
END SUBROUTINE



SUBROUTINE CONTRACT_POTENTIAL(N,EXPAND,X,Y,Z,PTL)
! CALCULATE THE VALUE OF POTENTIAL AT EACH GRID POINT.

   USE CONTROL
   USE STRUCTURE
   USE BASISSET
   USE INTEGRAL
   USE GRADIENT
   USE FMT
   USE CONSTANTS
   USE AUXILIARY

   IMPLICIT NONE
   INTEGER :: N
   DOUBLE PRECISION :: EXPAND(N)
   DOUBLE PRECISION :: X,Y,Z,PTL
   DOUBLE PRECISION,ALLOCATABLE :: N1(:,:,:,:),N2(:,:,:),W1(:)
   DOUBLE PRECISION :: PISUB
   DOUBLE PRECISION :: COMZ,FN
   DOUBLE PRECISION :: AX,AY,AZ,E,R2
   DOUBLE PRECISION :: T,H,F1(0:5),F2(0:5)
   INTEGER :: I,II,IATM
   INTEGER :: I1,I2,I3
   INTEGER :: M,TS,MMAX

   IF (IOPTN(71) >= 2) THEN

    PTL=0.0D0
    DO I=1,NAGS
     AX=X-AGSX(I)
     AY=Y-AGSY(I)
     AZ=Z-AGSZ(I)
     R2=AZT(I)*(AX**2+AY**2+AZ**2)
     T=1.0D0
     IF (AAX(I) == 1) THEN
      T=T*AX
     ELSE IF (AAX(I) == 2) THEN
      T=T*AX*AX
     ELSE IF (AAX(I) == 3) THEN
      T=T*AX*AX*AX
     ENDIF
     IF (AAY(I) == 1) THEN
      T=T*AY
     ELSE IF (AAY(I) == 2) THEN
      T=T*AY*AY
     ELSE IF (AAY(I) == 3) THEN
      T=T*AY*AY*AY
     ENDIF
     IF (AAZ(I) == 1) THEN
      T=T*AZ
     ELSE IF (AAZ(I) == 2) THEN
      T=T*AZ*AZ
     ELSE IF (AAZ(I) == 3) THEN
      T=T*AZ*AZ*AZ
     ENDIF
     PTL=PTL-0.5D0*ANORM(I)*T*DEXP(-R2)*EXPAND(I)
    ENDDO
    RETURN

   ELSE IF (IOPTN(71) == 1) THEN

    ALLOCATE(N1(0:3,0:3,0:3,0:5),N2(0:3,0:3,0:3),W1(NAGS))

    PISUB=2.0D0/DSQRT(PI)
    F1(0)=1.0D0/PISUB
    F1(1)=1.0D0/2.0D0/PISUB
    F1(2)=3.0D0/4.0D0/PISUB
    F1(3)=15.0D0/8.0D0/PISUB
    F1(4)=105.0D0/16.0D0/PISUB
    F1(5)=945.0D0/32.0D0/PISUB
    F2(0)=-0.5D0
    F2(1)=-1.5D0
    F2(2)=-2.5D0
    F2(3)=-3.5D0
    F2(4)=-4.5D0
    F2(5)=-5.5D0

    DO I=1,NASHELL
     II=A_SHELL(I,0,0,0)
     IATM=AGS_ATOM(II)
     AX=AGSX(II)
     AY=AGSY(II)
     AZ=AGSZ(II)
     COMZ=AZT(II)
     E=PISUB*DSQRT(COMZ)*(DSQRT(PI/COMZ))**3
     N2=0.0D0
     T=COMZ*((AX-X)**2+(AY-Y)**2+(AZ-Z)**2)
     DO M=0,A_SHELL_ANG(I)
      IF (T < TF(M)) THEN
       TS=NINT(T*20.0D0)
       H=0.05D0*DFLOAT(TS)-T
       N1(0,0,0,M)=((((((IGAMMA(TS,M+6)*H*0.166666666666667D0+IGAMMA(TS,M+5))*H*0.2D0+IGAMMA(TS,M+4))*H*0.25D0+ &
       IGAMMA(TS,M+3))*H*0.333333333333333D0+IGAMMA(TS,M+2))*H*0.5D0+IGAMMA(TS,M+1))*H+IGAMMA(TS,M))*E
      ELSE
       N1(0,0,0,M)=E*F1(M)*DEXP(F2(M)*DLOG(T))
      ENDIF
     ENDDO
     N2(0,0,0)=N2(0,0,0)+N1(0,0,0,0)

     DO I1=0,A_SHELL_ANG(I)
      DO I2=0,A_SHELL_ANG(I)-I1
       DO I3=0,A_SHELL_ANG(I)-I1-I2
        MMAX=A_SHELL_ANG(I)-I1-I2-I3
        IF ((I1+I2+I3 == 0).OR.(MMAX < 0)) CYCLE
        DO M=0,MMAX
         IF (I1 >= 1) THEN
          N1(I1,I2,I3,M)=-(AX-X)*N1(I1-1,I2,I3,M+1)
          IF (I1 >= 2) N1(I1,I2,I3,M)=N1(I1,I2,I3,M)+0.5D0*DFLOAT(I1-1)/COMZ*(N1(I1-2,I2,I3,M)-N1(I1-2,I2,I3,M+1))
         ELSE IF (I2 >= 1) THEN
          N1(I1,I2,I3,M)=-(AY-Y)*N1(I1,I2-1,I3,M+1)
          IF (I2 >= 2) N1(I1,I2,I3,M)=N1(I1,I2,I3,M)+0.5D0*DFLOAT(I2-1)/COMZ*(N1(I1,I2-2,I3,M)-N1(I1,I2-2,I3,M+1))
         ELSE IF (I3 >= 1) THEN
          N1(I1,I2,I3,M)=-(AZ-Z)*N1(I1,I2,I3-1,M+1)
          IF (I3 >= 2) N1(I1,I2,I3,M)=N1(I1,I2,I3,M)+0.5D0*DFLOAT(I3-1)/COMZ*(N1(I1,I2,I3-2,M)-N1(I1,I2,I3-2,M+1))
         END IF
        ENDDO
        N2(I1,I2,I3)=N2(I1,I2,I3)+N1(I1,I2,I3,0)
       ENDDO
      ENDDO
     ENDDO
     DO I1=0,A_SHELL_ANG(I)
      DO I2=0,A_SHELL_ANG(I)-I1
       DO I3=0,A_SHELL_ANG(I)-I1-I2
        W1(A_SHELL(I,I1,I2,I3))=N2(I1,I2,I3)*ANORM(A_SHELL(I,I1,I2,I3))
       ENDDO
      ENDDO
     ENDDO
    ENDDO
    PTL=0.0D0
    DO I=1,NAGS
     PTL=PTL-0.5D0*W1(I)*EXPAND(I)
    ENDDO

    DEALLOCATE(N1,N2,W1)

   ENDIF

   RETURN
END SUBROUTINE



SUBROUTINE SORT(N,NP,A0,A1,A2,A3,A4,A5,A6)
! SORTS THE ELEMENTS OF A0,A1,A2,A3,A4,A5,A6, SO THAT THE ELEMENTS OF A0 IS IN THE INCREASING ORDER 

   IMPLICIT NONE
   INTEGER :: N,NP
   INTEGER :: I,J,K
   DOUBLE PRECISION :: A0(NP),A1(NP),A2(NP),A3(NP),A4(NP),A5(NP),A6(NP)
   DOUBLE PRECISION,ALLOCATABLE :: B0(:),B1(:),B2(:),B3(:),B4(:),B5(:),B6(:)
   DOUBLE PRECISION :: C

   ALLOCATE(B0(N),B1(N),B2(N),B3(N),B4(N),B5(N),B6(N))

   DO I=1,N
    C=1.0D99
    DO J=1,N
     IF (A0(J) < C) THEN
      K=J
      C=A0(J)
     ENDIF
    ENDDO
    B0(I)=A0(K)
    B1(I)=A1(K)
    B2(I)=A2(K)
    B3(I)=A3(K)
    B4(I)=A4(K)
    B5(I)=A5(K)
    B6(I)=A6(K)
    A0(K)=2.0D99
   ENDDO
   DO I=1,N
    A0(I)=B0(I)
    A1(I)=B1(I)
    A2(I)=B2(I)
    A3(I)=B3(I)
    A4(I)=B4(I)
    A5(I)=B5(I)
    A6(I)=B6(I)
   ENDDO

   DEALLOCATE(B0,B1,B2,B3,B4,B5,B6)
   RETURN
END SUBROUTINE



SUBROUTINE SLATER51_EXCHANGE
! CALCULATE THE VALUES OF SLATER 1951 ORBITAL-DEPENDENT EXCHANGE POTENTIAL AT EACH GRID POINT.

   USE CONTROL
   USE CONSTANTS
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT

   IMPLICIT NONE
   INTEGER :: I,J,K,L
   INTEGER :: MOI,MOJ
   DOUBLE PRECISION :: X,Y,Z,A1,A2,A3
   DOUBLE PRECISION,ALLOCATABLE :: CGS(:,:),C2P(:) ! 'C2P' IS WORKING ARRAY FOR CGS_GRID
   DOUBLE PRECISION,ALLOCATABLE :: N0(:,:)

   IF (KVC /= 0) CALL PABORT('SLATER51 CALCULATIONS ARE FOR ATOMS & MOLECULES ONLY')

   ALLOCATE(N0(NCGS,NCGS),CGS(NCGS,-REDUCED_CEL1_XC:REDUCED_CEL1_XC),C2P(NPGS))
   DO I=1,NATOM
    DO J=1,NGRID(I)
     IF (RHO(J,I) /= 0.0D0) THEN
      X=GRIDX(J,I)+ATOMX(I)
      Y=GRIDY(J,I)+ATOMY(I)
      Z=GRIDZ(J,I)+ATOMZ(I)
      CALL NUCLEAR_ATTRACTION_GRID(X,Y,Z,NCGS,N0)
      CALL CGS_GRID(CGS,C2P,NCGS,REDUCED_CEL1_XC,NPGS,J,I)
      DO MOI=1,IOCC
       DO MOJ=1,IOCC
        A1=0.0D0
        A2=0.0D0
        A3=0.0D0
        DO K=1,NCGS
         A1=A1+CGS(K,0)*CO(K,MOI,0)
         A2=A2+CGS(K,0)*CO(K,MOJ,0)
         DO L=1,NCGS
          A3=A3+N0(K,L)*CO(K,MOI,0)*CO(L,MOJ,0)
         ENDDO
        ENDDO
        D1F1(J,I)=D1F1(J,I)-2.0D0*A1*A2*A3/RHO(J,I)
       ENDDO
      ENDDO
     ENDIF
    ENDDO
   ENDDO
   DEALLOCATE(N0,CGS,C2P)

   RETURN
END SUBROUTINE



SUBROUTINE KLI_EXCHANGE
! CALCULATE THE VALUES OF KRIEGER-LI-IAFRATE ORBITAL-DEPENDENT EXCHANGE POTENTIAL AT EACH GRID POINT.

   USE CONTROL
   USE CONSTANTS
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT

   IMPLICIT NONE
   INTEGER :: I,J,K,L
   INTEGER :: MOI,MOJ
   DOUBLE PRECISION :: X,Y,Z,A1,A2,A3,D
   DOUBLE PRECISION,ALLOCATABLE :: CGS(:,:),C2P(:) ! 'C2P' IS WORKING ARRAY FOR CGS_GRID
   DOUBLE PRECISION,ALLOCATABLE :: N0(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: VSBAR(:),VHBAR(:),A(:,:),AS(:,:),B(:),BS(:),INDX(:)

   IF (KVC /= 0) CALL PABORT('KLI CALCULATIONS ARE FOR ATOMS & MOLECULES ONLY')

   ALLOCATE(N0(NCGS,NCGS),CGS(NCGS,-REDUCED_CEL1_XC:REDUCED_CEL1_XC),C2P(NPGS))

   ! SLATER51 EXCHANGE
   DO I=1,NATOM
    DO J=1,NGRID(I)
     IF (RHO(J,I) /= 0.0D0) THEN
      X=GRIDX(J,I)+ATOMX(I)
      Y=GRIDY(J,I)+ATOMY(I)
      Z=GRIDZ(J,I)+ATOMZ(I)
      CALL NUCLEAR_ATTRACTION_GRID(X,Y,Z,NCGS,N0)
      CALL CGS_GRID(CGS,C2P,NCGS,REDUCED_CEL1_XC,NPGS,J,I)
      DO MOI=1,IOCC
       DO MOJ=1,IOCC
        A1=0.0D0
        A2=0.0D0
        A3=0.0D0
        DO K=1,NCGS
         A1=A1+CGS(K,0)*CO(K,MOI,0)
         A2=A2+CGS(K,0)*CO(K,MOJ,0)
         DO L=1,NCGS
          A3=A3+N0(K,L)*CO(K,MOI,0)*CO(L,MOJ,0)
         ENDDO
        ENDDO
        D1F1(J,I)=D1F1(J,I)-2.0D0*A1*A2*A3/RHO(J,I)
       ENDDO
      ENDDO
     ENDIF
    ENDDO
   ENDDO

   ! KLI CORRECTIONS
   IF (IOCC > 1) THEN

    ALLOCATE(VSBAR(IOCC-1),VHBAR(IOCC-1),A(IOCC-1,IOCC-1),AS(IOCC-1,IOCC-1),B(IOCC-1),BS(IOCC-1),INDX(IOCC-1))

    ! CONSTRUCT THE ORBITAL EXPECTATION VALUE OF HF NON-LOCAL EXCHANGE POTENTIAL
    DO MOI=1,IOCC-1
     VHBAR(MOI)=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       VHBAR(MOI)=VHBAR(MOI)-0.5D0*X_C(I,J,0)*CO(I,MOI,0)*CO(J,MOI,0)
      ENDDO
     ENDDO
    ENDDO

    ! CONSTRUCT THE ORBITAL EXPECTATION VALUE OF SLATER51 LOCAL EXCHANGE POTENTIAL
    DO MOI=1,IOCC-1
     VSBAR(MOI)=0.0D0
     DO I=1,NATOM
      DO J=1,NGRID(I)
       CALL CGS_GRID(CGS,C2P,NCGS,REDUCED_CEL1_XC,NPGS,J,I)
       A1=0.0D0
       DO K=1,NCGS
        A1=A1+CGS(K,0)*CO(K,MOI,0)
       ENDDO
       VSBAR(MOI)=VSBAR(MOI)+GRIDW(J,I)*A1*A1*D1F1(J,I)
      ENDDO
     ENDDO
    ENDDO

    ! FORM A MATRIX OF KRIEGER-LI-IAFRATE METHOD
    DO MOI=1,IOCC-1
     DO MOJ=1,IOCC-1
      A(MOI,MOJ)=0.0D0
      DO I=1,NATOM
       DO J=1,NGRID(I)
        CALL CGS_GRID(CGS,C2P,NCGS,REDUCED_CEL1_XC,NPGS,J,I)
        A1=0.0D0
        DO K=1,NCGS
         A1=A1+CGS(K,0)*CO(K,MOI,0)
        ENDDO
        A2=0.0D0
        DO K=1,NCGS
         A2=A2+CGS(K,0)*CO(K,MOJ,0)
        ENDDO
        A(MOI,MOJ)=A(MOI,MOJ)+2.0D0*GRIDW(J,I)*A1*A1*A2*A2/RHO(J,I)
       ENDDO
      ENDDO
     ENDDO
    ENDDO

    ! FORM THE INVERSE OF A
    DO MOI=1,IOCC-1
     B(MOI)=VSBAR(MOI)
     DO MOJ=1,IOCC-1
      B(MOI)=B(MOI)-A(MOI,MOJ)*VHBAR(MOJ)
     ENDDO
    ENDDO
    A=-A
    DO MOI=1,IOCC-1
     A(MOI,MOI)=A(MOI,MOI)+1.0D0
    ENDDO
    AS=A
    BS=B
    IF (IOCC == 2) THEN
     B(1)=B(1)/A(1,1)
    ELSE
     CALL LUDCMP(A,IOCC-1,IOCC-1,INDX,D)
     CALL LUBKSB(A,IOCC-1,IOCC-1,INDX,B)
     CALL MPROVE(AS,A,IOCC-1,IOCC-1,INDX,BS,B)
    ENDIF

    ! ADD CORRECTIONS TO THE POTENTIAL
    DO I=1,NATOM
     DO J=1,NGRID(I)
      CALL CGS_GRID(CGS,C2P,NCGS,REDUCED_CEL1_XC,NPGS,J,I)
      DO MOI=1,IOCC-1
       A1=0.0D0
       DO K=1,NCGS
        A1=A1+CGS(K,0)*CO(K,MOI,0)
       ENDDO
       D1F1(J,I)=D1F1(J,I)+2.0D0*A1*A1/RHO(J,I)*(B(MOI)-VHBAR(MOI))
      ENDDO
     ENDDO
    ENDDO

    DEALLOCATE(VSBAR,VHBAR,A,AS,B,BS,INDX)
    
   ENDIF

   DEALLOCATE(N0,CGS,C2P)

   RETURN
END SUBROUTINE



SUBROUTINE NUCLEAR_ATTRACTION_GRID(X,Y,Z,N,N0)
! CALCULATE COULOMB POTENTIAL OF ALL PAIRS OF AO'S AT A GRID POINT (X,Y,Z).

   USE CONTROL
   USE STRUCTURE
   USE BASISSET
   USE INTEGRAL
   USE GRADIENT
   USE FMT
   USE CONSTANTS

   IMPLICIT NONE
   INTEGER :: N
   DOUBLE PRECISION :: X,Y,Z
   DOUBLE PRECISION :: N0(N,N)
   DOUBLE PRECISION,ALLOCATABLE :: N1(:,:,:,:,:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: W1(:,:),W2(:,:)
   DOUBLE PRECISION :: PISUB
   DOUBLE PRECISION :: COMZ,FN
   DOUBLE PRECISION :: AX,AY,AZ,BX,BY,BZ,PX,PY,PZ,E
   DOUBLE PRECISION :: T,H,F1(0:5),F2(0:5)
   INTEGER :: I,J,II,JJ,IATM,JATM
   INTEGER :: I1,I2,I3,J1,J2,J3
   INTEGER :: M,TS,MMAX

   IF (N /= NCGS) CALL PABORT('DIMENSION OF N0 IN NUCLEAR_ATTRACTION_GRID IS INCONSISTENT')

   ALLOCATE(N1(0:3,0:3,0:3,0:3,0:3,0:3,0:5))
   ALLOCATE(W1(NPGS,NPGS),W2(NCGS,NPGS))

   PISUB=2.0D0/DSQRT(PI)
   F1(0)=1.0D0/PISUB
   F1(1)=1.0D0/2.0D0/PISUB
   F1(2)=3.0D0/4.0D0/PISUB
   F1(3)=15.0D0/8.0D0/PISUB
   F1(4)=105.0D0/16.0D0/PISUB
   F1(5)=945.0D0/32.0D0/PISUB
   F2(0)=-0.5D0
   F2(1)=-1.5D0
   F2(2)=-2.5D0
   F2(3)=-3.5D0
   F2(4)=-4.5D0
   F2(5)=-5.5D0

   DO I=1,NPSHELL
    II=P_SHELL(I,0,0,0)
    IATM=PGS_ATOM(II)
    AX=PGSX(II)
    AY=PGSY(II)
    AZ=PGSZ(II)
    DO J=1,NPSHELL
     JJ=P_SHELL(J,0,0,0)
     JATM=PGS_ATOM(JJ)
     BX=PGSX(JJ)
     BY=PGSY(JJ)
     BZ=PGSZ(JJ)
     COMZ=ZT(II)+ZT(JJ)
     PX=(AX*ZT(II)+BX*ZT(JJ))/COMZ
     PY=(AY*ZT(II)+BY*ZT(JJ))/COMZ
     PZ=(AZ*ZT(II)+BZ*ZT(JJ))/COMZ
     E=PISUB*DSQRT(COMZ)*S_P(II,JJ,0)
     T=COMZ*((PX-X)**2+(PY-Y)**2+(PZ-Z)**2)
     DO M=0,P_SHELL_ANG(I)+P_SHELL_ANG(J)
      IF (T < TF(M)) THEN
       TS=NINT(T*20.0D0)
       H=0.05D0*DFLOAT(TS)-T
       N1(0,0,0,0,0,0,M)=((((((IGAMMA(TS,M+6)*H*0.166666666666667D0+IGAMMA(TS,M+5))*H*0.2D0+IGAMMA(TS,M+4))*H*0.25D0+ &
       IGAMMA(TS,M+3))*H*0.333333333333333D0+IGAMMA(TS,M+2))*H*0.5D0+IGAMMA(TS,M+1))*H+IGAMMA(TS,M))*E
      ELSE
       N1(0,0,0,0,0,0,M)=E*F1(M)*DEXP(F2(M)*DLOG(T))
      ENDIF
     ENDDO

     DO I1=0,P_SHELL_ANG(I)
      DO I2=0,P_SHELL_ANG(I)-I1
       DO I3=0,P_SHELL_ANG(I)-I1-I2
        DO J1=0,P_SHELL_ANG(J)
         DO J2=0,P_SHELL_ANG(J)-J1
          DO J3=0,P_SHELL_ANG(J)-J1-J2
           MMAX=P_SHELL_ANG(I)+P_SHELL_ANG(J)-I1-I2-I3-J1-J2-J3
           IF ((I1+I2+I3+J1+J2+J3 == 0).OR.(MMAX < 0)) CYCLE
           DO M=0,MMAX
            IF (I1 >= 1) THEN
             N1(I1,I2,I3,J1,J2,J3,M)=(PX-AX)*N1(I1-1,I2,I3,J1,J2,J3,M)-(PX-X)*N1(I1-1,I2,I3,J1,J2,J3,M+1)
             IF (I1 >= 2) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(I1-1)/COMZ*(N1(I1-2,I2,I3,J1,J2,J3,M)-N1(I1-2,I2,I3,J1,J2,J3,M+1))
             IF (J1 >= 1) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(J1)/COMZ*(N1(I1-1,I2,I3,J1-1,J2,J3,M)-N1(I1-1,I2,I3,J1-1,J2,J3,M+1))
            ELSE IF (I2 >= 1) THEN
             N1(I1,I2,I3,J1,J2,J3,M)=(PY-AY)*N1(I1,I2-1,I3,J1,J2,J3,M)-(PY-Y)*N1(I1,I2-1,I3,J1,J2,J3,M+1)
             IF (I2 >= 2) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(I2-1)/COMZ*(N1(I1,I2-2,I3,J1,J2,J3,M)-N1(I1,I2-2,I3,J1,J2,J3,M+1))
             IF (J2 >= 1) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(J2)/COMZ*(N1(I1,I2-1,I3,J1,J2-1,J3,M)-N1(I1,I2-1,I3,J1,J2-1,J3,M+1))
            ELSE IF (I3 >= 1) THEN
             N1(I1,I2,I3,J1,J2,J3,M)=(PZ-AZ)*N1(I1,I2,I3-1,J1,J2,J3,M)-(PZ-Z)*N1(I1,I2,I3-1,J1,J2,J3,M+1)
             IF (I3 >= 2) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(I3-1)/COMZ*(N1(I1,I2,I3-2,J1,J2,J3,M)-N1(I1,I2,I3-2,J1,J2,J3,M+1))
             IF (J3 >= 1) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(J3)/COMZ*(N1(I1,I2,I3-1,J1,J2,J3-1,M)-N1(I1,I2,I3-1,J1,J2,J3-1,M+1))
            ELSE IF (J1 >= 1) THEN
             N1(I1,I2,I3,J1,J2,J3,M)=(PX-BX)*N1(I1,I2,I3,J1-1,J2,J3,M)-(PX-X)*N1(I1,I2,I3,J1-1,J2,J3,M+1)
             IF (J1 >= 2) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(J1-1)/COMZ*(N1(I1,I2,I3,J1-2,J2,J3,M)-N1(I1,I2,I3,J1-2,J2,J3,M+1))
            ELSE IF (J2 >= 1) THEN
             N1(I1,I2,I3,J1,J2,J3,M)=(PY-BY)*N1(I1,I2,I3,J1,J2-1,J3,M)-(PY-Y)*N1(I1,I2,I3,J1,J2-1,J3,M+1)
             IF (J2 >= 2) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(J2-1)/COMZ*(N1(I1,I2,I3,J1,J2-2,J3,M)-N1(I1,I2,I3,J1,J2-2,J3,M+1))
            ELSE IF (J3 >= 1) THEN
             N1(I1,I2,I3,J1,J2,J3,M)=(PZ-BZ)*N1(I1,I2,I3,J1,J2,J3-1,M)-(PZ-Z)*N1(I1,I2,I3,J1,J2,J3-1,M+1)
             IF (J3 >= 2) N1(I1,I2,I3,J1,J2,J3,M)=N1(I1,I2,I3,J1,J2,J3,M)+ &
             0.5D0*DFLOAT(J3-1)/COMZ*(N1(I1,I2,I3,J1,J2,J3-2,M)-N1(I1,I2,I3,J1,J2,J3-2,M+1))
            END IF
           ENDDO
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
     DO I1=0,P_SHELL_ANG(I)
      DO I2=0,P_SHELL_ANG(I)-I1
       DO I3=0,P_SHELL_ANG(I)-I1-I2
        DO J1=0,P_SHELL_ANG(J)
         DO J2=0,P_SHELL_ANG(J)-J1
          DO J3=0,P_SHELL_ANG(J)-J1-J2
           W1(P_SHELL(I,I1,I2,I3),P_SHELL(J,J1,J2,J3))=N1(I1,I2,I3,J1,J2,J3,0)
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   ! CONTRACTION
   W2=MATMUL(CC,W1)
   N0=MATMUL(W2,TRANSPOSE(CC))
   DEALLOCATE(N1,W1,W2)
   RETURN
END SUBROUTINE



SUBROUTINE POTENTIAL_TO_DENSITY(ERROR)
! GENERATE AN EXCHANGE CHARGE DENSITY CORRESPONDING TO A GIVEN EXCHANGE POTENTIAL.
! USES TWO-CENTER ELECTRON REPULSION INTEGRALS.
! MUST BE PROVIDED WITH THE EXCHANGE POTENTIAL IN D1F1(:,:).
! OVERWRITES D1F1(:,:) WITH THE EXCHANGE CHARGE DENSITY.
! RETURNS AN ERROR IN THE FITTING PROCEDURE.

   USE CONTROL
   USE STRUCTURE
   USE GRADIENT
   USE INTEGRAL
   USE BASISSET
   USE AUXILIARY
   USE DFT
   USE OEP

   IMPLICIT NONE
   INTEGER :: I,J,K
   INTEGER :: REDUCED_NAGS
   DOUBLE PRECISION :: ERROR
   DOUBLE PRECISION :: AX,AY,AZ,R2,T
   DOUBLE PRECISION,ALLOCATABLE :: WR1(:,:),WR2(:,:),WR3(:),WR4(:),WR5(:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: WC1(:,:),WC2(:,:)

   ALLOCATE(WC1(NAGS,NAGS),WC2(NAGS,NAGS),WR1(NAGS,NAGS),WR2(NAGS,NAGS),WR3(NAGS),WR4(NAGS),WR5(MAXNGRID,NATOM))

   ! SECURE THE ORIGINAL POTENTIAL
   WR5=D1F1

   ! FORM AN OVERLAP OF AN AUXILIARY BASIS FUNCTION AND THE GIVEN POTENTIAL
   DO K=1,NAGS
    WR3(K)=0.0D0
    DO I=1,NATOM
     DO J=1,NGRID(I)
      AX=GRIDX(J,I)+ATOMX(I)-AGSX(K)
      AY=GRIDY(J,I)+ATOMY(I)-AGSY(K)
      AZ=GRIDZ(J,I)+ATOMZ(I)-AGSZ(K)
      R2=AZT(K)*(AX**2+AY**2+AZ**2)
      T=1.0D0
      IF (AAX(K) == 1) THEN
       T=T*AX
      ELSE IF (AAX(K) == 2) THEN
       T=T*AX*AX
      ELSE IF (AAX(K) == 3) THEN
       T=T*AX*AX*AX
      ENDIF
      IF (AAY(K) == 1) THEN
       T=T*AY
      ELSE IF (AAY(K) == 2) THEN
       T=T*AY*AY
      ELSE IF (AAY(K) == 3) THEN
       T=T*AY*AY*AY
      ENDIF
      IF (AAZ(K) == 1) THEN
       T=T*AZ
      ELSE IF (AAZ(K) == 2) THEN
       T=T*AZ*AZ
      ELSE IF (AAZ(K) == 3) THEN
       T=T*AZ*AZ*AZ
      ENDIF
      WR3(K)=WR3(K)+GRIDW(J,I)*D1F1(J,I)*ANORM(K)*T*DEXP(-R2)
     ENDDO
    ENDDO
   ENDDO
 
   ! FORM AUXILIARY ELECTRON REPULSION INTEGRALS
   CALL TWOINDEX_V(WR1,NAGS,0)
   DO I=1,NAGS
    DO J=1,NAGS
     WC1(J,I)=DCMPLX(WR1(J,I),0.0D0)
    ENDDO
   ENDDO

   ! DIAGONALIZE AUXILIARY OVERLAP
   CALL HHBS(NAGS,NAGS,WC1,WR4,WC2)
   REDUCED_NAGS=0
   DO I=1,NAGS
    IF (WR4(I) > DOPTN(85)) THEN
     REDUCED_NAGS=REDUCED_NAGS+1
     DO J=1,NAGS
      WR2(J,REDUCED_NAGS)=DREAL(WC2(J,I))/DSQRT(WR4(I))
     ENDDO
    ENDIF
   ENDDO

   ! COMPUTE THE EXPANSION COEFFICIENT FOR POTENTIAL PLOT
   DO I=1,REDUCED_NAGS
    WR4(I)=0.0D0
    DO J=1,NAGS
     WR4(I)=WR4(I)+WR2(J,I)*WR3(J)
    ENDDO
   ENDDO
   DO I=1,NAGS
    WR3(I)=0.0D0
    DO J=1,REDUCED_NAGS
     WR3(I)=WR3(I)+WR2(I,J)*WR4(J)
    ENDDO
   ENDDO

   ! REPRODUCE THE POTENTIAL FROM THE EXCHANGE CHARGE DENSITY
   ERROR=0.0D0
   DO I=1,NATOM
    DO J=1,NGRID(I)
     AX=GRIDX(J,I)+ATOMX(I)
     AY=GRIDY(J,I)+ATOMY(I)
     AZ=GRIDZ(J,I)+ATOMZ(I)
     CALL CONTRACT_POTENTIAL(NAGS,WR3,AX,AY,AZ,T)
     ERROR=ERROR+GRIDW(J,I)*(WR5(J,I)+T*2.0D0)**2
    ENDDO
   ENDDO

   ! COMPUTE THE EXCHANGE CHARGE DENSITY
   DO I=1,NATOM
    DO J=1,NGRID(I)
     D1F1(J,I)=0.0D0
     DO K=1,NAGS
      AX=GRIDX(J,I)+ATOMX(I)-AGSX(K)
      AY=GRIDY(J,I)+ATOMY(I)-AGSY(K)
      AZ=GRIDZ(J,I)+ATOMZ(I)-AGSZ(K)
      R2=AZT(K)*(AX**2+AY**2+AZ**2)
      T=1.0D0
      IF (AAX(K) == 1) THEN
       T=T*AX
      ELSE IF (AAX(K) == 2) THEN
       T=T*AX*AX
      ELSE IF (AAX(K) == 3) THEN
       T=T*AX*AX*AX
      ENDIF
      IF (AAY(K) == 1) THEN
       T=T*AY
      ELSE IF (AAY(K) == 2) THEN
       T=T*AY*AY
      ELSE IF (AAY(K) == 3) THEN
       T=T*AY*AY*AY
      ENDIF
      IF (AAZ(K) == 1) THEN
       T=T*AZ
      ELSE IF (AAZ(K) == 2) THEN
       T=T*AZ*AZ
      ELSE IF (AAZ(K) == 3) THEN
       T=T*AZ*AZ*AZ
      ENDIF
      D1F1(J,I)=D1F1(J,I)+ANORM(K)*T*DEXP(-R2)*WR3(K)
     ENDDO
    ENDDO
   ENDDO

   DEALLOCATE(WC1,WC2,WR1,WR2,WR3,WR4,WR5)

   RETURN
END SUBROUTINE



SUBROUTINE EXCHANGE_VIRIAL_RELATION(SHIFT,E)
! CALCULATES EXCHANGE ENERGY BY EXCHANGE VIRIAL THEOREM OF GHOSH & PARR AND OF LEVY & PERDEW
! USES AN EXCHANGE POTENTIAL AS D1F1 SHIFTED BY SHIFT AND RETURNS ENERGY AS E.

   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT

   IMPLICIT NONE
   DOUBLE PRECISION :: SHIFT,E
   INTEGER :: I,J,K,L,Q1,Q2,Q3
   DOUBLE PRECISION,ALLOCATABLE :: CGS(:,:),C2P(:) ! 'C2P' IS WORKING ARRAY FOR CGS_GRID
   DOUBLE PRECISION,ALLOCATABLE :: CGSDX(:,:),CGSDY(:,:),CGSDZ(:,:)
   DOUBLE PRECISION :: X,Y,Z
   DOUBLE PRECISION :: Q1C,Q1S,Q2C,Q2S

   ALLOCATE(CGS(NCGS,-REDUCED_CEL1_XC:REDUCED_CEL1_XC),C2P(NPGS))
   ALLOCATE(CGSDX(NCGS,-REDUCED_CEL1_XC:REDUCED_CEL1_XC))
   ALLOCATE(CGSDY(NCGS,-REDUCED_CEL1_XC:REDUCED_CEL1_XC))
   ALLOCATE(CGSDZ(NCGS,-REDUCED_CEL1_XC:REDUCED_CEL1_XC))

   RHO_GX=0.0D0
   RHO_GY=0.0D0
   RHO_GZ=0.0D0
   DO I=1,NATOM
    DO J=1,NGRID(I)
     CALL CGS_GRID(CGS,C2P,NCGS,REDUCED_CEL1_XC,NPGS,J,I)
     CALL CGS_DERIVATIVE_GRID(CGSDX,CGSDY,CGSDZ,C2P,NCGS,REDUCED_CEL1_XC,NPGS,J,I)
     X=0.0D0
     Y=0.0D0
     Z=0.0D0
     IF (HELIX == 0.0D0) THEN
      DO Q1=-REDUCED_CEL1_XC,REDUCED_CEL1_XC
       DO Q2=-REDUCED_CEL1_XC,REDUCED_CEL1_XC
        Q3=Q1+Q2
        IF ((Q3 <= REDUCED_CEL1_XC).AND.(Q3 >= -REDUCED_CEL1_XC)) THEN
         DO K=1,NCGS
          DO L=1,NCGS
           X=X+P_C(L,K,Q2)*(CGS(L,Q1)*CGSDX(K,Q3)+CGSDX(L,Q1)*CGS(K,Q3))
           Y=Y+P_C(L,K,Q2)*(CGS(L,Q1)*CGSDY(K,Q3)+CGSDY(L,Q1)*CGS(K,Q3))
           Z=Z+P_C(L,K,Q2)*(CGS(L,Q1)*CGSDZ(K,Q3)+CGSDZ(L,Q1)*CGS(K,Q3))
          ENDDO
         ENDDO
        ENDIF
       ENDDO
      ENDDO
     ELSE
      DO Q1=-REDUCED_CEL1_XC,REDUCED_CEL1_XC
       Q1C=DCOS(DFLOAT(Q1)*HELIX)
       Q1S=DSIN(DFLOAT(Q1)*HELIX)
       DO Q2=-REDUCED_CEL1_XC,REDUCED_CEL1_XC
        Q3=Q1+Q2
        IF ((Q3 <= REDUCED_CEL1_XC).AND.(Q3 >= -REDUCED_CEL1_XC)) THEN
         Q2C=DCOS(DFLOAT(Q3)*HELIX)
         Q2S=DSIN(DFLOAT(Q3)*HELIX)
         DO K=1,NCGS
          DO L=1,NCGS
           X=X+P_C(L,K,Q2)*(CGS(L,Q1)*CGSDX(K,Q3)+CGSDX(L,Q1)*CGS(K,Q3))
           Y=Y+P_C(L,K,Q2)*(CGS(L,Q1)*(CGSDY(K,Q3)*Q2C-CGSDZ(K,Q3)*Q2S)+(CGSDY(L,Q1)*Q1C-CGSDZ(L,Q1)*Q1S)*CGS(K,Q3))
           Z=Z+P_C(L,K,Q2)*(CGS(L,Q1)*(CGSDZ(K,Q3)*Q2C+CGSDY(K,Q3)*Q2S)+(CGSDZ(L,Q1)*Q1C+CGSDY(L,Q1)*Q1S)*CGS(K,Q3))
          ENDDO
         ENDDO
        ENDIF
       ENDDO
      ENDDO
     ENDIF
     RHO_GX(J,I)=RHO_GX(J,I)+X
     RHO_GY(J,I)=RHO_GY(J,I)+Y
     RHO_GZ(J,I)=RHO_GZ(J,I)+Z
    ENDDO
   ENDDO
  
   E=0.0D0
   DO I=1,NATOM
    DO J=1,NGRID(I)
     E=E+(D1F1(J,I)+SHIFT)*(3.0D0*RHO(J,I)+(GRIDX(J,I)+ATOMX(I))*RHO_GX(J,I)+(GRIDY(J,I)+ATOMY(I))*RHO_GY(J,I) &
                          +(GRIDZ(J,I)+ATOMZ(I))*RHO_GZ(J,I))*GRIDW(J,I)
    ENDDO
   ENDDO

   DEALLOCATE(CGS,C2P)
   DEALLOCATE(CGSDX,CGSDY,CGSDZ)

   RETURN
END SUBROUTINE



SUBROUTINE ASYMPTOTIC_CORRECTION
! GRAFT THE LONG-RANGE TAIL OF SLATER POTENTIAL TO A GIVEN EXCHANGE-CORRELATION POTENTIAL.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE AUXILIARY
   USE BASISSET
   USE INTEGRAL
   USE DFT

   IMPLICIT NONE
   LOGICAL :: LGRAFT
   INTEGER :: I,J,K
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   DOUBLE PRECISION :: A,B,X,Y,Z,DX,DY,DZ,R
   DOUBLE PRECISION,ALLOCATABLE :: D1F1_KEEP(:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: WC1(:)

   ALLOCATE(D1F1_KEEP(MAXNGRID,NATOM))

   ! COMPUTE THE SHIFT FOR THE EXCHANGE-CORRELATION POTENTIAL BY THE HOMO CONDITION
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'BARE POTENTIAL ALONG THE X AXIS'
    DO I=1,NATOM
     DO J=1,NGRID(I)
      X=GRIDX(J,I)+ATOMX(I)
      Y=GRIDY(J,I)+ATOMY(I)
      Z=GRIDZ(J,I)+ATOMZ(I)
      IF ((Y == 0.0D0).AND.(Z == 0.0D0)) WRITE(6,'(F10.5,F20.10)') X,D1F1(J,I)
     ENDDO
    ENDDO
   ENDIF
   ALLOCATE(WC1(NCGS))
   DO I=1,NCGS
    WC1(I)=0.0D0
    DO J=1,NCGS
     WC1(I)=WC1(I)-0.5D0*X_C(I,J,0)*DCONJG(CO(J,IOCC,0))
    ENDDO
   ENDDO
   A=0.0D0
   DO I=1,NCGS
    A=A+WC1(I)*CO(I,IOCC,0)
   ENDDO
   DO I=1,NCGS
    WC1(I)=0.0D0
    DO J=1,NCGS
     WC1(I)=WC1(I)+Y_C(I,J,0)*DCONJG(CO(J,IOCC,0))
    ENDDO
   ENDDO
   B=0.0D0
   DO I=1,NCGS
    B=B+WC1(I)*CO(I,IOCC,0)
   ENDDO
   DEALLOCATE(WC1)
   IF (IOPTN(9) >= 2) WRITE(6,'(A,F20.10)') 'SHIFT TO THE EXCHANGE-CORRELATION POTENTIAL = ',A-B
   D1F1_KEEP=D1F1+A-B

   ! GRAFT THE LONG-RANGE TAIL OF SLATER51 POTENTIAL
   D1F1=0.0D0
   CALL SLATER51_EXCHANGE
   DO I=1,NATOM
    DO J=1,NGRID(I)
     X=GRIDX(J,I)+ATOMX(I)
     Y=GRIDY(J,I)+ATOMY(I)
     Z=GRIDZ(J,I)+ATOMZ(I)
     LGRAFT=.TRUE.
     DO K=1,NATOM
      DX=X-ATOMX(K)
      DY=Y-ATOMY(K)
      DZ=Z-ATOMZ(K)
      R=DSQRT(DX**2+DY**2+DZ**2)
      IF ((R < BSRADI(IATOM(K))/ANG_BOHR).OR.(D1F1_KEEP(J,I) > D1F1(J,I))) LGRAFT=.FALSE.
     ENDDO
     IF (LGRAFT) D1F1_KEEP(J,I)=D1F1(J,I)
    ENDDO
   ENDDO
   D1F1=D1F1_KEEP
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'ASYMPTOTICALLY-CORRECTED POTENTIAL ALONG THE X AXIS'
    DO I=1,NATOM
     DO J=1,NGRID(I)
      X=GRIDX(J,I)+ATOMX(I)
      Y=GRIDY(J,I)+ATOMY(I)
      Z=GRIDZ(J,I)+ATOMZ(I)
      IF ((Y == 0.0D0).AND.(Z == 0.0D0)) WRITE(6,'(F10.5,F20.10)') X,D1F1(J,I)
     ENDDO
    ENDDO
   ENDIF

   DEALLOCATE(D1F1_KEEP)
   
   RETURN
END SUBROUTINE



SUBROUTINE CONTRACT_OEP(X,T,N,S,IFLAG)
! USES KERNEL_CORE AND THREE-INDEX INTEGRALS STORED EXTERNALLY.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE AUXILIARY
   USE BASISSET
   USE INTEGRAL
   USE OEP
   USE DFT

   IMPLICIT NONE
   INTEGER :: IFLAG ! NOT USED
   INTEGER :: N,S
   INTEGER,PARAMETER :: CASHESIZE = 1000
   INTEGER :: REDUCED_NAGS
   INTEGER :: ICASHECOUNT,EOF
   INTEGER,ALLOCATABLE :: INDX(:)
   INTEGER(4),ALLOCATABLE :: ICASHE1(:),ICASHE2(:)
   INTEGER :: I,J,K,L,P,Q
   DOUBLE COMPLEX :: X(N,N,-S:S),T(N,N,-S:S)
   DOUBLE COMPLEX,ALLOCATABLE :: CANN1(:,:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: WC1(:,:),WC2(:),WC3(:),S1(:,:),V1(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: WR1(:,:),WR2(:)
   DOUBLE PRECISION,ALLOCATABLE :: DCASHE(:)

   IF ((KVC /= 0).OR.(CEL1 /= 0)) CALL PABORT('OEP CALCULATIONS CAN ONLY BE PERFORMED FOR MOLECULES')

   ! FORM AUXILIARY OVERLAP
   ALLOCATE(S1(NAGS,NAGS),V1(NAGS,NAGS))
   ALLOCATE(WC1(NAGS,NAGS),WR1(NAGS,NAGS),WR2(NAGS))
   IF (IOPTN(71) == 1) CALL TWOINDEX_V(WR1,NAGS,0)
   IF (IOPTN(71) >= 2) CALL TWOINDEX_S(WR1,NAGS,0)
   DO I=1,NAGS
    DO J=1,NAGS
     S1(J,I)=DCMPLX(WR1(J,I),0.0D0)
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'TWO-CENTER AUXILIARY OVERLAP MATRIX'
    CALL DUMP7(S1,NAGS)
   ENDIF

   ! DIAGONALIZE AUXILIARY OVERLAP
   CALL HHBS(NAGS,NAGS,S1,WR2,WC1)
   REDUCED_NAGS=0
   DO I=1,NAGS
    IF (WR2(I) > DOPTN(85)) THEN
     REDUCED_NAGS=REDUCED_NAGS+1
     DO J=1,NAGS
      V1(J,REDUCED_NAGS)=WC1(J,I)/DSQRT(WR2(I))
     ENDDO
    ENDIF
   ENDDO
   DEALLOCATE(S1,WC1,WR1,WR2)

   ! RESTORE THREE-INDEX OVERLAP INTEGRALS
   ALLOCATE(ICASHE1(CASHESIZE),ICASHE2(CASHESIZE),DCASHE(CASHESIZE))
   ALLOCATE(CANN1(REDUCED_NAGS,NCGS,NCGS))
   CANN1(1:REDUCED_NAGS,1:NCGS,1:NCGS)=DCMPLX(0.0D0,0.0D0)
   DO K=1,REDUCED_NAGS
    IF (IOPTN(71) == 1) REWIND(32) ! AO-BASED THREE-INDEX ELECTRON REPULSION INTEGRAL FILE
    IF (IOPTN(71) >= 2) REWIND(35) ! AO-BASED THREE-INDEX OVERLAP INTEGRAL FILE
    DO
     IF (IOPTN(71) == 1) READ(32,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
     IF (IOPTN(71) >= 2) READ(35,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
     IF (EOF /= 0) EXIT
     DO ICASHECOUNT=1,CASHESIZE
      IF (ICASHE1(ICASHECOUNT) == -1) EXIT
      P=0
      Q=0
      I=0
      J=0
      L=0
      CALL MVBITS(ICASHE1(ICASHECOUNT), 8, 8,P,0)
      CALL MVBITS(ICASHE1(ICASHECOUNT), 0, 8,Q,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT),24, 8,I,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT),16, 8,J,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT), 0,16,L,0)
      CANN1(K,I,J)=CANN1(K,I,J)+V1(L,K)*DCASHE(ICASHECOUNT)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(ICASHE1,ICASHE2,DCASHE)
   DEALLOCATE(V1)

   ALLOCATE(WC2(REDUCED_NAGS),WC3(REDUCED_NAGS))
   DO I=1,REDUCED_NAGS
    WC2(I)=DCMPLX(0.0D0,0.0D0)
    DO J=1,NCGS
     DO K=1,NCGS
      WC2(I)=WC2(I)+T(J,K,0)*CANN1(I,J,K)
     ENDDO
    ENDDO
   ENDDO
   DO I=1,REDUCED_NAGS
    WC3(I)=DCMPLX(0.0D0,0.0D0)
    DO J=1,REDUCED_NAGS
     WC3(I)=WC3(I)+KERNEL_CORE(I,J)*WC2(J)
    ENDDO
   ENDDO
   DEALLOCATE(WC2)
   DO I=1,NCGS
    DO J=1,NCGS
     X(J,I,0)=DCMPLX(0.0D0,0.0D0)
     DO K=1,REDUCED_NAGS
      X(J,I,0)=X(J,I,0)+CANN1(K,J,I)*WC3(K)*DOPTN(84)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(CANN1,WC3) 

   RETURN
END SUBROUTINE



SUBROUTINE MAKE_KERNEL_CORE
! FORM THE CORE PART OF THE RIGOROUS EXCHANGE KERNEL AND KEEP IT IN A MODULE.
! USES THE THREE- AND FOUR-CENTER INTEGRALS STORED EXTERNALLY.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE AUXILIARY
   USE BASISSET
   USE INTEGRAL
   USE OEP
   USE DFT

   IMPLICIT NONE
   INTEGER,PARAMETER :: CASHESIZE = 1000
   INTEGER :: REDUCED_NAGS,REDUCED_REDUCED_NAGS
   INTEGER :: MOP,MOQ,MOA,MOI,MOB,MOJ
   INTEGER :: ICASHECOUNT,EOF
   INTEGER,ALLOCATABLE :: INDX(:)
   INTEGER(4),ALLOCATABLE :: ICASHE1(:),ICASHE2(:)
   INTEGER :: I,J,K,L,M,P,Q,R
   DOUBLE COMPLEX,ALLOCATABLE :: X_M(:,:)    ! MO BASED HF EXCHANGE MATRIX
   DOUBLE COMPLEX,ALLOCATABLE :: Y_M(:,:)    ! MO BASED SLATER EXCHANGE MATRIX
   DOUBLE COMPLEX,ALLOCATABLE :: O_M(:,:)    ! MO BASED OEP EXCHANGE MATRIX
   DOUBLE COMPLEX,ALLOCATABLE :: S(:,:),V1(:,:),V2(:,:),WC1(:,:),WC2(:),WC3(:)
   DOUBLE COMPLEX,ALLOCATABLE :: CANN1(:,:,:),CANN2(:,:,:)
   DOUBLE COMPLEX,ALLOCATABLE :: CHI(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: WR1(:,:),WR2(:)
   DOUBLE PRECISION,ALLOCATABLE :: DANN1(:,:,:),DANN2(:,:,:),DANN3(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: DCASHE(:)

   IF ((KVC /= 0).OR.(CEL1 /= 0)) CALL PABORT('OEP CALCULATIONS CAN ONLY BE PERFORMED FOR MOLECULES')
   IF (LOPTN(25)) CALL PABORT('USE THE DISK-BASED ALGORITHM FOR TDOEP')
   WRITE(6,'(A)') 'CORE OF THE EXCHANGE KERNEL WILL BE CREATED'
   
   ! CONSTRUCT HF EXCHANGE MATRIX IN THE MO BASIS
   ALLOCATE(X_M(IALLMAX,IALLMAX))
   ALLOCATE(WC1(NCGS,IALLMAX))
   DO MOP=1,IALL(0)
    DO I=1,NCGS
     WC1(I,MOP)=DCMPLX(0.0D0,0.0D0)
     DO J=1,NCGS
      WC1(I,MOP)=WC1(I,MOP)+X_C(I,J,0)*DCONJG(CO(J,MOP,0))
     ENDDO
    ENDDO
   ENDDO
   DO MOQ=1,IALL(0)
    DO MOP=1,IALL(0)
     X_M(MOQ,MOP)=DCMPLX(0.0D0,0.0D0)
     DO I=1,NCGS
      X_M(MOQ,MOP)=X_M(MOQ,MOP)+WC1(I,MOP)*CO(I,MOQ,0)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(WC1)
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'HF EXCHANGE MATRIX IN THE MO BASIS'
    CALL DUMP7(X_M,IALLMAX)
   ENDIF

   ! CONSTRUCT SLATER/KLI EXCHANGE MATRIX IN THE MO BASIS
   IF (IOPTN(71) >= 3) THEN
    CALL LOCAL_EXCHANGE_CORRELATION
    ALLOCATE(Y_M(IALLMAX,IALLMAX))
    ALLOCATE(WC1(NCGS,IALLMAX))
    DO MOP=1,IALL(0)
     DO I=1,NCGS
      WC1(I,MOP)=DCMPLX(0.0D0,0.0D0)
      DO J=1,NCGS
       WC1(I,MOP)=WC1(I,MOP)+Y_C(I,J,0)*DCONJG(CO(J,MOP,0))
      ENDDO
     ENDDO
    ENDDO
    DO MOQ=1,IALL(0)
     DO MOP=1,IALL(0)
      Y_M(MOQ,MOP)=DCMPLX(0.0D0,0.0D0)
      DO I=1,NCGS
       Y_M(MOQ,MOP)=Y_M(MOQ,MOP)+WC1(I,MOP)*CO(I,MOQ,0)
      ENDDO
     ENDDO
    ENDDO
    DEALLOCATE(WC1)
    IF (IOPTN(9) == 3) THEN
     WRITE(6,'(A)') 'SLATER/KLI EXCHANGE MATRIX IN THE MO BASIS'
     CALL DUMP7(Y_M,IALLMAX)
    ENDIF
   ENDIF

   ! FORM AUXILIARY OVERLAP
   ALLOCATE(S(NAGS,NAGS),V1(NAGS,NAGS))
   ALLOCATE(WC1(NAGS,NAGS),WR1(NAGS,NAGS),WR2(NAGS))
   IF (IOPTN(71) == 1) CALL TWOINDEX_V(WR1,NAGS,0)
   IF (IOPTN(71) >= 2) CALL TWOINDEX_S(WR1,NAGS,0)
   DO I=1,NAGS
    DO J=1,NAGS
     S(J,I)=DCMPLX(WR1(J,I),0.0D0)
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'TWO-CENTER AUXILIARY OVERLAP MATRIX'
    CALL DUMP7(S,NAGS)
   ENDIF

   ! DIAGONALIZE AUXILIARY OVERLAP
   CALL HHBS(NAGS,NAGS,S,WR2,WC1)
   REDUCED_NAGS=0
   DO I=1,NAGS
    IF (WR2(I) > DOPTN(85)) THEN
     REDUCED_NAGS=REDUCED_NAGS+1
     DO J=1,NAGS
      V1(J,REDUCED_NAGS)=WC1(J,I)/DSQRT(WR2(I))
     ENDDO
    ENDIF
   ENDDO
   DEALLOCATE(S,WC1,WR1,WR2)

   ! RESTORE THREE-INDEX OVERLAP/ELECTRON REPULSION INTEGRALS
   ALLOCATE(ICASHE1(CASHESIZE),ICASHE2(CASHESIZE),DCASHE(CASHESIZE))
   ALLOCATE(CANN1(REDUCED_NAGS,NCGS,NCGS))
   CANN1(1:REDUCED_NAGS,1:NCGS,1:NCGS)=DCMPLX(0.0D0,0.0D0)
   DO K=1,REDUCED_NAGS
    IF (IOPTN(71) == 1) REWIND(32) ! AO-BASED THREE-INDEX ELECTRON REPULSION INTEGRAL FILE
    IF (IOPTN(71) >= 2) REWIND(35) ! AO-BASED THREE-INDEX OVERLAP INTEGRAL FILE
    DO
     IF (IOPTN(71) == 1) READ(32,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
     IF (IOPTN(71) >= 2) READ(35,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
     IF (EOF /= 0) EXIT
     DO ICASHECOUNT=1,CASHESIZE
      IF (ICASHE1(ICASHECOUNT) == -1) EXIT
      P=0
      Q=0
      I=0
      J=0
      L=0
      CALL MVBITS(ICASHE1(ICASHECOUNT), 8, 8,P,0)
      CALL MVBITS(ICASHE1(ICASHECOUNT), 0, 8,Q,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT),24, 8,I,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT),16, 8,J,0)
      CALL MVBITS(ICASHE2(ICASHECOUNT), 0,16,L,0)
      CANN1(K,I,J)=CANN1(K,I,J)+V1(L,K)*DCASHE(ICASHECOUNT)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(ICASHE1,ICASHE2,DCASHE)
   DEALLOCATE(V1)

   ! TRANSFORM THREE-INDEX OVERLAP INTEGRALS FROM AO TO MO BASIS
   ALLOCATE(CANN2(REDUCED_NAGS,IALLMAX,IALLMAX),WC1(NCGS,IALLMAX))
   CANN2(1:REDUCED_NAGS,1:IALL(0),1:IALL(0))=DCMPLX(0.0D0,0.0D0)
   DO L=1,REDUCED_NAGS
    DO I=1,NCGS
     DO MOP=1,IALL(0)
      WC1(I,MOP)=DCMPLX(0.0D0,0.0D0)
      DO J=1,NCGS
       WC1(I,MOP)=WC1(I,MOP)+CO(J,MOP,0)*CANN1(L,I,J)
      ENDDO
     ENDDO
    ENDDO
    DO MOP=1,IALL(0)
     DO MOQ=1,IALL(0)
      DO I=1,NCGS
       CANN2(L,MOQ,MOP)=CANN2(L,MOQ,MOP)+DCONJG(CO(I,MOQ,0))*WC1(I,MOP)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(WC1)

   ! FORM MATRIX REPRESENTATION OF CHI
   ALLOCATE(CHI(REDUCED_NAGS,REDUCED_NAGS))
   DO I=1,REDUCED_NAGS
    DO J=1,REDUCED_NAGS
     CHI(J,I)=DCMPLX(0.0D0,0.0D0)
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       CHI(J,I)=CHI(J,I)+2.0D0*CANN2(J,MOI,MOA)*CANN2(I,MOA,MOI)/(EPSILON(MOI,0)-EPSILON(MOA,0))
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'MATRIX REPRESENTATION OF CHI'
    CALL DUMP7(CHI,REDUCED_NAGS)
   ENDIF

   ! DIAGONALIZE CHI REP TO SEE HOW MANY SINGULARITIES ARE THERE
   ALLOCATE(WR2(REDUCED_NAGS),WC1(REDUCED_NAGS,REDUCED_NAGS),V2(REDUCED_NAGS,REDUCED_NAGS))
   CALL HHBS(REDUCED_NAGS,REDUCED_NAGS,CHI,WR2,WC1)
   REDUCED_REDUCED_NAGS=0
   DO I=1,REDUCED_NAGS
    IF (DABS(WR2(I)) > DABS(WR2(1))*1.0D-7) THEN
     REDUCED_REDUCED_NAGS=REDUCED_REDUCED_NAGS+1
     DO J=1,REDUCED_NAGS
      V2(J,REDUCED_REDUCED_NAGS)=WC1(J,I)
     ENDDO
    ENDIF
   ENDDO
   DEALLOCATE(CHI,WC1)

   ! FORM INVERSE OF CHI
   DO I=1,REDUCED_NAGS
    DO J=1,REDUCED_NAGS
     CHI_INVERSE(J,I)=DCMPLX(0.0D0,0.0D0)
     DO K=1,REDUCED_REDUCED_NAGS
      CHI_INVERSE(J,I)=CHI_INVERSE(J,I)+V2(J,K)*V2(I,K)/WR2(K)
     ENDDO
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'MATRIX REPRESENTATION OF CHI INVERSE'
    CALL DUMP7(CHI_INVERSE,NAGS)
   ENDIF
   DEALLOCATE(V2,WR2)

   ! FORM OEP EXCHANGE INTEGRAL MATRIX
   ALLOCATE(WC2(REDUCED_NAGS),WC3(REDUCED_NAGS))
   IF (IOPTN(71) <= 2) THEN
    DO I=1,REDUCED_NAGS
     WC2(I)=DCMPLX(0.0D0,0.0D0)
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       WC2(I)=WC2(I)+(CANN2(I,MOA,MOI)*X_M(MOI,MOA)+CANN2(I,MOI,MOA)*X_M(MOA,MOI))/(EPSILON(MOI,0)-EPSILON(MOA,0))
      ENDDO
     ENDDO
    ENDDO
   ELSE
    DO I=1,REDUCED_NAGS
     WC2(I)=DCMPLX(0.0D0,0.0D0)
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       WC2(I)=WC2(I)+(CANN2(I,MOA,MOI)*(X_M(MOI,MOA)+2.0D0*Y_M(MOI,MOA))+CANN2(I,MOI,MOA)*(X_M(MOA,MOI)+2.0D0*Y_M(MOA,MOI))) &
       /(EPSILON(MOI,0)-EPSILON(MOA,0))
      ENDDO
     ENDDO
    ENDDO
    DEALLOCATE(Y_M)
   ENDIF
   DO I=1,REDUCED_NAGS
    WC3(I)=DCMPLX(0.0D0,0.0D0)
    DO J=1,REDUCED_NAGS
     WC3(I)=WC3(I)+CHI_INVERSE(I,J)*WC2(J)
    ENDDO
   ENDDO
   DO I=1,NCGS
    DO J=1,NCGS
     IF (IOPTN(71) <= 2) O_C(J,I,0)=0.0D0
     IF (IOPTN(71) >= 3) O_C(J,I,0)=-2.0D0*Y_C(J,I,0)
     DO K=1,REDUCED_NAGS
      O_C(J,I,0)=O_C(J,I,0)+DREAL(CANN1(K,J,I)*WC3(K))
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(WC2,CANN1)
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'OEP EXCHANGE INTEGRAL MATRIX'
    CALL DUMP1(O_C,NCGS,0)
   ENDIF
   
   ! CONSTRUCT OEP EXCHANGE MATRIX IN THE MO BASIS
   ALLOCATE(O_M(IALLMAX,IALLMAX))
   ALLOCATE(WC1(NCGS,IALLMAX))
   DO MOP=1,IALL(0)
    DO I=1,NCGS
     WC1(I,MOP)=DCMPLX(0.0D0,0.0D0)
     DO J=1,NCGS
      WC1(I,MOP)=WC1(I,MOP)+O_C(I,J,0)*DCONJG(CO(J,MOP,0))
     ENDDO
    ENDDO
   ENDDO
   DO MOQ=1,IALL(0)
    DO MOP=1,IALL(0)
     O_M(MOQ,MOP)=DCMPLX(0.0D0,0.0D0)
     DO I=1,NCGS
      O_M(MOQ,MOP)=O_M(MOQ,MOP)+WC1(I,MOP)*CO(I,MOQ,0)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(WC1)
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'OEP EXCHANGE MATRIX IN THE MO BASIS'
    CALL DUMP7(O_M,IALLMAX)
   ENDIF

   ! MAKE KERNEL CORE
   DO I=1,REDUCED_NAGS
    DO J=1,REDUCED_NAGS 
     KERNEL_CORE(J,I)=DCMPLX(0.0D0,0.0D0)
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       DO MOB=IOCC+1,IALL(0)
        ! NOTE THAT O_M AND X_M SHOULD ACCOMPANY THE FACTOR (-1/2); SEE PFOCK.F90
        KERNEL_CORE(J,I)=KERNEL_CORE(J,I)+CANN2(J,MOI,MOA)*CANN2(I,MOI,MOB)*(O_M(MOB,MOA)-X_M(MOB,MOA)) &
                                         /(EPSILON(MOI,0)-EPSILON(MOA,0))/(EPSILON(MOI,0)-EPSILON(MOB,0))
       ENDDO
      ENDDO
     ENDDO
     DO MOI=1,IOCC
      DO MOJ=1,IOCC
       DO MOA=IOCC+1,IALL(0)
        KERNEL_CORE(J,I)=KERNEL_CORE(J,I)-CANN2(J,MOI,MOA)*CANN2(I,MOA,MOJ)*(O_M(MOI,MOJ)-X_M(MOI,MOJ)) &
                                         /(EPSILON(MOI,0)-EPSILON(MOA,0))/(EPSILON(MOJ,0)-EPSILON(MOA,0))
       ENDDO
      ENDDO
     ENDDO
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       DO MOB=IOCC+1,IALL(0)
        KERNEL_CORE(J,I)=KERNEL_CORE(J,I)+CANN2(J,MOB,MOA)*CANN2(I,MOI,MOB)*(O_M(MOI,MOA)-X_M(MOI,MOA)) &
                                         /(EPSILON(MOI,0)-EPSILON(MOA,0))/(EPSILON(MOI,0)-EPSILON(MOB,0))
       ENDDO
      ENDDO
     ENDDO
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       DO MOB=IOCC+1,IALL(0)
        KERNEL_CORE(J,I)=KERNEL_CORE(J,I)+CANN2(J,MOI,MOB)*CANN2(I,MOB,MOA)*(O_M(MOI,MOA)-X_M(MOI,MOA)) &
                                         /(EPSILON(MOI,0)-EPSILON(MOA,0))/(EPSILON(MOI,0)-EPSILON(MOB,0))
       ENDDO
      ENDDO
     ENDDO
     DO MOI=1,IOCC
      DO MOJ=1,IOCC
       DO MOA=IOCC+1,IALL(0)
        KERNEL_CORE(J,I)=KERNEL_CORE(J,I)-CANN2(J,MOI,MOJ)*CANN2(I,MOA,MOJ)*(O_M(MOI,MOA)-X_M(MOI,MOA)) &
                                         /(EPSILON(MOI,0)-EPSILON(MOA,0))/(EPSILON(MOJ,0)-EPSILON(MOA,0))
       ENDDO
      ENDDO
     ENDDO
     DO MOI=1,IOCC
      DO MOJ=1,IOCC
       DO MOA=IOCC+1,IALL(0)
        KERNEL_CORE(J,I)=KERNEL_CORE(J,I)-CANN2(J,MOA,MOJ)*CANN2(I,MOI,MOJ)*(O_M(MOI,MOA)-X_M(MOI,MOA)) &
                                         /(EPSILON(MOI,0)-EPSILON(MOA,0))/(EPSILON(MOJ,0)-EPSILON(MOA,0))
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   
   ALLOCATE(DANN1(NAGS,NCGS,NCGS),DANN2(NAGS,NCGS,NCGS))
   DO K=1,NCGS
    DO J=1,NCGS
     DO I=1,REDUCED_NAGS
      DANN1(I,J,K)=0.0D0
      DO MOJ=1,IOCC
       DO MOB=IOCC+1,IALL(0)
        DANN1(I,J,K)=DANN1(I,J,K)+CO(J,MOJ,0)*CO(K,MOB,0)*CANN2(I,MOJ,MOB)/(EPSILON(MOJ,0)-EPSILON(MOB,0))
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO

   REWIND(31)
   DANN2=0.0D0
   ALLOCATE(ICASHE1(CASHESIZE),ICASHE2(CASHESIZE),DCASHE(CASHESIZE))
   DO
    READ(31,IOSTAT=EOF) ICASHE1,ICASHE2,DCASHE
    IF (EOF /= 0) EXIT
    DO ICASHECOUNT=1,CASHESIZE
     IF (ICASHE1(ICASHECOUNT) == -1) EXIT
     P=0
     Q=0
     R=0
     I=0
     J=0
     K=0
     L=0
     CALL MVBITS(ICASHE1(ICASHECOUNT),16,8,P,0)
     CALL MVBITS(ICASHE1(ICASHECOUNT), 8,8,Q,0)
     CALL MVBITS(ICASHE1(ICASHECOUNT), 0,8,R,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT),24,8,I,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT),16,8,J,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT), 8,8,K,0)
     CALL MVBITS(ICASHE2(ICASHECOUNT), 0,8,L,0)
     DO M=1,REDUCED_NAGS
      DANN2(M,I,L)=DANN2(M,I,L)+(DANN1(M,K,J)+DANN1(M,J,K))*DCASHE(ICASHECOUNT)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(ICASHE1,ICASHE2,DCASHE)
   DEALLOCATE(DANN1)

   ALLOCATE(DANN3(NAGS,IALLMAX,IALLMAX))
   DO MOA=IOCC+1,IALL(0)
    DO MOI=1,IOCC
     DO I=1,REDUCED_NAGS
      DANN3(I,MOI,MOA)=0.0D0
      DO J=1,NCGS
       DO K=1,NCGS
        DANN3(I,MOI,MOA)=DANN3(I,MOI,MOA)+CO(J,MOI,0)*CO(K,MOA,0)*DANN2(I,J,K)
       ENDDO
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(DANN2)
   DO I=1,REDUCED_NAGS
    DO J=1,REDUCED_NAGS
     DO MOI=1,IOCC
      DO MOA=IOCC+1,IALL(0)
       KERNEL_CORE(J,I)=KERNEL_CORE(J,I)-2.0D0*CANN2(J,MOI,MOA)*DANN3(I,MOI,MOA)/(EPSILON(MOI,0)-EPSILON(MOA,0))
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(DANN3,CANN2) 

   ! FORM X^(-1)H X^(-1)
   ALLOCATE(WC1(NAGS,NAGS))
   DO I=1,REDUCED_NAGS
    DO J=1,REDUCED_NAGS
     WC1(J,I)=DCMPLX(0.0D0,0.0D0)
     DO K=1,REDUCED_NAGS
      WC1(J,I)=WC1(J,I)+KERNEL_CORE(J,K)*CHI_INVERSE(K,I)
     ENDDO
    ENDDO
   ENDDO
   DO I=1,REDUCED_NAGS
    DO J=1,REDUCED_NAGS
     KERNEL_CORE(J,I)=DCMPLX(0.0D0,0.0D0)
     DO K=1,REDUCED_NAGS
      KERNEL_CORE(J,I)=KERNEL_CORE(J,I)+CHI_INVERSE(J,K)*WC1(K,I)
     ENDDO
    ENDDO
   ENDDO
   IF (IOPTN(9) == 3) THEN
    WRITE(6,'(A)') 'CORE OF THE KERNEL'
    CALL DUMP11(KERNEL_CORE,REDUCED_NAGS,NAGS)
   ENDIF
   DEALLOCATE(WC1) 

   RETURN
END SUBROUTINE
