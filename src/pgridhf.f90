SUBROUTINE GRIDHF2

! Perform an exact grid-based HF calculation of a polyatomic molecule,
! using au auxiliary basis set.

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   INTEGER,PARAMETER :: MAXMACROITER=1000
   INTEGER,PARAMETER :: MAXMICROITER=10
   INTEGER :: ISIZE
   INTEGER :: MACROITER,MICROITER
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:)
   DOUBLE PRECISION :: RH
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   INTEGER :: I,J,K

   K=1
   DO I=1,NATOM
    IF (IATOM(I) > IATOM(K)) K=I
   ENDDO

   ! CREATE A FACTORIAL LIST
   ALLOCATE(FACTORIAL(0:80),SGN(-80:80))
   FACTORIAL(0)=1.0D0
   DO I=1,80
    FACTORIAL(I)=FACTORIAL(I-1)*DFLOAT(I)
   ENDDO
   DO I=-80,80
    SGN(I)=(-1.0D0)**I
   ENDDO

   ALLOCATE(NGRID(NATOM),GRIDX(MAXNGRID,NATOM),GRIDY(MAXNGRID,NATOM),GRIDZ(MAXNGRID,NATOM),GRIDW(MAXNGRID,NATOM))
   ALLOCATE(FUZZYW(MAXNGRID,NATOM),GRIDATOMW(MAXNGRID,NATOM),RHO(MAXNGRID,NATOM),GDIAG(MAXNGRID))
   ALLOCATE(GAUSS_CHEV(MAX(50,IOPTN(81)),NATOM),GAUSS_CHEV_W(MAX(50,IOPTN(81)),NATOM))
   ALLOCATE(LEBEDVX(IOPTN(82)),LEBEDVY(IOPTN(82)),LEBEDVZ(IOPTN(82)),LEBEDVW(IOPTN(82)))

   CALL CONSTRUCT_GRID2
   CALL GRID_WEIGHT2
   ALLOCATE(SECONDDERIV(15,RG,NATOM),YLMMEM(0:LMAX,-LMAX:LMAX,AG))
   SECONDERIV=0.0D0
   CALL SECOND_DERIV_DELTA
!  DO I=1,NATOM
!   CALL DUMP10(SECONDDERIV(:,:,I),RG,RG)
!  ENDDO
   CALL YLM4
!  CALL ELECTRON_DENSITY
!  CALL INTEGRATE_ELECTRON_DENSITY

   ALLOCATE(MORBITALS(MAXNGRID,NATOM,IOCC))
   ALLOCATE(RESIDUAL(MAXNGRID,IOCC))
   ALLOCATE(WORK1(MAXNGRID),R1(0:LMAX,-LMAX:LMAX,RG))
   DO I=1,IOCC
    R1=0.0D0
    DO J=1,RG
     RH=DFLOAT(IATOM(K))*GAUSS_CHEV(J,K)
     R1(0,0,J)=DEXP(-RH*0.7D0**(I-2))
    ENDDO
    CALL PACKYLM2(LMAX,WORK1,R1,RG,AG)
    DO J=1,NGRID(K)
     RESIDUAL(J,I)=WORK1(J)
    ENDDO
   ENDDO

   CALL GRID_ORBITALS
!  MORBITALS=0.0D0
   CALL GRID_DENSITY
!  CALL CONSTRUCT_GDIAG
!  CALL GRID_J3
   CALL GRID_K2
   CALL GRID_T2
   CALL GRID_N2
   CALL GRID_J2
!  CALL GRID_J1
!  CALL GRID_N1
!  CALL GRID_T1

   DO MACROITER=1,MAXMACROITER ! LOOP FOR A BASIS EXPANSION
    WRITE(6,'(I3,A)') MACROITER,' ITERATION'
!   ISIZE=2*IOCC ! here
    ISIZE=MAXNGRID
    ALLOCATE(AOBASIS(MAXNGRID,ISIZE))
    CALL GRID_AOBASIS(MACROITER,ISIZE) ! ISIZE WILL BE ADJUSTED
    WRITE(6,'(A,I5)') 'DIMENSION OF FOCK = ',ISIZE
    CALL PFLUSH(6)
    IF (ISIZE < IOCC) CALL PABORT('INCREASE ANGULAR GRID SIZE')
    CALL GRID_DENSITY
    ALLOCATE(GCORE(ISIZE,ISIZE),GFOCK(ISIZE,ISIZE),GOVLP(ISIZE,ISIZE),GEPSILON(ISIZE))
    CALL GRID_SCF(MICROITER,ISIZE)
    DEALLOCATE(GCORE,GFOCK,GOVLP,GEPSILON)
    DEALLOCATE(AOBASIS)
   ENDDO

   DEALLOCATE(RESIDUAL,MORBITALS,SECONDDERIV,YLMMEM)
   DEALLOCATE(NGRID,GRIDX,GRIDY,GRIDZ,GRIDW)
   DEALLOCATE(FUZZYW,GRIDATOMW,RHO,GDIAG)
   DEALLOCATE(GAUSS_CHEV,GAUSS_CHEV_W,LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW)
   DEALLOCATE(FACTORIAL,SGN)
   DEALLOCATE(WORK1,R1)
   
   RETURN
END SUBROUTINE



SUBROUTINE GRID_ORBITALS
! Make occupied orbitals on a 3D grid

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: CGS(:,:),C2P(:) ! 'C2P' IS WORKING ARRAY FOR CGS_GRID
   INTEGER :: I,J,K,L

   ALLOCATE(CGS(NCGS,0:0),C2P(NPGS))
   DO I=1,NATOM
    DO J=1,NGRID(I)
     CALL CGS_GRID(CGS,C2P,NCGS,0,NPGS,J,I)
     DO K=1,IOCC
      MORBITALS(J,I,K)=0.0D0
      DO L=1,NCGS
       MORBITALS(J,I,K)=MORBITALS(J,I,K)+DREAL(CO(L,K,0))*CGS(L,0)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   IF (IOPTN(9) >= 2) THEN
    WRITE(6,'(A)') 'OCCUPIED ORBITALS'
    WRITE(6,'(10I8:)') (K,K=1,IOCC)
    DO I=1,NATOM
     DO J=1,NGRID(I)
      WRITE(6,'(10F8.4:)') (MORBITALS(J,I,K),K=1,IOCC)
     ENDDO
    ENDDO
   ENDIF
   DEALLOCATE(CGS,C2P)

   RETURN
END SUBROUTINE



SUBROUTINE GRID_AOBASIS(ORDER,ISIZE)
! Make arbitrary atomic orbital like basis functions as many times as IOCC

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: ORDER,ISIZE
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:),WORK2(:)
   DOUBLE PRECISION,ALLOCATABLE :: LG(:,:,:)
   DOUBLE PRECISION :: RH
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: PRJ(:,:,:)
   INTEGER :: I,J,K,L,M,N,O
   DOUBLE PRECISION :: S
   DOUBLE PRECISION :: X,Y,Z

   ALLOCATE(WORK1(MAXNGRID),LG(RG,0:2*ORDER,0:2*ORDER))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(PRJ(RG,0:LMAX,30),WORK2(RG))
   K=1
   DO I=1,NATOM
    IF (IATOM(I) > IATOM(K)) K=I
   ENDDO
   WRITE(6,'(A,I3)') "AO BASIS GENERATION ON ONE CENTER:",K

! From here ...
 AOBASIS=0.0D0
 i=0
 do L=0,LMAX
  do m=-L,L
   do n=1,rg
    r1=0.0D0
    r1(l,m,n)=1.0d0/dsqrt(gauss_chev_w(n,k))
    i=i+1
    CALL PACKYLM2(LMAX,aobasis(:,i),R1,RG,AG)
   enddo
  enddo
 enddo
 ISIZE=i
 return
! to here: full diagonalization.

   PRJ=0.0D0
   DO L=0,LMAX
    DO N=1,10
     DO J=1,RG
      RH=DFLOAT(IATOM(K))/DFLOAT(L+1)*GAUSS_CHEV(J,K)
      PRJ(J,L,N)=RH**L*DEXP(-RH*0.7D0**(N-4))
     ENDDO
     IF (N == 1) THEN
      S=0.0D0
      DO J=1,RG
       S=S+PRJ(J,L,N)**2*GAUSS_CHEV_W(J,K)
      ENDDO
      S=DSQRT(S)
      DO J=1,RG
       PRJ(J,L,N)=PRJ(J,L,N)/S
      ENDDO 
     ELSE
      DO M=1,N-1
       S=0.0D0
       DO J=1,RG
        S=S+PRJ(J,L,N)*PRJ(J,L,M)*GAUSS_CHEV_W(J,K)
       ENDDO
       DO J=1,RG
        PRJ(J,L,N)=PRJ(J,L,N)-S*PRJ(J,L,M)
       ENDDO
      ENDDO
      S=0.0D0
      DO J=1,RG
       S=S+PRJ(J,L,N)**2*GAUSS_CHEV_W(J,K)
      ENDDO
      S=DSQRT(S)
      DO J=1,RG
       PRJ(J,L,N)=PRJ(J,L,N)/S
      ENDDO 
     ENDIF
    ENDDO
!write(*,*) l,'1-5'
!do j=1,rg
! write(*,'(5f14.5)') prj(j,l,1),prj(j,l,2),prj(j,l,3),prj(j,l,4),prj(j,l,5)
!enddo
!write(*,*) l,'6-10'
!do j=1,rg
! write(*,'(5f14.5)') prj(j,l,6),prj(j,l,7),prj(j,l,8),prj(j,l,9),prj(j,l,10)
!enddo
!write(*,*) l,'11-15'
!do j=1,rg
! write(*,'(5f14.5)') prj(j,l,11),prj(j,l,12),prj(j,l,13),prj(j,l,14),prj(j,l,15)
!enddo
   ENDDO 
!i=0
!do l=0,1
! do m=-l,l
!  do n=1,10
!   i=i+1
!   r1=0.0d0
!   do j=1,rg
!    r1(l,m,j)=prj(j,l,n)
!   enddo
!   call packylm2(lmax,aobasis(:,I),r1,rg,ag)
!  enddo
! enddo
!enddo
!isize=i
!return
   

   I=0
   DO N=1,IOCC
    I=I+1
    DO J=1,NGRID(K)
     AOBASIS(J,I)=MORBITALS(J,K,N)
    ENDDO
    IF (N > 1) THEN
     DO L=1,N-1
      S=0.0D0
      DO J=1,NGRID(K)
       S=S+AOBASIS(J,N)*AOBASIS(J,L)*GRIDATOMW(J,K)
      ENDDO
      DO J=1,NGRID(K)
       AOBASIS(J,N)=AOBASIS(J,N)-S*AOBASIS(J,L)
      ENDDO
     ENDDO
    ENDIF
    CALL EXPANDYLM2(LMAX,AOBASIS(:,I),R1,RG,AG)
    DO L=0,LMAX
     DO M=-L,L
      IF (L > LMAX/2) THEN
       DO J=1,RG
        R1(L,M,J)=0.0D0
       ENDDO
      ENDIF
     ENDDO
    ENDDO
    CALL PACKYLM2(LMAX,AOBASIS(:,I),R1,RG,AG)
    S=0.0D0
    DO J=1,NGRID(K)
     S=S+AOBASIS(J,I)**2*GRIDATOMW(J,K)
    ENDDO
    S=DSQRT(S)
    DO J=1,NGRID(K)
     AOBASIS(J,I)=AOBASIS(J,I)/S
    ENDDO
   ENDDO
   DO N=1,IOCC
    CALL EXPANDYLM2(LMAX,RESIDUAL(:,N),R1,RG,AG)
    DO L=0,LMAX
     DO M=-L,L
!     WORK2=0.0D0
!     DO O=1,10
!      S=0.0D0
!      DO J=1,RG
!       S=S+R1(L,M,J)*PRJ(J,L,O)*GAUSS_CHEV_W(J,K)
!      ENDDO
!      DO J=1,RG
!       WORK2(J)=WORK2(J)+PRJ(J,L,O)*S
!      ENDDO
!     ENDDO
!     DO J=1,RG
!      R1(L,M,J)=WORK2(J)
!     ENDDO
      IF (L > LMAX/2) THEN
       DO J=1,RG
        R1(L,M,J)=0.0D0
       ENDDO
      ENDIF
     ENDDO
    ENDDO
! comment out from here (if regularizing not desired)
    WRITE(6,'(A)') 'REGULARIZING BY ELIMINATING LMAX/2 < L =< LMAX COMPONENTS ...'
    CALL PACKYLM2(LMAX,RESIDUAL(:,N),R1,RG,AG)
! ... to here
!   CALL PACKYLM2(LMAX,WORK1,R1,RG,AG)
!DO L=1,NGRID(K)
!X=GRIDX(L,K)+ATOMX(K)
!Y=GRIDY(L,K)+ATOMY(K)
!Z=GRIDZ(L,K)+ATOMZ(K)
!IF (X == 0.0D0) WRITE(6,'(4F20.10)') Y,Z,RESIDUAL(L,N),WORK1(L)
!ENDDO

    DO L=1,I
     S=0.0D0
     DO J=1,NGRID(K)
      S=S+RESIDUAL(J,N)*AOBASIS(J,L)*GRIDATOMW(J,K)
     ENDDO
     DO J=1,NGRID(K)
      RESIDUAL(J,N)=RESIDUAL(J,N)-S*AOBASIS(J,L)
     ENDDO
    ENDDO
    S=0.0D0
    DO J=1,NGRID(K)
     S=S+RESIDUAL(J,N)**2*GRIDATOMW(J,K)
    ENDDO
    S=DSQRT(S)
    DO J=1,NGRID(K)
     RESIDUAL(J,N)=RESIDUAL(J,N)/S
    ENDDO
    IF (S > 1.0D-6) THEN
     I=I+1
     DO J=1,NGRID(K)
      AOBASIS(J,I)=RESIDUAL(J,N)
     ENDDO
    ENDIF
   ENDDO
!  DO N=1,ORDER*2
!   IF (N == 0) THEN
!    DO J=1,RG
!     LG(J,N)=1.0D0
!    ENDDO
!   ELSE IF (N == 1) THEN
!    DO J=1,RG
!     RH=2.0D0*DFLOAT(IATOM(K))/DFLOAT(ORDER)*GAUSS_CHEV(J,K)
!     LG(J,N)=-RH+1.0D0
!    ENDDO
!   ELSE
!    DO J=1,RG
!     RH=2.0D0*DFLOAT(IATOM(K))/DFLOAT(ORDER)*GAUSS_CHEV(J,K)
!     LG(J,N)=(2.0D0*DFLOAT(N)-1.0D0-RH)*LG(J,N-1)-DFLOAT(N-1)**2*LG(J,N-2)
!    ENDDO
!   ENDIF
!   DO L=0,N
!    DO J=1,RG
!     RH=2.0D0*DFLOAT(IATOM(K))/DFLOAT(N)*GAUSS_CHEV(J,K)
!     LG(J,N,L)=0.0D0
!     DO M=L,N
!      LG(J,N,L)=LG(J,N,L)+FACTORIAL(N)/FACTORIAL(N-M)/FACTORIAL(M-L)/FACTORIAL(M)*(RH)**(M-L)*SGN(M)
!     ENDDO
!    ENDDO
!   ENDDO
!  ENDDO
! uncomment from here
!  DO L=0,MIN(ORDER,LMAX/2) ! here
!   DO N=1,MIN(6+ORDER*2,20)
!    WRITE(6,'(A,2I3)') 'N,L =',N,L
!    DO M=-L,L
!     I=I+1
!     R1=0.0D0
!     DO J=1,RG
!      RH=DFLOAT(IATOM(K))/DFLOAT(L+1)*GAUSS_CHEV(J,K)
!      R1(L,M,J)=RH**L*DEXP(-RH*0.7D0**(N-4))
!     ENDDO
!     CALL PACKYLM2(LMAX,WORK1,R1,RG,AG)
!     DO J=1,NGRID(K)
!      AOBASIS(J,I)=WORK1(J)
!     ENDDO
!    ENDDO
!   ENDDO
!  ENDDO
   ISIZE=I
!do i=1,isize
!CALL EXPANDYLM2(LMAX,AOBASIS(:,i),R1,RG,AG)
!call dump12(LMAX,R1,RG,'AOBASIS')
!enddo
   CALL PFLUSH(6)

   DEALLOCATE(WORK1,R1,LG,PRJ,WORK2)
   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCT_GDIAG
! Make diagonal part of the H core matrix


   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: I,J,K,N
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:)
   DOUBLE PRECISION,ALLOCATABLE :: WORK2(:)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R2(:,:,:)
   DOUBLE PRECISION :: X0,Y0,Z0,X1,Y1,Z1

   ALLOCATE(WORK1(MAXNGRID))
   ALLOCATE(WORK2(MAXNGRID))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(R2(0:LMAX,-LMAX:LMAX,RG))

   K=1
   N=0
   DO I=1,NATOM
    IF (IATOM(I) > IATOM(K)) K=I
    N=N+IATOM(I)
   ENDDO
   N=N+CHARGE
   WRITE(6,'(A,I3)') "AO BASIS GENERATION ON ONE CENTER:",K

   GDIAG=0.0D0
   ! COULOMB POTENTIAL
   DO J=1,NGRID(K)
    WORK2(J)=RHO(J,K)
   ENDDO
   CALL EXPANDYLM2(LMAX,WORK2,R1,RG,AG)
   CALL POISSON2(LMAX,R1,R2,RG,K)
   CALL PACKYLM2(LMAX,WORK2,R2,RG,AG)
   DO I=1,NGRID(K)
write(*,*) I
    WORK1=0.0D0
    WORK1(I)=1.0D0
    ! KINETIC
    CALL EXPANDYLM2(LMAX,WORK1,R1,RG,AG)
    CALL KINETICYLM2(LMAX,R1,R2,RG,K)
    CALL PACKYLM2(LMAX,WORK1,R2,RG,AG)
    GDIAG(I)=WORK1(I)
    ! NUCLEAR
    DO J=1,NATOM
     X0=ATOMX(K)+GRIDX(I,K)
     Y0=ATOMY(K)+GRIDY(I,K)
     Z0=ATOMZ(K)+GRIDZ(I,K)
     X1=ATOMX(J)
     Y1=ATOMY(J)
     Z1=ATOMZ(J)
     GDIAG(I)=GDIAG(I)-DFLOAT(IATOM(J))/DSQRT((X1-X0)**2+(Y1-Y0)**2+(Z1-Z0)**2)
    ENDDO
    ! COULOMB
    GDIAG(I)=GDIAG(I)+WORK2(I)*DFLOAT(N-1)/DFLOAT(N)
!   GDIAG(I)=GDIAG(I)+WORK2(I)*0.5D0
!   ! EXCHANGE
!   DO J=1,IOCC
!    WORK1=0.0D0
!    WORK1(I)=MORBITALS(I,K,J)
!    CALL EXPANDYLM2(LMAX,WORK1,R1,RG,AG)
!    CALL POISSON2(LMAX,R1,R2,RG,K)
!    CALL PACKYLM2(LMAX,WORK1,R2,RG,AG)
!    GDIAG(I)=GDIAG(I)-WORK1(I)*MORBITALS(I,K,J)
!   ENDDO

   ENDDO
   DEALLOCATE(WORK1)
   DEALLOCATE(WORK2)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_DENSITY
! Make density from occupied orbitals

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: I,J,K

   RHO=0.0D0
   DO K=1,IOCC
    DO I=1,NATOM
     DO J=1,NGRID(I)
      RHO(J,I)=RHO(J,I)+2.0D0*MORBITALS(J,I,K)**2
     ENDDO
    ENDDO
   ENDDO

   RETURN
END SUBROUTINE



SUBROUTINE GRID_SCF(ITER,ISIZE)
! Act Fock operator on one center

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU
   USE GRADIENT

   IMPLICIT NONE
   INTEGER :: ITER
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:)
   DOUBLE PRECISION,ALLOCATABLE :: COUL(:)
   DOUBLE PRECISION,ALLOCATABLE :: EXCH(:)
   DOUBLE PRECISION,ALLOCATABLE :: FXAO(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: FXMO(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R2(:,:,:)
   DOUBLE PRECISION :: S1,S2,F1,F2,C1,E1,T1
   DOUBLE PRECISION :: X0,Y0,Z0,X1,Y1,Z1
   INTEGER :: I,J,K,L,M
   INTEGER :: ISIZE
   DOUBLE PRECISION,ALLOCATABLE :: FS1(:,:),FS2(:,:),FOCKOLD(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: VR(:,:),VL(:,:),ER(:),EI(:),WK(:),VRS(:,:)
   INTEGER :: INFO
   DOUBLE PRECISION :: X,Y,Z

   ALLOCATE(WORK1(MAXNGRID))
   ALLOCATE(COUL(MAXNGRID))
   ALLOCATE(EXCH(MAXNGRID))
   ALLOCATE(FXAO(MAXNGRID,ISIZE))
   ALLOCATE(FXMO(MAXNGRID,IOCC))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(R2(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(FOCKOLD(ISIZE,ISIZE))
   IF (ITER > 1) THEN
    FOCKOLD=GFOCK
   ENDIF
   K=1
   DO I=1,NATOM
    IF (IATOM(I) > IATOM(K)) K=I
   ENDDO
   WRITE(6,'(A,I3,A,I5)') "APPLY FOCK OPERATOR WITH A ONE-CENTER QUADRATURE ",K," WITH SUBSPACE SIZE:",ISIZE
   CALL PFLUSH(6)
   ! NORMALIZE AO BASIS
   DO I=1,ISIZE
    T1=0.0D0
    DO L=1,NGRID(K)
     T1=T1+AOBASIS(L,I)**2*GRIDATOMW(L,K)
    ENDDO
    T1=DSQRT(T1)
    DO L=1,NGRID(K)
     AOBASIS(L,I)=AOBASIS(L,I)/T1
    ENDDO
   ENDDO
   ! COULOMB POTENTIAL
   DO J=1,NGRID(K)
    COUL(J)=RHO(J,K)
   ENDDO
   CALL EXPANDYLM2(LMAX,COUL,R1,RG,AG)
   IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'DENSITY')
   CALL POISSON2(LMAX,R1,R2,RG,K)
   IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'COULOMB POTENTIAL')
   CALL PACKYLM2(LMAX,COUL,R2,RG,AG)
   ! LOOP OVER AO 1
   DO L=1,ISIZE
    ! KINETIC
    DO J=1,NGRID(K)
     WORK1(J)=AOBASIS(J,L)
    ENDDO
    CALL EXPANDYLM2(LMAX,WORK1,R1,RG,AG)
    IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'ORBITAL')
    CALL KINETICYLM2(LMAX,R1,R2,RG,K)
    IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'KINETIC x ORBITAL')
    CALL PACKYLM2(LMAX,WORK1,R2,RG,AG)
    DO J=1,NGRID(K)
     FXAO(J,L)=WORK1(J)
    ENDDO
    ! NUCLEAR
    WORK1=0.0D0
    DO I=1,NATOM
     X0=ATOMX(I)
     Y0=ATOMY(I)
     Z0=ATOMZ(I)
     DO J=1,NGRID(K)
      X1=ATOMX(K)+GRIDX(J,K)
      Y1=ATOMY(K)+GRIDY(J,K)
      Z1=ATOMZ(K)+GRIDZ(J,K)
      WORK1(J)=WORK1(J)-DFLOAT(IATOM(I))*AOBASIS(J,L)/DSQRT((X1-X0)**2+(Y1-Y0)**2+(Z1-Z0)**2)
     ENDDO
    ENDDO
    DO J=1,NGRID(K)
     FXAO(J,L)=FXAO(J,L)+WORK1(J)
    ENDDO
    ! EXCHANGE
    EXCH=0.0D0
    DO I=1,IOCC
     DO J=1,NGRID(K)
      WORK1(J)=AOBASIS(J,L)*MORBITALS(J,K,I)
     ENDDO
     CALL EXPANDYLM2(LMAX,WORK1,R1,RG,AG)
     IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'DENSITY')
     CALL POISSON2(LMAX,R1,R2,RG,K)
     IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'EXCHANGE POTENTIAL')
     CALL PACKYLM2(LMAX,WORK1,R2,RG,AG)
     DO J=1,NGRID(K)
      EXCH(J)=EXCH(J)-WORK1(J)*MORBITALS(J,K,I)
     ENDDO
    ENDDO
    ! LOOP OVER AO 2
    DO M=1,ISIZE
     ! OVERLAP
     S1=0.0D0
     DO J=1,NGRID(K)
      S1=S1+AOBASIS(J,L)*AOBASIS(J,M)*GRIDATOMW(J,K)
     ENDDO
     GOVLP(M,L)=S1
     ! FOCK
     C1=0.0D0
     DO J=1,NGRID(K)
      C1=C1+FXAO(J,L)*AOBASIS(J,M)*GRIDATOMW(J,K)
     ENDDO
     GCORE(L,M)=C1
     F1=C1
     ! COULOMB
     DO J=1,NGRID(K)
      F1=F1+(COUL(J)*AOBASIS(J,L)+EXCH(J))*AOBASIS(J,M)*GRIDATOMW(J,K)
     ENDDO
     GFOCK(L,M)=F1
     F2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       F2=F2+DREAL(CO(I,M,0))*CO(J,L,0)*F_C(I,J,0)
      ENDDO
     ENDDO
!    WRITE(6,'(2I3,2F15.10)') L,M,F1,F2
    ENDDO
    ! COULOMB & EXCHANGE
    DO J=1,NGRID(K)
     FXAO(J,L)=FXAO(J,L)+(COUL(J)*AOBASIS(J,L)+EXCH(J))
    ENDDO
   ENDDO
!  IF (ITER > 4) THEN
!   GFOCK=0.5D0*GFOCK+0.5D0*FOCKOLD
!  ENDIF
   WRITE(6,'(A)') 'FOCK AND OVERLAP MATRIX EVALUATED BY QUADRATURE'
!  CALL DUMP10(GOVLP,ISIZE,ISIZE)
!  CALL DUMP10(GFOCK,ISIZE,ISIZE)
   ! FOCK DIAGONALIZATION
   ALLOCATE(VR(ISIZE,ISIZE),VL(1,ISIZE),ER(ISIZE),EI(ISIZE),WK(4*ISIZE),FS1(ISIZE,ISIZE))
   FS1=GFOCK
   CALL DGEEV('N','V',ISIZE,FS1,ISIZE,ER,EI,VL,1,VR,ISIZE,WK,4*ISIZE,INFO)
   CALL SCHMIDT(VR,ISIZE)
   CALL PIKSRT2(ISIZE,ISIZE,ER,EI,VR,WK)
!  WRITE(*,*) 'FOCK EIGENVALUES:',ER
!  WRITE(*,*) 'FOCK EIGENVALUES:',EI
   ! ENERGY
   E1=0.0D0
   DO I=1,IOCC
    DO L=1,ISIZE
     DO M=1,ISIZE
      E1=E1+(GFOCK(L,M)+GCORE(L,M))*VR(L,I)*VR(M,I)
     ENDDO
    ENDDO
   ENDDO
   WRITE(*,*) 'ENERGY:',E1+NUCLEAR_REPULSION
   CALL PFLUSH(6)
   ! FORM MOS & RESIDUALS
   MORBITALS=0.0D0
!  MORBITALS=0.5D0*MORBITALS
   FXMO=0.0D0
   M=0
   DO I=1,ISIZE
    IF (DABS(EI(I)) < 1.0D-7) THEN
     M=M+1
     IF (M <= IOCC) THEN
      GEPSILON(M)=ER(I)
      DO J=1,ISIZE
       DO L=1,NGRID(K)
        MORBITALS(L,K,M)=MORBITALS(L,K,M)+AOBASIS(L,J)*VR(J,I)
        FXMO(L,M)=FXMO(L,M)+FXAO(L,J)*VR(J,I)
       ENDDO
      ENDDO
     ENDIF
    ENDIF
   ENDDO
!  ! SCHMIDT ORTHOGONALIZATION
   DO I=1,IOCC
    DO L=1,NGRID(K)
     RESIDUAL(L,I)=FXMO(L,I)-GEPSILON(I)*MORBITALS(L,K,I)
X=GRIDX(L,K)+ATOMX(K)
Y=GRIDY(L,K)+ATOMY(K)
Z=GRIDZ(L,K)+ATOMZ(K)
!IF (X == 0.0D0) WRITE(6,'(4F20.10)') Y,Z,FXMO(L,I),ER(I)*MORBITALS(L,K,I)
    ENDDO
!   DO J=1,ISIZE
!    T1=0.0D0
!    DO L=1,NGRID(K)
!     T1=T1+FXMO(L,I)*AOBASIS(L,J)*GRIDATOMW(L,K)
!    ENDDO
!    DO L=1,NGRID(K)
!     FXMO(L,I)=FXMO(L,I)-AOBASIS(L,J)*T1
!    ENDDO
!   ENDDO
    T1=0.0D0
    DO L=1,NGRID(K)
     T1=T1+RESIDUAL(L,I)**2*GRIDATOMW(L,K)
    ENDDO
    T1=DSQRT(T1)
!   IF (T1 > 1.0D-4) THEN
     WRITE(*,*) 'ORBITAL ENERGY ',GEPSILON(I),' RESIDUAL ',I,T1
     CALL EXPANDYLM2(LMAX,RESIDUAL(:,I),R1,RG,AG)
     IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'RESIDUAL')
     CALL PFLUSH(6)
!    ISIZE=ISIZE+1
!    DO L=1,NGRID(K)
!     AOBASIS(L,ISIZE)=FXMO(L,I)/T1
!    ENDDO
!   ENDIF
    IF (ITER < 50) THEN
     DO L=1,NGRID(K)
      RESIDUAL(L,I)=RESIDUAL(L,I)/(GDIAG(L)-GEPSILON(I))
     ENDDO
    ENDIF
   ENDDO
   DEALLOCATE(VR,VL,ER,EI,WK)
   DEALLOCATE(FS1,FOCKOLD)
   DEALLOCATE(WORK1,COUL,EXCH,FXAO,FXMO,R1,R2)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_N1
! Act nuclear attraction operator

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:,:)
   DOUBLE PRECISION :: X0,Y0,Z0
   DOUBLE PRECISION :: X1,Y1,Z1
   DOUBLE PRECISION :: R,N1,N2
   INTEGER :: I,J,K,L,M

   ALLOCATE(WORK1(MAXNGRID,NATOM))
   WRITE(6,'(A)') "NUCLEAR ATTRACTION"
   DO L=1,IOCC
    WORK1=0.0D0
    DO K=1,NATOM
     X0=ATOMX(K)
     Y0=ATOMY(K)
     Z0=ATOMZ(K)
     DO I=1,NATOM
      DO J=1,NGRID(I)
       X1=ATOMX(I)+GRIDX(J,I)
       Y1=ATOMY(I)+GRIDY(J,I)
       Z1=ATOMZ(I)+GRIDZ(J,I)
       WORK1(J,I)=WORK1(J,I)-DFLOAT(IATOM(K))*MORBITALS(J,I,L)/DSQRT((X1-X0)**2+(Y1-Y0)**2+(Z1-Z0)**2)
      ENDDO
     ENDDO
    ENDDO
    DO M=1,IOCC
     N1=0.0D0
     DO I=1,NATOM
      DO J=1,NGRID(I)
       N1=N1+WORK1(J,I)*MORBITALS(J,I,M)*GRIDW(J,I)
      ENDDO
     ENDDO
     N2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       N2=N2+DREAL(CO(I,M,0))*CO(J,L,0)*N_C(I,J,0)
      ENDDO
     ENDDO
     WRITE(6,'(2I3,2F15.10)') L,M,N1,N2
    ENDDO
   ENDDO
   DEALLOCATE(WORK1)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_N2
! Act nuclear attraction operator

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:)
   DOUBLE PRECISION :: X0,Y0,Z0
   DOUBLE PRECISION :: X1,Y1,Z1
   DOUBLE PRECISION :: R,N1,N2
   INTEGER :: I,J,K,L,M

   ALLOCATE(WORK1(MAXNGRID))
   K=1
   DO I=1,NATOM
    IF (IATOM(I) > IATOM(K)) K=I
   ENDDO
   WRITE(6,'(A,I3)') "NUCLEAR ATTRACTION ON ONE CENTER:",K
   DO L=1,IOCC
    WORK1=0.0D0
    DO I=1,NATOM
     X0=ATOMX(I)
     Y0=ATOMY(I)
     Z0=ATOMZ(I)
     DO J=1,NGRID(K)
      X1=ATOMX(K)+GRIDX(J,K)
      Y1=ATOMY(K)+GRIDY(J,K)
      Z1=ATOMZ(K)+GRIDZ(J,K)
      WORK1(J)=WORK1(J)-DFLOAT(IATOM(I))*MORBITALS(J,K,L)/DSQRT((X1-X0)**2+(Y1-Y0)**2+(Z1-Z0)**2)
     ENDDO
    ENDDO
    DO M=1,IOCC
     N1=0.0D0
     DO J=1,NGRID(K)
      N1=N1+WORK1(J)*MORBITALS(J,K,M)*GRIDATOMW(J,K)
     ENDDO
     N2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       N2=N2+DREAL(CO(I,M,0))*CO(J,L,0)*N_C(I,J,0)
      ENDDO
     ENDDO
     WRITE(6,'(2I3,2F15.10)') L,M,N1,N2
    ENDDO
   ENDDO
   DEALLOCATE(WORK1)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_T1
! Act kinetic operator

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R2(:,:,:)
   DOUBLE PRECISION :: T1,T2
   INTEGER :: I,J,L,M

   ALLOCATE(WORK1(MAXNGRID))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(R2(0:LMAX,-LMAX:LMAX,RG))
   WRITE(6,'(A)') "KINETIC"
   DO L=1,IOCC
    DO M=1,IOCC
     T1=0.0D0
     DO I=1,NATOM
      ! OBTAIN ATOMIC CONTRIBUTION
      DO J=1,NGRID(I)
       WORK1(J)=MORBITALS(J,I,L)*FUZZYW(J,I)
!      WORK1(J)=MORBITALS(J,I,L)
      ENDDO
      CALL EXPANDYLM2(LMAX,WORK1,R1,RG,AG)
      IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'ORBITAL')
      CALL KINETICYLM2(LMAX,R1,R2,RG,I)
      IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'KINETIC x ORBITAL')
      CALL PACKYLM2(LMAX,WORK1,R2,RG,AG)
      DO J=1,NGRID(I)
       T1=T1+WORK1(J)*MORBITALS(J,I,M)*GRIDATOMW(J,I)
!      T1=T1+WORK1(J)*MORBITALS(J,I,M)*GRIDW(J,I)
      ENDDO
     ENDDO
     T2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       T2=T2+DREAL(CO(I,M,0))*CO(J,L,0)*T_C(I,J,0)
      ENDDO
     ENDDO
     WRITE(6,'(2I3,2F15.10)') L,M,T1,T2
    ENDDO
   ENDDO
   DEALLOCATE(WORK1,R1,R2)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_T2
! Act kinetic operator on one center

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R2(:,:,:)
   DOUBLE PRECISION :: T1,T2
   INTEGER :: I,J,K,L,M

   ALLOCATE(WORK1(MAXNGRID))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(R2(0:LMAX,-LMAX:LMAX,RG))
   K=1
   DO I=1,NATOM
    IF (IATOM(I) > IATOM(K)) K=I
   ENDDO
   WRITE(6,'(A,I3)') "KINETIC ON ONE CENTER:",K
   DO L=1,IOCC
    DO M=1,IOCC
     T1=0.0D0
     ! OBTAIN ATOMIC CONTRIBUTION
     DO J=1,NGRID(K)
      WORK1(J)=MORBITALS(J,K,L)
     ENDDO
     CALL EXPANDYLM2(LMAX,WORK1,R1,RG,AG)
     IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'ORBITAL')
     CALL KINETICYLM2(LMAX,R1,R2,RG,K)
     IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'KINETIC x ORBITAL')
     CALL PACKYLM2(LMAX,WORK1,R2,RG,AG)
     DO J=1,NGRID(K)
      T1=T1+WORK1(J)*MORBITALS(J,K,M)*GRIDATOMW(J,K)
     ENDDO
     T2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       T2=T2+DREAL(CO(I,M,0))*CO(J,L,0)*T_C(I,J,0)
      ENDDO
     ENDDO
     WRITE(6,'(2I3,2F15.10)') L,M,T1,T2
    ENDDO
   ENDDO
   DEALLOCATE(WORK1,R1,R2)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_J1
! Act Coulomb repulsion operator

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: WORK2(:)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R2(:,:,:)
   DOUBLE PRECISION :: J1,J2
   INTEGER :: I,J,L,M

   ALLOCATE(WORK1(MAXNGRID,NATOM),WORK2(MAXNGRID))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(R2(0:LMAX,-LMAX:LMAX,RG))
   WRITE(6,'(A)') "COULOMB involving radial interpolation"
   WORK1=0.0D0
   DO I=1,NATOM
!  DO I=2,2
    ! OBTAIN ATOMIC CONTRIBUTION
    DO J=1,NGRID(I)
     WORK2(J)=RHO(J,I)*FUZZYW(J,I)
!    WORK2(J)=RHO(J,I)
    ENDDO
    CALL EXPANDYLM2(LMAX,WORK2,R1,RG,AG)
    IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'DENSITY')
    CALL POISSON2(LMAX,R1,R2,RG,I)
    IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'COULOMB POTENTIAL')
    DO L=1,NATOM
     IF (L == I) CALL PACKYLM2(LMAX,WORK2,R2,RG,AG)
     IF (L /= I) CALL PACKYLM3(L,I,LMAX,WORK2,R2,RG,AG)
     DO J=1,NGRID(L)
      WORK1(J,L)=WORK1(J,L)+WORK2(J)
     ENDDO
    ENDDO
!   CALL DUMP_POTENTIAL(WORK1,MAXNGRID,NATOM)
   ENDDO
   DO L=1,IOCC
    DO M=1,IOCC
     J1=0.0D0
     DO I=1,NATOM
      DO J=1,NGRID(I)
!      J1=J1+WORK1(J,I)*MORBITALS(J,I,L)*MORBITALS(J,I,M)*GRIDATOMW(J,I)
       J1=J1+WORK1(J,I)*MORBITALS(J,I,L)*MORBITALS(J,I,M)*GRIDW(J,I)
      ENDDO
     ENDDO
     J2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       J2=J2+DREAL(CO(I,M,0))*CO(J,L,0)*C_C(I,J,0)
      ENDDO
     ENDDO
     WRITE(6,'(2I3,2F15.10)') L,M,J1,J2
    ENDDO
   ENDDO
   DEALLOCATE(WORK1,WORK2,R1,R2)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_J2
! Act Coulomb repulsion operator on one center only

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: WORK2(:)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R2(:,:,:)
   DOUBLE PRECISION :: J1,J2
   INTEGER :: I,J,K,L,M

   ALLOCATE(WORK2(MAXNGRID))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(R2(0:LMAX,-LMAX:LMAX,RG))
   K=1
   DO I=1,NATOM
    IF (IATOM(I) > IATOM(K)) K=I
   ENDDO
   WRITE(6,'(A,I3)') "COULOMB ON CENTER:",K
   ! OBTAIN ATOMIC CONTRIBUTION
   DO J=1,NGRID(K)
    WORK2(J)=RHO(J,K)
   ENDDO
   CALL EXPANDYLM2(LMAX,WORK2,R1,RG,AG)
   IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'DENSITY')
   CALL POISSON2(LMAX,R1,R2,RG,K)
   IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'COULOMB POTENTIAL')
   CALL PACKYLM2(LMAX,WORK2,R2,RG,AG)
   DO L=1,IOCC
    DO M=1,IOCC
     J1=0.0D0
     DO J=1,NGRID(K)
      J1=J1+WORK2(J)*MORBITALS(J,K,L)*MORBITALS(J,K,M)*GRIDATOMW(J,K)
     ENDDO
     J2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       J2=J2+DREAL(CO(I,M,0))*CO(J,L,0)*C_C(I,J,0)
      ENDDO
     ENDDO
     WRITE(6,'(2I3,2F15.10)') L,M,J1,J2
    ENDDO
   ENDDO
   DEALLOCATE(WORK2,R1,R2)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_K2
! Act exchange operator on one center only

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:)
   DOUBLE PRECISION,ALLOCATABLE :: WORK2(:)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R2(:,:,:)
   DOUBLE PRECISION :: K1,K2
   INTEGER :: I,J,K,L,M

   ALLOCATE(WORK1(MAXNGRID))
   ALLOCATE(WORK2(MAXNGRID))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(R2(0:LMAX,-LMAX:LMAX,RG))
   K=1
   DO I=1,NATOM
    IF (IATOM(I) > IATOM(K)) K=I
   ENDDO
   WRITE(6,'(A,I3)') "EXCHANGE ON CENTER:",K
   ! OBTAIN ATOMIC CONTRIBUTION
   DO L=1,IOCC
    WORK1=0.0D0
    DO I=1,IOCC
     DO J=1,NGRID(K)
      WORK2(J)=MORBITALS(J,K,L)*MORBITALS(J,K,I)
     ENDDO
     CALL EXPANDYLM2(LMAX,WORK2,R1,RG,AG)
     IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'DENSITY')
     CALL POISSON2(LMAX,R1,R2,RG,K)
     IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'EXCHANGE POTENTIAL')
     CALL PACKYLM2(LMAX,WORK2,R2,RG,AG)
     DO J=1,NGRID(K)
      WORK1(J)=WORK1(J)-WORK2(J)*MORBITALS(J,K,I)
     ENDDO
    ENDDO
    DO M=1,IOCC
     K1=0.0D0
     DO J=1,NGRID(K)
      K1=K1+WORK1(J)*MORBITALS(J,K,M)*GRIDATOMW(J,K)
     ENDDO
     K2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       K2=K2-0.5D0*DREAL(CO(I,M,0))*CO(J,L,0)*X_C(I,J,0)
      ENDDO
     ENDDO
     WRITE(6,'(2I3,2F15.10)') L,M,K1,K2
    ENDDO
   ENDDO
   DEALLOCATE(WORK1,WORK2,R1,R2)
   RETURN
END SUBROUTINE



SUBROUTINE GRID_J3
! Act Coulomb repulsion operator with no interpolation

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,ALLOCATABLE :: WORK1(:,:)
   DOUBLE PRECISION,ALLOCATABLE :: WORK2(:)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:,:,:)
   DOUBLE PRECISION,ALLOCATABLE :: R2(:,:,:)
   DOUBLE PRECISION :: J1,J2
   INTEGER :: I,J,L,M

   ALLOCATE(WORK1(MAXNGRID,NATOM),WORK2(MAXNGRID))
   ALLOCATE(R1(0:LMAX,-LMAX:LMAX,RG))
   ALLOCATE(R2(0:LMAX,-LMAX:LMAX,RG))
   WRITE(6,'(A)') "COULOMB WITHOUT INTER/EXTRAPOLATION (NO FUZZY CELL)"
   WORK1=0.0D0
   DO I=1,NATOM
    DO J=1,NGRID(I)
     WORK2(J)=RHO(J,I)
    ENDDO
    CALL EXPANDYLM2(LMAX,WORK2,R1,RG,AG)
    IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R1,RG,'DENSITY')
    CALL POISSON2(LMAX,R1,R2,RG,I)
    IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,RG,'COULOMB POTENTIAL')
    CALL PACKYLM2(LMAX,WORK2,R2,RG,AG)
    DO J=1,NGRID(I)
     WORK1(J,I)=WORK2(J)
    ENDDO
   ENDDO
   IF (IOPTN(9) >= 2) CALL DUMP_POTENTIAL(WORK1,MAXNGRID,NATOM)
   DO L=1,IOCC
    DO M=1,IOCC
     J1=0.0D0
     DO I=1,NATOM
!    DO I=2,2
      DO J=1,NGRID(I)
!      J1=J1+WORK1(J,I)*MORBITALS(J,I,L)*MORBITALS(J,I,M)*GRIDATOMW(J,I)
       J1=J1+WORK1(J,I)*MORBITALS(J,I,L)*MORBITALS(J,I,M)*GRIDW(J,I)
      ENDDO
     ENDDO
     J2=0.0D0
     DO I=1,NCGS
      DO J=1,NCGS
       J2=J2+DREAL(CO(I,M,0))*CO(J,L,0)*C_C(I,J,0)
      ENDDO
     ENDDO
     WRITE(6,'(2I3,2F15.10)') L,M,J1,J2
    ENDDO
   ENDDO
   DEALLOCATE(WORK1,WORK2,R1,R2)
   RETURN
END SUBROUTINE



SUBROUTINE POISSON2(LM,R1,R2,NR,N)

   USE CONSTANTS
   USE CONTROL
   USE STRUCTURE
   USE INTEGRAL
   USE BASISSET
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: N
   INTEGER :: LM
   INTEGER :: NR
   DOUBLE PRECISION :: R1(0:LM,-LM:LM,NR)
   DOUBLE PRECISION :: R2(0:LM,-LM:LM,NR)
   DOUBLE PRECISION,ALLOCATABLE   :: W1(:)
   DOUBLE PRECISION,ALLOCATABLE :: W2(:,:),W3(:)
   INTEGER :: I,J,L,M,INFO
   INTEGER,ALLOCATABLE :: INDX(:)

   ALLOCATE(W1(NR),W2(NR,NR),W3(NR),INDX(NR))
   DO L=0,LM
    DO M=-L,L
     DO I=1,RG
      W1=0.0D0
      W1(I)=1.0D0
      CALL SECOND_DERIV_GAMMA(W1,NR,N)
!     CALL SECOND_DERIV_EPSILON(W1,NR,N)
      DO J=1,RG
       W2(J,I)=W1(J)
      ENDDO
      W2(I,I)=W2(I,I)-DFLOAT(L*(L+1))/GAUSS_CHEV(I,N)**2
     ENDDO
     DO I=1,RG
      W3(I)=-4.0D0*PI*R1(L,M,I)*GAUSS_CHEV(I,N)
     ENDDO
     CALL DGESV(NR,1,W2,NR,INDX,W3,NR,INFO)
     IF (INFO /= 0) CALL PABORT('DGESV FAILED')
     DO I=1,RG
      R2(L,M,I)=W3(I)/GAUSS_CHEV(I,N)
     ENDDO
    ENDDO
   ENDDO
   IF (IOPTN(9) >= 2) CALL DUMP12(LMAX,R2,NR,'COULOMB POTENTIAL')
   DEALLOCATE(W1,W2,W3,INDX)
   RETURN
END SUBROUTINE



SUBROUTINE EXPANDYLM2(LM,F,R,NR,NA)
! Expand a given function as a linear combination of radial spherical functions

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: LM
   INTEGER :: NR,NA
   DOUBLE PRECISION :: F(NA,NR)
   DOUBLE PRECISION :: YLM
   DOUBLE PRECISION :: R(0:LM,-LM:LM,NR)
   INTEGER :: I,J,L,M

   DO L=0,LMAX       ! LOOP OVER L
    DO M=-L,L        ! LOOP OVER M
     DO I=1,RG       ! LOOP OVER RADIAL GRID POINTS
      R(L,M,I)=0.0D0
      DO J=1,AG      ! LOOP OVER ANGULAR GRID POINTS
       CALL YLM2(L,M,I,J,YLM) ! GET R & YLM AT THE POINT
       R(L,M,I)=R(L,M,I)+YLM*F(J,I)*LEBEDVW(J)
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE PACKYLM2(LM,F,R,NR,NA)
! Expand a linear combination of radial spherical functions to real space

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: LM
   INTEGER :: NR,NA
   DOUBLE PRECISION :: F(NA,NR)
   DOUBLE PRECISION :: YLM
   DOUBLE PRECISION :: R(0:LM,-LM:LM,NR)
   INTEGER :: I,J,L,M

   DO I=1,RG       ! LOOP OVER RADIAL GRID POINTS
    DO J=1,AG      ! LOOP OVER ANGULAR GRID POINTS
     F(J,I)=0.0D0
     DO L=0,LMAX   ! LOOP OVER L
      DO M=-L,L    ! LOOP OVER M
       CALL YLM2(L,M,I,J,YLM) ! GET R & YLM AT THE POINT
       F(J,I)=F(J,I)+R(L,M,I)*YLM
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE YLM2(L,M,I,J,YLM)
! Returns the value of radius and real L,M spherical harmonics at a grid point (radial,angular)=(I,J)

   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: YLM
   INTEGER :: L,M
   INTEGER :: I,J

   YLM=YLMMEM(L,M,J)

   RETURN
END SUBROUTINE



SUBROUTINE YLM4
! Returns the value of radius and real L,M spherical harmonics at a grid point (radial,angular)=(I,J)

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION :: YLM
   INTEGER :: L,M
   INTEGER :: I,J,K
   DOUBLE PRECISION :: THETA,PHI
   DOUBLE PRECISION :: NORM
   DOUBLE PRECISION,EXTERNAL :: PLGNDR

   DO L=0,LMAX
    DO M=-L,L
     DO J=1,AG
      CALL C2SPHERICAL2(THETA,PHI,I,J)
      IF (M >= 0) THEN
       YLM=PLGNDR(L,IABS(M),DCOS(THETA))*DCOS(DFLOAT(IABS(M))*PHI)
      ELSE
       YLM=PLGNDR(L,IABS(M),DCOS(THETA))*DSIN(DFLOAT(IABS(M))*PHI)
      ENDIF
      NORM = DFLOAT(2*L+1)/4.0D0/PI
      IF (M /= 0) NORM=NORM*2.0D0
      IF (IABS(M) >= 1) THEN
       DO K=L-IABS(M)+1,L+IABS(M)
        NORM=NORM/DFLOAT(K)
       ENDDO
      ENDIF
      YLM=DSQRT(NORM)*YLM
      YLMMEM(L,M,J)=YLM
     ENDDO
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE C2SPHERICAL2(THETA,PHI,I,J)
! Returns the spherical coordinates of a grid point (radial,angular)=(I,J)

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: N
   INTEGER :: I,J
   DOUBLE PRECISION :: X,Y,Z
   DOUBLE PRECISION :: THETA,PHI

   X=LEBEDVX(J)
   Y=LEBEDVY(J)
   Z=LEBEDVZ(J)
   THETA=DACOS(Z)
   IF (X == 0.0D0) THEN
    IF (Y > 0.0D0) PHI=PI/2.0D0
    IF (Y < 0.0D0) PHI=-PI/2.0D0
   ELSE IF (Y == 0.0D0) THEN
    IF (X > 0.0D0) PHI=0.0D0
    IF (X < 0.0D0) PHI=-PI
   ELSE IF (X > 0.0D0) THEN
    PHI=DATAN(Y/X)
   ELSE
    PHI=DATAN(Y/X)+PI
   ENDIF
! DEBUG CODE ...
!  IF (DABS(Z-DCOS(THETA))>1.0D-10) WRITE(*,*) 'Z',Z,DCOS(THETA)
!  IF (DABS(X-DSIN(THETA)*DCOS(PHI))>1.0D-10) WRITE(*,*) 'X',X,DSIN(THETA)*DCOS(PHI)
!  IF (DABS(Y-DSIN(THETA)*DSIN(PHI))>1.0D-10) WRITE(*,*) 'Y',Y,DSIN(THETA)*DSIN(PHI)
! ... END DEBUG
   RETURN
END SUBROUTINE



SUBROUTINE PACKYLM3(IB,IA,LM,F,R,NR,NA)
! Return a numerical value of radial spherical functions of center A on a grid of center B

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER,PARAMETER :: INTORDER = 4
   INTEGER :: IA,IB
   INTEGER :: LM
   INTEGER :: NR,NA
   DOUBLE PRECISION :: F(NA,NR),RADIUS
   DOUBLE PRECISION :: RREAL,DY
   DOUBLE PRECISION :: YLM
   DOUBLE PRECISION :: R(0:LM,-LM:LM,NR)
   DOUBLE PRECISION,ALLOCATABLE :: X(:),Y(:)
   INTEGER :: I,J,K,L,M,P

   ALLOCATE(X(NR),Y(NR))
   X=GAUSS_CHEV(:,IA)
   DO I=1,RG       ! LOOP OVER RADIAL GRID POINTS OF ATOM IB
    DO J=1,AG      ! LOOP OVER ANGULAR GRID POINTS OF ATOM IB
     F(J,I)=0.0D0
     DO L=0,LMAX   ! LOOP OVER L CENTERED AT ATOM IA
      DO M=-L,L    ! LOOP OVER M CENTERED AT ATOM IA
       CALL YLM3(IB,IA,RADIUS,L,M,I,J,YLM) ! GET R & YLM AT THE POINT
       P=1
       DO K=1,RG
        IF (GAUSS_CHEV(K,IA) > RADIUS) P=K
       ENDDO
       P=MAX(1,MIN(P-1,NR-3))
       Y=R(L,M,:)
       CALL RATINT(X(P),Y(P),INTORDER,RADIUS,RREAL,DY)
       F(J,I)=F(J,I)+RREAL*YLM
      ENDDO
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(X,Y)
   RETURN
END SUBROUTINE



SUBROUTINE YLM3(IB,IA,RADIUS,L,M,I,J,YLM)
! Returns the value of radius and real L,M spherical harmonics at a grid point (radial,angular)=(I,J)

   USE CONSTANTS
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: IB,IA
   DOUBLE PRECISION :: RADIUS
   DOUBLE PRECISION :: YLM
   INTEGER :: L,M
   INTEGER :: I,J,K
   DOUBLE PRECISION :: THETA,PHI
   DOUBLE PRECISION :: NORM
   DOUBLE PRECISION,EXTERNAL :: PLGNDR

   CALL C2SPHERICAL3(IB,IA,RADIUS,THETA,PHI,I,J)
   IF (M >= 0) THEN
    YLM=PLGNDR(L,IABS(M),DCOS(THETA))*DCOS(DFLOAT(IABS(M))*PHI)
   ELSE
    YLM=PLGNDR(L,IABS(M),DCOS(THETA))*DSIN(DFLOAT(IABS(M))*PHI)
   ENDIF
   NORM = DFLOAT(2*L+1)/4.0D0/PI
   IF (M /= 0) NORM=NORM*2.0D0
   IF (IABS(M) >= 1) THEN
    DO K=L-IABS(M)+1,L+IABS(M)
     NORM=NORM/DFLOAT(K)
    ENDDO
   ENDIF
   YLM=DSQRT(NORM)*YLM
   RETURN
END SUBROUTINE



SUBROUTINE C2SPHERICAL3(IB,IA,RADIUS,THETA,PHI,I,J)
! Returns the spherical coordinates of a grid point (radial,angular)=(I,J)

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: IB,IA
   INTEGER :: N
   INTEGER :: I,J
   DOUBLE PRECISION :: X,Y,Z
   DOUBLE PRECISION :: THETA,PHI,RADIUS

   X=GAUSS_CHEV(I,IB)*LEBEDVX(J)+ATOMX(IB)-ATOMX(IA)
   Y=GAUSS_CHEV(I,IB)*LEBEDVY(J)+ATOMY(IB)-ATOMY(IA)
   Z=GAUSS_CHEV(I,IB)*LEBEDVZ(J)+ATOMZ(IB)-ATOMZ(IA)
   RADIUS=DSQRT(X**2+Y**2+Z**2)
   X=X/RADIUS
   Y=Y/RADIUS
   Z=Z/RADIUS
   THETA=DACOS(Z)
   IF (X == 0.0D0) THEN
    IF (Y > 0.0D0) PHI=PI/2.0D0
    IF (Y < 0.0D0) PHI=-PI/2.0D0
   ELSE IF (Y == 0.0D0) THEN
    IF (X > 0.0D0) PHI=0.0D0
    IF (X < 0.0D0) PHI=-PI
   ELSE IF (X > 0.0D0) THEN
    PHI=DATAN(Y/X)
   ELSE
    PHI=DATAN(Y/X)+PI
   ENDIF
! DEBUG CODE ...
!  IF (DABS(Z-DCOS(THETA))>1.0D-10) WRITE(*,*) 'Z',Z,DCOS(THETA)
!  IF (DABS(X-DSIN(THETA)*DCOS(PHI))>1.0D-10) WRITE(*,*) 'X',X,DSIN(THETA)*DCOS(PHI)
!  IF (DABS(Y-DSIN(THETA)*DSIN(PHI))>1.0D-10) WRITE(*,*) 'Y',Y,DSIN(THETA)*DSIN(PHI)
! ... END DEBUG
   RETURN
END SUBROUTINE



SUBROUTINE CONSTRUCT_GRID2
! CONSTRUCT GRID FOR NUMERICAL INTEGRATION IN DFT CALCULATIONS.

   USE CONSTANTS
   USE STRUCTURE
   USE DFT
   USE CONTROL
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,PARAMETER :: TARADI(17) = &
     (/0.800D0,0.900D0,1.800D0,1.400D0,1.300D0,1.100D0,0.900D0,0.900D0,0.900D0, &
       0.400D0,1.400D0,1.300D0,1.300D0,1.200D0,1.100D0,1.000D0,1.000D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   INTEGER :: I,J,K,L
   DOUBLE PRECISION :: R1,R2,X

   WRITE(6,'(A,I3,A,I5)') 'NUMERICAL GRID IS ',IOPTN(81),' *',IOPTN(82)
   RG=IOPTN(81)
   AG=IOPTN(82)
   DO I=1,NATOM
    NGRID(I)=IOPTN(81)*IOPTN(82)
    R1=BSRADI(IATOM(I))
    DO J=1,RG
     X=DCOS(DFLOAT(J)*PI/DFLOAT(RG+1))
     GAUSS_CHEV(J,I)=R1*(1.0D0+X)/(1.0D0-X)
     GAUSS_CHEV_W(J,I)=2.0D0*R1/(1.0D0-X)**2*PI/DFLOAT(RG+1)*DSIN(DFLOAT(J)*PI/DFLOAT(RG+1))*GAUSS_CHEV(J,I)**2
    ENDDO
    J=0
    CALL ANGULAR_GRID2(IOPTN(82),LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW)
    WRITE(6,'(A,I2,A,I3)') 'LEBEDEV GRID RANK FOR ATOM ',I,' IS ',LMAX
    DO K=1,IOPTN(81)
     R2=GAUSS_CHEV(K,I)
     DO L=1,IOPTN(82)
      J=J+1
      GRIDX(J,I)=R2*LEBEDVX(L)
      GRIDY(J,I)=R2*LEBEDVY(L)
      GRIDZ(J,I)=R2*LEBEDVZ(L)
      GRIDW(J,I)=GAUSS_CHEV_W(K,I)*LEBEDVW(L)
     ENDDO
    ENDDO
    IF (J /= NGRID(I)) CALL PABORT('AN INTERNAL PROGRAM ERROR IS DETECTED')
    IF (IOPTN(9) >= 2) THEN
     DO J=1,RG
      WRITE(6,'(I3,2F15.10)') J,GAUSS_CHEV(J,I),GAUSS_CHEV_W(J,I)
     ENDDO
    ENDIF
   ENDDO

   RETURN
END SUBROUTINE



SUBROUTINE ANGULAR_GRID2(I)
! CONSTRUCT ANGULAR GRID POINTS FOR LEBEDEV QUADRATURE.
! SEE V.I.LEBEDEV, ZH.VYCHISL.MAT.MAT.FIZ. 15,1,48 (1975); ZH.VYCHISL.MAT.MAT.FIZ. 16,2,293 (1976); SIB.MAT.ZH. 18,1,132 (1975).
! ***** CAUTION : THIS SUBROUTINE MAY NOT WORK CORRECTLY WHEN COMPILED WITH A VERY STRONG OPTIMIZATION OPTION.

   USE CONSTANTS
   USE SINANOGLU
   USE CONTROL

   IMPLICIT NONE
   INTEGER :: I,J,K,L,M,N
   DOUBLE PRECISION :: A

   IF (I == 1) THEN
    LMAX=0
    LEBEDVX(1)=1.0D0
    LEBEDVY(1)=0.0D0
    LEBEDVZ(1)=0.0D0
    LEBEDVW(1)=1.0D0
    K=1
   ELSE IF (I == 6) THEN
    LMAX=(3-1)/2
    CALL LD0006(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 14) THEN
    LMAX=(5-1)/2
    CALL LD0014(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 26) THEN
    LMAX=(7-1)/2
    CALL LD0026(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 38) THEN
    LMAX=(9-1)/2
    CALL LD0038(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 50) THEN
    LMAX=(11-1)/2
    CALL LD0050(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 74) THEN
    LMAX=(13-1)/2
    CALL LD0074(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 86) THEN
    LMAX=(15-1)/2
    CALL LD0086(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 110) THEN
    LMAX=(17-1)/2
    CALL LD0110(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 146) THEN
    LMAX=(19-1)/2
    CALL LD0146(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 170) THEN
    LMAX=(21-1)/2
    CALL LD0170(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 194) THEN
    LMAX=(23-1)/2
    CALL LD0194(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 230) THEN
    LMAX=(25-1)/2
    CALL LD0230(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 266) THEN
    LMAX=(27-1)/2
    CALL LD0266(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 302) THEN
    LMAX=(29-1)/2
    CALL LD0302(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 350) THEN
    LMAX=(31-1)/2
    CALL LD0350(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 434) THEN
    LMAX=(35-1)/2
    CALL LD0434(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 590) THEN
    LMAX=(41-1)/2
    CALL LD0590(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 770) THEN
    LMAX=(47-1)/2
    CALL LD0770(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 974) THEN
    LMAX=(53-1)/2
    CALL LD0974(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 1202) THEN
    LMAX=(59-1)/2
    CALL LD1202(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 1454) THEN
    LMAX=(65-1)/2
    CALL LD1454(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 1730) THEN
    LMAX=(71-1)/2
    CALL LD1730(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 2030) THEN
    LMAX=(77-1)/2
    CALL LD2030(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 2354) THEN
    LMAX=(83-1)/2
    CALL LD2354(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 2702) THEN
    LMAX=(89-1)/2
    CALL LD2702(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 3074) THEN
    LMAX=(95-1)/2
    CALL LD3074(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 3470) THEN
    LMAX=(101-1)/2
    CALL LD3470(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 3890) THEN
    LMAX=(107-1)/2
    CALL LD3890(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 4334) THEN
    LMAX=(113-1)/2
    CALL LD4334(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 4802) THEN
    LMAX=(119-1)/2
    CALL LD4802(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 5294) THEN
    LMAX=(125-1)/2
    CALL LD5294(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE IF (I == 5810) THEN
    LMAX=(131-1)/2
    CALL LD5810(LEBEDVX,LEBEDVY,LEBEDVZ,LEBEDVW,K)
   ELSE
    CALL PABORT('LEBEDEV GRID NOT FOUND')
   ENDIF
   IF (I.NE.K) CALL PABORT('LEBEDEV GRID IS CORRUPTED')
   A=0.0D0
   DO J=1,K
    A=A+LEBEDVW(J)
   ENDDO
   DO J=1,AG
    LEBEDVW(J)=LEBEDVW(J)*4.0D0*PI
   ENDDO
   IF (DABS(A-1.0D0) > 1.0D-10) THEN
    WRITE(*,*) A
    CALL PABORT('SUM OF SURFACE QUADRUTURE WEIGHTS DEVIATES FROM UNITY')
   ENDIF
   IF (IOPTN(9) >= 2) THEN
    DO J=1,AG
     WRITE(6,'(I3,4F15.10)') J,LEBEDVX(J),LEBEDVY(J),LEBEDVZ(J),LEBEDVW(J)
    ENDDO
   ENDIF
   RETURN
END SUBROUTINE



SUBROUTINE GRID_WEIGHT2
! CALCULATE THE WEIGHT FUNCTION FOR THE BECKE FUZZY CELLS WITH ATOMIC SIZE ADJUSTMENT.
! SEE A.D.BECKE, J.CHEM.PHYS. 88,2547 (1988); O.TREUTLER AND R.AHLRICHS, J.CHEM.PHYS. 102,346 (1995).

   USE STRUCTURE
   USE INTEGRAL
   USE DFT
   USE SINANOGLU

   IMPLICIT NONE
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   INTEGER :: Q1,Q2,I,J,K,N
   DOUBLE PRECISION :: X0,Y0,Z0,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3
   DOUBLE PRECISION :: R1,R2,R3,A0,M0
   DOUBLE PRECISION :: QX1,QC1,QS1,QX2,QC2,QS2
   DOUBLE PRECISION,ALLOCATABLE :: W(:,:,:),S(:)

   ALLOCATE(W(MAXNGRID,NATOM,-REDUCED_CEL1:REDUCED_CEL1),S(MAXNGRID))
   WRITE(6,'(A)') 'CALCULATE WEIGHT FACTORS FOR GAUSS-CHEBYSHEV-LEBEDEV QUADRATURE'
   DO I=1,NATOM
    DO J=1,NGRID(I)
     FUZZYW(J,I)=1.0D0
     GRIDATOMW(J,I)=GRIDW(J,I)
    ENDDO
   ENDDO
   DO I=1,NATOM
    X0=ATOMX(I)
    Y0=ATOMY(I)
    Z0=ATOMZ(I)
    DO Q1=-REDUCED_CEL1,REDUCED_CEL1
     DO J=1,NATOM
      DO N=1,NGRID(I)
       W(N,J,Q1)=1.0D0
      ENDDO
     ENDDO
    ENDDO
!   DO N=1,NGRID(I)
!    IF (ABS(INT((GRIDX(N,I)+X0)/PERIOD)) > CEL1) W(N,I,0)=0.0D0
!   ENDDO
    DO Q1=-REDUCED_CEL1,REDUCED_CEL1
     QX1=PERIOD*DFLOAT(Q1)
     QC1=DCOS(DFLOAT(Q1)*HELIX)
     QS1=DSIN(DFLOAT(Q1)*HELIX)
     DO J=1,NATOM
      X1=ATOMX(J)+QX1
      Y1=ATOMY(J)*QC1-ATOMZ(J)*QS1
      Z1=ATOMY(J)*QS1+ATOMZ(J)*QC1
      DO Q2=-REDUCED_CEL1,REDUCED_CEL1
       QX2=PERIOD*DFLOAT(Q1+Q2)
       QC2=DCOS(DFLOAT(Q1+Q2)*HELIX)
       QS2=DSIN(DFLOAT(Q1+Q2)*HELIX)
       DO K=1,NATOM
        IF ((Q2 == 0).AND.(K == J)) CYCLE
        X2=ATOMX(K)+QX2
        Y2=ATOMY(K)*QC2-ATOMZ(K)*QS2
        Z2=ATOMY(K)*QS2+ATOMZ(K)*QC2
        R1=DSQRT((X1-X2)**2+(Y1-Y2)**2+(Z1-Z2)**2)
        A0=DSQRT(BSRADI(IATOM(J))/BSRADI(IATOM(K)))
        A0=(A0-1.0D0)/(A0+1.0D0)
        A0=A0/(A0*A0-1.0D0)
        DO N=1,NGRID(I)
         X3=GRIDX(N,I)+X0
!        IF (ABS(INT(X3/PERIOD)) > CEL1) CYCLE
         Y3=GRIDY(N,I)+Y0
         Z3=GRIDZ(N,I)+Z0
         R2=DSQRT((X1-X3)**2+(Y1-Y3)**2+(Z1-Z3)**2)
         R3=DSQRT((X2-X3)**2+(Y2-Y3)**2+(Z2-Z3)**2)
         M0=(R2-R3)/R1
         M0=M0+A0*(1.0D0-M0*M0)
         M0=(1.5D0-0.5D0*M0*M0)*M0
         M0=(1.5D0-0.5D0*M0*M0)*M0
         M0=(1.5D0-0.5D0*M0*M0)*M0
         W(N,J,Q1)=W(N,J,Q1)*(0.5D0-0.5D0*M0)
        ENDDO
       ENDDO
      ENDDO
     ENDDO
    ENDDO
    DO N=1,NGRID(I)
     S(N)=0.0D0
    ENDDO
    DO Q1=-REDUCED_CEL1,REDUCED_CEL1
     DO J=1,NATOM
      DO N=1,NGRID(I)
       S(N)=S(N)+W(N,J,Q1)
      ENDDO
     ENDDO
    ENDDO
    DO N=1,NGRID(I)
     GRIDW(N,I)=GRIDW(N,I)*W(N,I,0)/S(N)
     FUZZYW(N,I)=FUZZYW(N,I)*W(N,I,0)/S(N)
!     if (dabs(w(n,i,0)/s(n)) > 0.4) write(40+i,*) atomx(i)+gridx(n,i),atomy(i)+gridy(n,i),atomz(i)+gridz(n,i)
    ENDDO
!do j=1,ngrid(i)
!if ((dabs(fuzzyw(j,i)) > 0.5).and.(gridx(j,i)**2+gridy(j,i)**2+gridz(j,i)**2 < 400.0).and.(i == 1)) &
!write(6,'(A,3F10.3)') 'H ',gridx(j,i)+atomx(i),gridy(j,i)+atomy(i),gridz(j,i)+atomz(i)
!if ((dabs(fuzzyw(j,i)) > 0.5).and.(gridx(j,i)**2+gridy(j,i)**2+gridz(j,i)**2 < 400.0).and.(i == 2)) &
!write(6,'(A,3F10.3)') 'O ',gridx(j,i)+atomx(i),gridy(j,i)+atomy(i),gridz(j,i)+atomz(i)
!if ((dabs(fuzzyw(j,i)) > 0.5).and.(gridx(j,i)**2+gridy(j,i)**2+gridz(j,i)**2 < 400.0).and.(i == 3)) &
!write(6,'(A,3F10.3)') 'H ',gridx(j,i)+atomx(i),gridy(j,i)+atomy(i),gridz(j,i)+atomz(i)
!enddo
   ENDDO
   DEALLOCATE(W,S)

   RETURN
END SUBROUTINE



SUBROUTINE KINETICYLM2(LM,R,RR,NR,N)
! Apply kinetic operator to a one-electron function expanded by YLM's.

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: N
   INTEGER :: LM
   INTEGER :: NR
   DOUBLE PRECISION :: R(0:LM,-LM:LM,NR)
   DOUBLE PRECISION :: RR(0:LM,-LM:LM,NR)
   INTEGER :: I,L,M
   DOUBLE PRECISION,ALLOCATABLE :: RLM1(:)

   ALLOCATE(RLM1(NR))

   DO L=0,LM
    DO M=-L,L
     DO I=1,RG
      RLM1(I)=R(L,M,I)*GAUSS_CHEV(I,N)
     ENDDO
     CALL SECOND_DERIV_BETA(RLM1,NR,N)
     DO I=1,RG
      RR(L,M,I)=-0.5D0*(RLM1(I)/GAUSS_CHEV(I,N)-DFLOAT(L*(L+1))*R(L,M,I)/(GAUSS_CHEV(I,N)**2))
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(RLM1)

   RETURN
END SUBROUTINE



SUBROUTINE SECOND_DERIV_BETA(R,NR,N)
! 7- and 9-point finite-difference second differentiation
! Functions are zero at both boundaries.

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: N
   INTEGER :: NR
   DOUBLE PRECISION :: R(NR)
   DOUBLE PRECISION :: H
   DOUBLE PRECISION,ALLOCATABLE :: R1D(:)
   DOUBLE PRECISION,ALLOCATABLE :: R2D(:)
   INTEGER :: I
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   DOUBLE PRECISION :: R0,X,OMEGA

   ALLOCATE(R1D(NR),R2D(NR))
   H=PI/DFLOAT(RG+1)

   ! FIRST DERIVATIVES
   R1D(1)=(-924.0D0*R(1)+1800.0D0*R(2)-1200.0D0*R(3)+600.0D0*R(4)-180.0D0*R(5)+24.0D0*R(6))/(720.0D0*H)
   R1D(2)=(-288.0D0*R(1)-420.0D0*R(2)+960.0D0*R(3)-360.0D0*R(4)+96.0D0*R(5)-12.0D0*R(6))/(720.0D0*H)
   R1D(3)=(+108.0D0*R(1)-540.0D0*R(2)+540.0D0*R(4)-108.0D0*R(5)+12.0D0*R(6))/(720.0D0*H)
   R1D(4)=(-12.0D0*R(1)+108.0D0*R(2)-540.0D0*R(3)+540.0D0*R(5)-108.0D0*R(5)+12.0D0*R(7))/(720.0D0*H)
   R1D(RG-3)=(-12.0D0*R(RG-6)+108.0D0*R(RG-5)-540.0D0*R(RG-4)+540.0D0*R(RG-2)-108.0D0*R(RG-1)+12.0D0*R(RG))/(720.0D0*H)
   R1D(RG-2)=(-12.0D0*R(RG-5)+108.0D0*R(RG-4)-540.0D0*R(RG-3)+540.0D0*R(RG-1)-108.0D0*R(RG))/(720.0D0*H)
   R1D(RG-1)=(+12.0D0*R(RG-5)-96.0D0*R(RG-4)+360.0D0*R(RG-3)-960.0D0*R(RG-2)+420.0D0*R(RG-1)+288.0D0*R(RG))/(720.0D0*H)
   R1D(RG)=(-24.0D0*R(RG-5)+180.0D0*R(RG-4)-600.0D0*R(RG-3)+1200.0D0*R(RG-2)-1800.0D0*R(RG-1)+924.0D0*R(RG))/(720.0D0*H)
   DO I=5,RG-4
    R1D(I)=(+144.0D0*R(I-4)-1536.0D0*R(I-3)+8064.0D0*R(I-2)-32256.0D0*R(I-1) &
           +32256.0D0*R(I+1)-8064.0D0*R(I+2)+1536.0D0*R(I+3)-144.0D0*R(I+4))/(40320.0D0*H)
   ENDDO

   ! SECOND DERIVATIVES
   R2D(1)=(-294.0D0*R(1)-510.0D0*R(2)+940.0D0*R(3)-570.0D0*R(4)+186.0D0*R(5)-26.0D0*R(6))/(360.0D0*H**2)
   R2D(2)=(+456.0D0*R(1)-840.0D0*R(2)+400.0D0*R(3)+30.0D0*R(4)-24.0D0*R(5)+4.0D0*R(6))/(360.0D0*H**2)
   R2D(3)=(-54.0D0*R(1)+540.0D0*R(2)-980.0D0*R(3)+540.0D0*R(4)-54.0D0*R(5)+4.0D0*R(6))/(360.0D0*H**2)
   R2D(4)=(+4.0D0*R(1)-54.0D0*R(2)+540.0D0*R(3)-980.0D0*R(4)+540.0D0*R(5)-54.0D0*R(6)+4.0D0*R(7))/(360.0D0*H**2)
   R2D(RG-3)=(+4.0D0*R(RG-6)-54.0D0*R(RG-5)+540.0D0*R(RG-4)-980.0D0*R(RG-3) &
              +540.0D0*R(RG-2)-54.0D0*R(RG-1)+4.0D0*R(RG))/(360.0D0*H**2)
   R2D(RG-2)=(+4.0D0*R(RG-5)-54.0D0*R(RG-4)+540.0D0*R(RG-3)-980.0D0*R(RG-2)+540.0D0*R(RG-1)-54.0D0*R(RG))/(360.0D0*H**2)
   R2D(RG-1)=(+4.0D0*R(RG-5)-24.0D0*R(RG-4)+30.0D0*R(RG-3)+400.0D0*R(RG-2)-840.0D0*R(RG-1)+456.0D0*R(RG))/(360.0D0*H**2)
   R2D(RG)=(-26.0D0*R(RG-5)+186.0D0*R(RG-4)-570.0D0*R(RG-3)+940.0D0*R(RG-2)-510.0D0*R(RG-1)-294.0D0*R(RG))/(360.0D0*H**2)
   DO I=5,RG-4
    R2D(I)=(-36.0D0*R(I-4) +512.0D0*R(I-3)-4032.0D0*R(I-2)+32256.0D0*R(I-1)-57400.0D0*R(I) &
            +32256.0D0*R(I+1)-4032.0D0*R(I+2)+512.0D0*R(I+3)-36.0D0*R(I+4))/(20160.0D0*H**2)
   ENDDO

   R0=BSRADI(IATOM(N))
   DO I=1,RG
    OMEGA=DFLOAT(I)*PI/DFLOAT(RG+1)
    X=DCOS(OMEGA)
    R(I)=+R1D(I)*((1.0D0-X)**3/(2.0D0*R0**2*DSIN(OMEGA)) &
         -(1.0D0-X)**4*DCOS(OMEGA)/(4.0D0*R0**2*DSIN(OMEGA)**3)) &
         +R2D(I)*((1.0D0-X)**2/(2.0D0*R0*DSIN(OMEGA)))**2
   ENDDO

   DEALLOCATE(R2D,R1D)
   RETURN
END SUBROUTINE



SUBROUTINE SECOND_DERIV_EPSILON(R,NR,N)
! 7-point finite-difference second differentiation
! (1/r)(d2/dr2)r r^-1f(r) = (1/r)(d2x/dr2)(df/dx) + (1/r)(dx/dr)^2(d2f/dx2)

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: N
   INTEGER :: NR
   DOUBLE PRECISION :: R(NR)
   DOUBLE PRECISION :: H
   DOUBLE PRECISION,ALLOCATABLE :: R1D(:)
   DOUBLE PRECISION,ALLOCATABLE :: R2D(:)
   INTEGER :: I
   DOUBLE PRECISION,PARAMETER :: BSRADI(17) = &
     (/0.472D0,0.472D0,1.370D0,0.992D0,0.803D0,0.661D0,0.614D0,0.567D0,0.472D0, &
       0.472D0,1.701D0,1.417D0,1.181D0,1.039D0,0.945D0,0.945D0,0.945D0/) ! Ne DATA WAS MISSING IN THE ORIGINAL
   DOUBLE PRECISION :: R0,X,OMEGA

   ALLOCATE(R1D(NR),R2D(NR))
   H=PI/DFLOAT(RG+1)

   ! FIRST DERIVATIVES
   R1D(1)=(-1764.0D0*R(1)+4320.0D0*R(2)-5400.0D0*R(3)+4800.0D0*R(4)-2700.0D0*R(5)+864.0D0*R(6)-120.0D0*R(7))/(720.0D0*H)
   R1D(2)=(-120.0D0*R(1)-924.0D0*R(2)+1800.0D0*R(3)-1200.0D0*R(4)+600.0D0*R(5)-180.0D0*R(6)+24.0D0*R(7))/(720.0D0*H)
   R1D(3)=(24.0D0*R(1)-288.0D0*R(2)-420.0D0*R(3)+960.0D0*R(4)-360.0D0*R(5)+96.0D0*R(6)-12.0D0*R(7))/(720.0D0*H)
   R1D(4)=(-12.0D0*R(1)+108.0D0*R(2)-540.0D0*R(3)+540.0D0*R(5)-108.0D0*R(6)+12.0D0*R(7))/(720.0D0*H)
   R1D(RG-3)=(-12.0D0*R(RG-6)+108.0D0*R(RG-5)-540.0D0*R(RG-4)+540.0D0*R(RG-2)-108.0D0*R(RG-1)+12.0D0*R(RG))/(720.0D0*H)
   R1D(RG-2)=(-12.0D0*R(RG-5)+108.0D0*R(RG-4)-540.0D0*R(RG-3)+540.0D0*R(RG-1)-108.0D0*R(RG))/(720.0D0*H)
   R1D(RG-1)=(+12.0D0*R(RG-5)-96.0D0*R(RG-4)+360.0D0*R(RG-3)-960.0D0*R(RG-2)+420.0D0*R(RG-1)+288.0D0*R(RG))/(720.0D0*H)
   R1D(RG)=(-24.0D0*R(RG-5)+180.0D0*R(RG-4)-600.0D0*R(RG-3)+1200.0D0*R(RG-2)-1800.0D0*R(RG-1)+924.0D0*R(RG))/(720.0D0*H)
   DO I=5,RG-4
    R1D(I)=(+144.0D0*R(I-4)-1536.0D0*R(I-3)+8064.0D0*R(I-2)-32256.0D0*R(I-1) &
           +32256.0D0*R(I+1)-8064.0D0*R(I+2)+1536.0D0*R(I+3)-144.0D0*R(I+4))/(40320.0D0*H)
   ENDDO

   ! SECOND DERIVATIVES
   R2D(1)=(1624.0D0*R(1)-6264.0D0*R(2)+10530.0D0*R(3)-10160.0D0*R(4)+5940.0D0*R(5)-1944.0D0*R(6)+274.0D0*R(7))/(360.0D0*H**2)
   R2D(2)=(274.0D0*R(1)-294.0D0*R(2)-510.0D0*R(3)+940.0D0*R(4)-570.0D0*R(5)+186.0D0*R(6)-26.0D0*R(7))/(360.0D0*H**2)
   R2D(3)=(-26.0D0*R(1)+456.0D0*R(2)-840.0D0*R(3)+400.0D0*R(4)+30.0D0*R(5)-24.0D0*R(6)+4.0D0*R(7))/(360.0D0*H**2)
   R2D(4)=(4.0D0*R(1)-54.0D0*R(2)+540.0D0*R(3)-980.0D0*R(4)+540.0D0*R(5)-54.0D0*R(6)+4.0D0*R(7))/(360.0D0*H**2)
   R2D(RG-3)=(4.0D0*R(RG-6)-54.0D0*R(RG-5)+540.0D0*R(RG-4)-980.0D0*R(RG-3)+540.0D0*R(RG-2)-54.0D0*R(RG-1)+4.0D0*R(RG)) &
            /(360.0D0*H**2)
   R2D(RG-2)=(+4.0D0*R(RG-5)-54.0D0*R(RG-4)  +540.0D0*R(RG-3)-980.0D0*R(RG-2)+540.0D0*R(RG-1)-54.0D0*R(RG))/(360.0D0*H**2)
   R2D(RG-1)=(+4.0D0*R(RG-5)-24.0D0*R(RG-4)   +30.0D0*R(RG-3)+400.0D0*R(RG-2)-840.0D0*R(RG-1)+456.0D0*R(RG))/(360.0D0*H**2)
   R2D(RG)=(-26.0D0*R(RG-5)+186.0D0*R(RG-4)  -570.0D0*R(RG-3)+940.0D0*R(RG-2)-510.0D0*R(RG-1)-294.0D0*R(RG))/(360.0D0*H**2)
   DO I=5,RG-4
    R2D(I)=(-36.0D0*R(I-4) +512.0D0*R(I-3)-4032.0D0*R(I-2)+32256.0D0*R(I-1)-57400.0D0*R(I) &
            +32256.0D0*R(I+1)-4032.0D0*R(I+2)+512.0D0*R(I+3)-36.0D0*R(I+4))/(20160.0D0*H**2)
   ENDDO

   R0=BSRADI(IATOM(N))
   DO I=1,RG
    OMEGA=DFLOAT(I)*PI/DFLOAT(RG+1)
    X=DCOS(OMEGA)
    R(I)=+R1D(I)*((1.0D0-X)**3/(2.0D0*R0**2*DSIN(OMEGA)) &
         -(1.0D0-X)**4*DCOS(OMEGA)/(4.0D0*R0**2*DSIN(OMEGA)**3)) &
         +R2D(I)*((1.0D0-X)**2/(2.0D0*R0*DSIN(OMEGA)))**2
   ENDDO

   DEALLOCATE(R2D,R1D)
   RETURN
END SUBROUTINE



SUBROUTINE SECOND_DERIV_GAMMA(R,NR,N)

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: N
   INTEGER :: NR
   DOUBLE PRECISION :: R(NR)
   DOUBLE PRECISION,ALLOCATABLE :: R1(:)

   ALLOCATE(R1(NR))
   CALL DGBMV('N',NR,NR,7,7,1.0D0,SECONDDERIV(:,:,N),15,R,1,0.0D0,R1,1)
   R=R1
   DEALLOCATE(R1)
   RETURN
END SUBROUTINE



SUBROUTINE SECOND_DERIV_DELTA

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU

   IMPLICIT NONE
   INTEGER :: I,J,K,N
   DOUBLE PRECISION,ALLOCATABLE :: R(:)

   ALLOCATE(R(RG))
   DO N=1,NATOM
    DO I=1,RG
     R=0.0D0
     R(I)=1.0D0
     CALL SECOND_DERIV_EPSILON(R,RG,N)
     K=8-I
     DO J=MAX(1,I-7),MIN(RG,I+7)
      SECONDDERIV(K+J,I,N)=R(J)
     ENDDO
    ENDDO
   ENDDO
   DEALLOCATE(R)
   RETURN
END SUBROUTINE



SUBROUTINE polint(xa,ya,n,x,y,dy)

IMPLICIT NONE
INTEGER :: n,NMAX
DOUBLE PRECISION :: dy,x,y,xa(n),ya(n)
PARAMETER (NMAX=10)
INTEGER :: i,m,ns
DOUBLE PRECISION :: den,dif,dift,ho,hp,w,c(NMAX),d(NMAX)
ns=1
dif=dabs(x-xa(1))
do i=1,n
  dift=dabs(x-xa(i))
  if (dift.lt.dif) then
    ns=i
    dif=dift
  endif
  c(i)=ya(i)
  d(i)=ya(i)
enddo
y=ya(ns)
ns=ns-1
do m=1,n-1
  do i=1,n-m
    ho=xa(i)-x
    hp=xa(i+m)-x
    w=c(i+1)-d(i)
    den=ho-hp
    if(den.eq.0.0d0) pause 'failure in polint'
    den=w/den
    d(i)=hp*den
    c(i)=ho*den
  enddo
  if (2*ns.lt.n-m)then
    dy=c(ns+1)
  else
    dy=d(ns)
    ns=ns-1
  endif
  y=y+dy
enddo
return
END



SUBROUTINE ratint(xa,ya,n,x,y,dy)
IMPLICIT NONE
INTEGER n,NMAX
DOUBLE PRECISION dy,x,y,xa(n),ya(n),TINY
PARAMETER (NMAX=10,TINY=1.d-25)
INTEGER i,m,ns
DOUBLE PRECISION dd,h,hh,t,w,c(NMAX),d(NMAX)
ns=1
hh=dabs(x-xa(1))
do i=1,n
  h=dabs(x-xa(i))
  if (h.eq.0.0d0)then
    y=ya(i)
    dy=0.0d0
    return
  else if (h.lt.hh) then
    ns=i
    hh=h
  endif
  c(i)=ya(i)
  d(i)=ya(i)+TINY
enddo
y=ya(ns)
ns=ns-1
do m=1,n-1
  do i=1,n-m
    w=c(i+1)-d(i)
    h=xa(i+m)-x
    t=(xa(i)-x)*d(i)/h
    dd=t-c(i+1)
    if(dd.eq.0.0d0) pause 'failure in ratint'
    dd=w/dd
    d(i)=c(i+1)*dd
    c(i)=t*dd
  enddo
  if (2*ns.lt.n-m)then
    dy=c(ns+1)
  else
    dy=d(ns)
    ns=ns-1
  endif
  y=y+dy
enddo
return
END



SUBROUTINE DUMP_POTENTIAL(POTENTIAL,NG,NA)

   USE CONSTANTS
   USE STRUCTURE
   USE SINANOGLU
   USE DFT

   IMPLICIT NONE
   INTEGER :: NG,NA
   INTEGER :: I,J
   DOUBLE PRECISION :: POTENTIAL(NG,NA)
   DOUBLE PRECISION :: X,Y,Z

   DO I=1,NA
    DO J=1,NGRID(I)
     X=GRIDX(J,I)+ATOMX(I)
     Y=GRIDY(J,I)+ATOMY(I)
     Z=GRIDZ(J,I)+ATOMZ(I)
     IF (X == 0.0D0) WRITE(6,'(3F20.10)') Y,Z,POTENTIAL(J,I)
!    IF ((X == 0.0D0).AND.(Y == 0.0D0)) WRITE(6,'(2F20.10)') Z,POTENTIAL(J,I)
!    WRITE(6,'(4F20.10)') X,Y,Z,POTENTIAL(J,I)
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE



SUBROUTINE SCHMIDT(A,N)

   IMPLICIT NONE
   INTEGER :: N,I,J,K
   DOUBLE PRECISION :: A(N,N)
   DOUBLE PRECISION :: B

   B=0.0D0
   DO J=1,N
    B=B+A(J,1)**2
   ENDDO
   B=DSQRT(B)
   DO J=1,N
    A(J,1)=A(J,1)/B
   ENDDO
   DO I=2,N
    DO J=1,I-1
     B=0.0D0
     DO K=1,N
      B=B+A(K,I)*A(K,J)
     ENDDO
     DO K=1,N
      A(K,I)=A(K,I)-B*A(K,J)
     ENDDO
    ENDDO
    B=0.0D0
    DO J=1,N
     B=B+A(J,I)**2
    ENDDO
    B=DSQRT(B)
    DO J=1,N
     A(J,I)=A(J,I)/B
    ENDDO
   ENDDO
   RETURN
END SUBROUTINE
